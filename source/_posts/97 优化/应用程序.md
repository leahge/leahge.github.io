---
title: 应用程序
date: 2024-01-23 14:25:45
tags:
---

# 概述
性能调优工作离工作所执行的地方越近越好：最好在应用程序里。应用程序性能分析包括配置应用程序实现系统资源的最佳利用。

# 性能监控分析工具
| 工具  | 说明 |
| ---------------- | --------------------------- |
| perf  | CPU剖析、CPU火焰图、系统调用跟踪   |
| strace  | 系统调用跟踪 |
|bpftrace| 信号跟踪、I/O剖析、锁分析|

# 优化方法
## 编译优化
C/C++代码在编译时，GCC编译器将源码翻译成CPU可识别的指令序列，写入可执行程序的二进制文件中。CPU在执行指令时，通常采用流水线的方式并行执行指令，以提高性能，因此指令执行顺序的编排将对流水线执行效率有很大影响。通常在指令流水线中要考虑：执行指令计算的硬件资源数量、不同指令的执行周期、指令间的数据依赖等等因素。我们可以通过通知编译器，程序所运行的目标平台（CPU）指令集、流水线，来获取更好的指令序列编排。
1. 使用最新的编译器，充分利用架构最新的指令集，在CFLAGS和CPPFLAGS里面增加编译选项：
`-mcpu=neoverse-n2` 或 `-march=armv9-a`
2. ARM常用编译参数

| 参数	| 说明  |
|-----|------|
|-mabi=lp64	|生成64位ABI, Long-Pointer 64|
|-funroll-loops	|循环优化，展开在编译时能够确定循环次数的循环体|
|-flto=32	|链接时优化|
|--param early-inlining-insns=96	|内联优化，Specify growth that the early inliner can make，编译器默认是14.|
|--param max-inline-insns-auto=64	|内联优化，在指定-O3参数的情况下编译器可能不会更多的产生内联替代，修改该参数可以让编译器尽可能的对函数内联替代，编译器默认是30.|
|--param inline-unit-growth=96	|内联优化，Specifies maximal overall growth of the compilation unit caused by inlining.编译器默认是20.|
|-fcommon	|未初始化全局变量|

## 编码优化
### 减少内存拷贝
1. 使用sendfile代替send/sendto/write等函数将文件发送给对端。内核通过DMA将文件搬运到缓存（一次内存拷贝），然后把缓存的描述信息（位置和长度）传递给TCP/IP协议栈，内核在通过DMA将缓存搬运到网卡（第二次内存拷贝）。
2. 进程间通信使用共享内存代替socket/pipe通信。应用程序可以使用shmget等函数实现进程间通信。
### 提高流水
1. 使用 SVE
可扩展向量扩展 (SVE) 需要足够新的工具链来自动向量化为 SVE（GCC 11+、LLVM 14+）和支持 SVE 的 4.15+ 内核。

2. 软件预取
数据预取通过将代码中后续可能使用到的数据提前加载到cache中，减少CPU等待数据从内存中加载的时间，提升cache命中率，进而提升软件的运行效率。

3. 循环优化
充分利用CPU的指令单元，增加计算密度，对循环进行优化。

### cache优化
1. 减少跨NUMA访问
2. 避免伪共享：CPU标识Cache中的数据是否为有效数据不是以内存位宽为单位，而是以Cacheline为单位。这个机制可能会导致伪共享（false sharing）现象，从而使得CPU的Cache命中率变低。出现伪共享的常见原因是高频访问的数据未按照Cacheline大小对齐。ZF芯片的Cacheline为64字节。
3. 减少cache miss。常用优化手段如：数据结构布局优化，读取顺序调整，一提高cacheline的有效性，提高cache命中率。


### 提高并发和并行度
1. 使用非阻塞I/O
2. 调整多线程/多进程/协程并发数。多线程/多进程，可以充分利用CPU和内存资源，但应用的性能不会随进程/线程的增长而线性提升，比如线程间的调度、上下文切换、所竞争等都会影响并发性能，所以要针对业务模型选择合适的并发数量。

### 锁优化
1.编译器需要为应用使用原子操作产生LSE指令。LSE 提供低成本的原子操作，可以提高 CPU 到 CPU 通信、锁和互斥锁的系统吞吐量。当使用 LSE 而不是加载/存储独占时，改进可以达到一个数量级。GCC的标志 -march=armv8.2-a，使能了LSE。可以通过这个方式来确认LSE指令是否被创建，
```
objdump -d app | grep -i 'cas\|casp\|swp\|ldadd\|stadd\|ldclr\|stclr\|ldeor\|steor\|ldset\|stset\|ldsmax\|stsmax\|ldsmin\|stsmin\|ldumax\|stumax\|ldumin\|stumin' | wc -l
```

2. 同理，在编码时，如果使用汇编，则使用ARM最新的原子操作



## 库优化
使用优化的库代替系统默认库
1.jemalloc：jemalloc是一款内存分配器，与其它内存分配器（glibc）相比，其最大优势在于多线程场景下内存分配性能高以及内存碎片减少。在内存分配过程中，锁会造成线程等待，对性能影响巨大。jemalloc采用如下措施避免线程竞争锁的发生：使用线程变量，每个线程有自己的内存管理器，分配在这个线程内完成，就不需要和其它线程竞争锁。很多应用都可以通过编译参数或者配置文件指定内存分配库。
2. ARM性能库和ARM计算库（ACL）：Arm性能库是一组具有BLAS、LAPACK、FFT和稀疏线性代数功能的优化库。这些库针对Arm的Neoverse系列处理器进行了调整。ACL是一个用于机器学习和计算机视觉的高性能 C++ 库。它提供了一系列优化的算法和操作，可在 ARM CPU、GPU 和 DSP 上执行。开发者可以用它来优化在Armv9架构CPU和GPU上的机器学习应用开发。
