---
title: spinlock性能分析
date: 2024-02-06 10:56:16
tags:
---

## 问题描述：

对比Z和K两个cpu处理效率
|场景|Z|K|
|---|---|---|
|单线程 |11us  |11us|
|8线程一次调用耗时|82us|37us|
|8线程spinlock+保护区+spinlock|62us |5.3us|
|8线程保护区|7.6us |4.4us|

这里Z cpu的spinlock处理时间过长

## 问题分析

spinlock保护区内地代码是不可并行部分，即这部分8个线程只能串行执行，所以性能最高为8×保护区+并行处理拖尾  

由上面（8线程一次调用耗时）的时长 -  （8线程spinlock+保护区+spinlock）获得拖尾时间，Z为20us，K为31.7us。而保护区内Z为7.6us，K为4.4us

## 首先分析K

如下图红色部分为4.4us的保护区，后面白色框为自旋锁外可并行处理部分，时长约为31.7us。

极端情况下，如图左侧，最开始8个线程分别收到8个处理消息，保护区部分基本同时到达，经过第一轮的自旋锁的串行处理后，如图中间部分。由于并行处理部分31.7us>7\*4.4us,所以下一轮处理时（图右侧），第一个自旋锁到来时并不会跟前面的锁抢锁，所以后续处理每个线程的锁保护区都可能不会和其他线程的自旋锁冲突，所以自旋锁处理部分就很小，锁开销5.3-4.4 < 1us

<img src="./CjYTPWXBj2KABBg1AAA87pt6dWc999.png">

## 分析Z

如下图红色部分为7.6us的保护区，后面白色框为自旋锁外可并行处理部分，时长约为20us。

极端情况下，如图左侧，最开始8个线程分别收到8个处理消息，保护区部分基本同时到达，经过第一轮的自旋锁的串行处理后，如图中间部分。由于并行处理部分小于串行部分,所以下一轮处理到达时（图中蓝色部分），自旋锁需要等前面的锁处理完成，蓝色+橙色部分就是等待锁的时间，这里时间为62-7.6=53.4us，约为7个串行处理时间7.6×7=53.2us。所以这62us的8线程 spinlock+testq\_put+spinlock耗时是正常的

##         ![](spinlock%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%20-%20CPU%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%20-%20iCenter/CjYTPWXBn1mADjZVAABbcZPY7_4052.png)
