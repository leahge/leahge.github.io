<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	  
<script src="/js/search.js"></script>

	<!-- title -->
	
	<title>
	
		Hugeadm |
	
	LeahGe
	</title>

	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "leahge.github.io";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>


	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.4.14/dist/Valine.min.js"></script>

	
	
	<script type="text/javascript">

		var search_path = "/search.xml";
		if (search_path.length == 0) {
			search_path = "search.xml";
		}
		var path = search_path;
		searchFunc(path, 'local-search-input', 'local-search-result');
	</script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">LeahGe</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	

	

		<li class="menu-item">
			<a href="https://github.com/leahge" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
		<li class="menu-item">
			<form class="">
				<button class="btn text-muted fa fa-search d-none d-md-block d-lg-block" style="background-color: transparent;"
					disabled></button>
				<input id="local-search-input" class="form-control me-2 pe-4" type="search" aria-label="Search">
				<div id="local-search-result"
					style="position:absolute; padding-top: 8px; max-height: 960px; width: 480px;overflow-y: scroll; z-index: 1050;">
				</div>
			</form>
		</li>
	</ul>


</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 OS
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Linux
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Kernel
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/Kernel/kallsyms/">
                     
										    Kallsyms
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/31/01%20OS/Linux/Kernel/kernel_config/">
                     
										    Linux Kernel 编译选项
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Perf
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf-report/">
                     
										    Perf-Report(1) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf-script/">
                     
										    Perf-Script(1) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf-stat/">
                     
										    Perf-Stat(1)
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/28/01%20OS/Linux/Perf/perf_event/">
                     
										    PMU计数器
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_hardware/">
                     
										    PERF EVENT 硬件篇
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_hardware2/">
                     
										    PERF EVENT 硬件篇续篇
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_ipc/">
                     
										    Perf IPC以及CPU利用率
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_kernel/">
                     
										    PERF EVENT 内核篇
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/Perf/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">
                     
										    参考资料
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Shell
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Shell/ctrlc/">
                     
										    Linux Shell中捕获CTRL+C
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/Shell/stringcut/">
                     
										    Shell字符串截取
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										network
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/31/01%20OS/Linux/network/gro/">
                     
										    Linux Kernel 网络协议栈之GRO
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/network/irq/">
                     
										    网卡多队列配置和中断绑定
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/31/01%20OS/Linux/network/napi/">
                     
										    Linux协议栈--NAPI机制
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/systemd/">
                     
										    Systemd
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										指令
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/df/">
                     
										    Df(1)
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/du/">
                     
										    Du(1)
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/fio/">
                     
										    Fio
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ftrace/">
                     
										    Ftrace
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/grep/">
                     
										    Grep
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/hugeadm/">
                     
										    Hugeadm
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/iostat/">
                     
										    Iostat
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/last/">
                     
										    Last
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ln/">
                     
										    Ln
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/lsof/">
                     
										    Lsof
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ls/">
                     
										    Ls
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ltrace/">
                     
										    Ltrace(1) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/man_class/">
                     
										    Linux指令后的数字代表什么
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/mount/">
                     
										    Mount
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/mpstat/">
                     
										    Mpstat-Multiprocessor Statistics
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/nl/">
                     
										    Nl
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/nmve%20cli/">
                     
										    Nvme Cli
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/pidstat/">
                     
										    Pidstat
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ps/">
                     
										    Ps
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/pushd/">
                     
										    Linux 中使用 Pushd 和 Popd 命令来进行高效的目录导航
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sadc/">
                     
										    Sadc(8) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sar/">
                     
										    Sar
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sed/">
                     
										    Sed
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/shutdown/">
                     
										    Shutdown
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/strace/">
                     
										    Strace
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/taskset/">
                     
										    Taskset
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/tee/">
                     
										    Tee
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/vmstat/">
                     
										    Vmstat-Report Virtual Memory Statistics
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										系统调用
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/brk/">
                     
										    Brk
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/exec/">
                     
										    Exec
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/futex/">
                     
										    Futex
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/getcpu/">
                     
										    Getcpu系统调用
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/gettimeofday/">
                     
										    Gettimeofday
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/ioctl/">
                     
										    Ioctl
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/mmap/">
                     
										    Mmap
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										编译、链接和装载
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/DSO/">
                     
										    DSO(dynamic Shared Object)动态共享对象的原理
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/compile_Link/">
                     
										    Linux下编译、链接和装载
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/elf/">
                     
										    Elf文件格式
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/elfremovesymbol/">
                     
										    剥离与导回符号表及调试信息
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/">
                     
										    编译、链接和装载
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										进程
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/28/01%20OS/Linux/%E8%BF%9B%E7%A8%8B/status/">
                     
										    Linux进程状态：S 和D状态
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/%E6%9C%8D%E5%8A%A1%E5%99%A8BMC%E4%B8%8EIPMI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                     
										    服务器BMC与IPMI基础知识
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 CPU
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/14/02%20CPU/SocketNodeDieCoreProcessor/">
                     
										    Socket/Node/Die/Core/Processor/Package
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/02%20CPU/%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95/">
                     
										    技术发展
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										12 Python
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/14/12%20Python/Gunicorn_manual/">
                     
										    Gunicorn的使用手册
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										50 soft
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Nodejs
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/14/50%20soft/Nodejs/npm/">
                     
										    Npm
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										97 优化
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/23/97%20%E4%BC%98%E5%8C%96/CPU/">
                     
										    CPU
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/97%20%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98/">
                     
										    内存
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/97%20%E4%BC%98%E5%8C%96/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">
                     
										    应用程序
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/97%20%E4%BC%98%E5%8C%96/%E7%A3%81%E7%9B%98IO%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">
                     
										    磁盘IO和文件系统
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/97%20%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9CIO/">
                     
										    网络IO
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										98 Other
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/98%20Other/%E5%9B%BE%E7%81%B5%E6%9C%BA%E4%B8%8E%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/">
                     
										    图灵机与图灵完备
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										99 ebook
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Linux性能优化实战
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/00%20%E5%BC%80%E7%AF%87%E8%AF%8D/">
                     
										    开篇词
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/01%20%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/">
                     
										    如何学习
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/02%20%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E2%80%9C%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E2%80%9D/">
                     
										    怎么理解“评价负载”
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/03%20%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/">
                     
										    上下文切换
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/04%20%E6%9F%90%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84CPU%E4%BD%BF%E7%94%A8%E7%8E%87%E5%B1%85%E7%84%B6%E8%BE%BE%E5%88%B0%E7%99%BE%E5%88%86%E7%99%BE/">
                     
										    CPU利用率达到100%
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/05%20%E7%B3%BB%E7%BB%9F%E7%9A%84%20CPU%20%E4%BD%BF%E7%94%A8%E7%8E%87%E5%BE%88%E9%AB%98%EF%BC%8C%E4%BD%86%E4%B8%BA%E5%95%A5%E5%8D%B4%E6%89%BE%E4%B8%8D%E5%88%B0%E9%AB%98%20CPU%20%E7%9A%84%E5%BA%94%E7%94%A8/">
                     
										    找不到高CPU的应用
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/06%20%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/">
                     
										    不可中断进程和僵尸进程
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/07%20Linux%E8%BD%AF%E4%B8%AD%E6%96%AD/">
                     
										    Linux软中断
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/08%20%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%ADCPU%E4%BD%BF%E7%94%A8%E7%8E%87%E5%8D%87%E9%AB%98/">
                     
										    软中断CPU使用率升高
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/09%20%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BA%E7%B3%BB%E7%BB%9FCPU%E7%9A%84%E7%93%B6%E9%A2%88/">
                     
										    系统CPU的瓶颈
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/10%20CPU%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E4%B8%AA%E6%80%9D%E8%B7%AF/">
                     
										    CPU性能优化思路
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/11%20%E6%97%A0%E6%B3%95%E6%A8%A1%E6%8B%9F%E5%87%BA%20RES%20%E4%B8%AD%E6%96%AD/">
                     
										    无法模拟出RES中断
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/12%20%E7%94%A8perf%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90Java%E7%A8%8B%E5%BA%8F/">
                     
										    用Perf分析java程序
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/13%20Linux%E5%86%85%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/">
                     
										    内存工作原理
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/14%20%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84Buffer%E5%92%8CCache/">
                     
										    内存中的Buffer和Cache
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/15%20%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87/">
                     
										    利用系统缓存优化程序的运行效率
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/16%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">
                     
										    内存泄漏
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/17%20%E7%B3%BB%E7%BB%9F%E7%9A%84Swap%E5%8F%98%E9%AB%98/">
                     
										    系统的Swap变高
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/18%20%E5%BF%AB%E5%87%86%E7%8B%A0%E6%89%BE%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/">
                     
										    快准狠找到系统内存问题
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/19%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A3%81%E7%9B%98%E7%9A%84%E5%8C%BA%E5%88%AB/">
                     
										    文件系统与磁盘的区别
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/20%20inux%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/">
                     
										    文件系统怎么工作
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/21%20Linux%20%E7%A3%81%E7%9B%98IO%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/">
                     
										    磁盘I/O是怎么工作的
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/22%20%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E7%8B%82%E6%89%93%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%85%E9%AC%BC/">
                     
										    如何找出狂打日志的内鬼
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/23%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84%E7%A3%81%E7%9B%98IO%E5%BB%B6%E8%BF%9F%E5%BE%88%E9%AB%98/">
                     
										    磁盘IO延迟高
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/24%20SQL%E6%9F%A5%E8%AF%A2%E6%85%A2/">
                     
										    SQL查询慢
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/25%20Redis%E5%93%8D%E5%BA%94%E4%B8%A5%E9%87%8D%E5%BB%B6%E8%BF%9F/">
                     
										    Redis响应严重延迟
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/26%20%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BA%E7%B3%BB%E7%BB%9FIO%E7%9A%84%E7%93%B6%E9%A2%88/">
                     
										    快速分析系统IO瓶颈
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/27%20%E7%A3%81%E7%9B%98%20IO%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E4%B8%AA%E6%80%9D%E8%B7%AF/">
                     
										    磁盘I/O性能优化思路
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/28%20%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%20IO%20%E4%B8%8E%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%20IO%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/">
                     
										    阻塞、非阻塞 I/O 与同步、异步 I/O 的区别和联系
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/29%20Linux%20%E7%BD%91%E7%BB%9C/">
                     
										    Linux网络
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/23/99%20ebook/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/30%20C10K%20%E5%92%8C%20C1000K%20%E5%9B%9E%E9%A1%BE/">
                     
										    C10K和C1000K回顾
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/99%20ebook/books/">
                     
										    99 Ebook
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>
	<!-- 引入正文 -->
	<div id="content">
		<div id="local-search-result"></div>
		<h1 id="article-title">
	Hugeadm
</h1>
<div class="article-meta">
	
	<span>Leah Ge</span>
	<span>2024-01-23 12:26:49</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<h1 id="hugeadm"><a href="#hugeadm" class="headerlink" title="hugeadm"></a>hugeadm</h1><h2 id="HugePage介绍"><a href="#HugePage介绍" class="headerlink" title="HugePage介绍"></a><strong>HugePage介绍</strong></h2><p>Linux内存管理采用“分页机制”，内存页面默认大小为4KB。但是当运行内存需求量较大时，默认4KB大小的页面会导致较多的TLB miss和缺页中断，从而大大影响应用程序性能。</p>
<p>但是直接修改Linux内核页面大小，涉及面较广，不一定合适。为了以最小代价实现大页面支持，Linux采用了hugetlbfs特殊文件系统。这种文件系统形式支持大页面，使得应用程序可以根据需要灵活地选择虚拟内存页面大小，而不会被强制使用2MB大小页面。</p>
<p>使用HugePage需要内核中打开CONFIG_HUGETLB_PAGE以及CONFIG_HUGETLBFS。</p>
<p>Page Table:页表，也就是一种用于内存管理的实现方式，用于物理地址到逻辑地址之间的映射。因此对于内存的访问，先是访问Page Table，然后根据Page Table中的映射关系，隐式的转移到物理地址来存取数据。</p>
<p>TLB: Translation Lookaside Buffer (TLB) ，是虚拟地址到物理地址转换cache，包含了部分page table的映射关系，用于快速实现虚拟地址到物理地址的转换。</p>
<p>hugetlb: hugetlb 是TLB中指向HugePage的一个入口。</p>
<p>用户可以通过mmap或者SYSV共享内存(shmget&#x2F;shmat)来使用HugePage。 </p>
<p>内核中预留给HugePage的内存不能被其他功能复用。并且是不保证物理连续的。</p>
<img src="./1083701-20201130210658111-1079.jpg">

<h2 id="HugePage实现"><a href="#HugePage实现" class="headerlink" title="HugePage实现"></a><strong>HugePage实现</strong></h2><p>HugePage的应用涉及到两方面：内核使用HugeTLB对HugePage进行应设管理；使用hugetlbfs来提供为文件系统给用户空间访问。</p>
<h3 id="2-1-HugeTLB初始化"><a href="#2-1-HugeTLB初始化" class="headerlink" title="2.1 HugeTLB初始化"></a><strong>2.1 HugeTLB初始化</strong></h3><h4 id="2-1-1-数据结构"><a href="#2-1-1-数据结构" class="headerlink" title="2.1.1 数据结构"></a><strong>2.1.1 数据结构</strong></h4><p>全局数组hstates中每一个struct hstate相当于一个Huge Page池，不同的成员，其页面大小是不一样的。</p>
<p>hugetlb_max_hstate表示当前成员数量，HUGE_MAX_HSTATE表示系统支持最多struct hstate数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct hstate hstates[HUGE_MAX_HSTATE];</span><br><span class="line"></span><br><span class="line">/* Defines one hugetlb page size */</span><br><span class="line">struct hstate &#123;</span><br><span class="line">    int next_nid_to_alloc;</span><br><span class="line">    int next_nid_to_free;</span><br><span class="line">    unsigned int order;</span><br><span class="line">    unsigned long mask;</span><br><span class="line">    unsigned long max_huge_pages;</span><br><span class="line">    unsigned long nr_huge_pages;</span><br><span class="line">    unsigned long free_huge_pages;</span><br><span class="line">    unsigned long resv_huge_pages;</span><br><span class="line">    unsigned long surplus_huge_pages;</span><br><span class="line">    unsigned long nr_overcommit_huge_pages;</span><br><span class="line">    struct list_head hugepage_activelist;</span><br><span class="line">    struct list_head hugepage_freelists[MAX_NUMNODES];</span><br><span class="line">    unsigned int nr_huge_pages_node[MAX_NUMNODES];</span><br><span class="line">    unsigned int free_huge_pages_node[MAX_NUMNODES];</span><br><span class="line">    unsigned int surplus_huge_pages_node[MAX_NUMNODES];</span><br><span class="line">#ifdef CONFIG_CGROUP_HUGETLB</span><br><span class="line">    /* cgroup control files */</span><br><span class="line">    struct cftype cgroup_files[5];</span><br><span class="line">#endif</span><br><span class="line">    char name[HSTATE_NAME_LEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-Huge-Page-TLB初始化"><a href="#2-1-2-Huge-Page-TLB初始化" class="headerlink" title="2.1.2 Huge Page TLB初始化"></a><strong>2.1.2 Huge Page TLB初始化</strong></h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/14028825.html#hugetlb_init">hugetlb_init</a>()是Huge Page初始化入口，属于subsys_initcall()，在arch_initcall()之后，fs_initcall()之前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">static int __init hugetlb_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if (!hugepages_supported())</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    if (!size_to_hstate(default_hstate_size)) &#123;-------------------------------如果通过command line设置了default_hugepagesz则跳过；否则使用系统默认的HPAGE_SIZE作为默认Huge Page大小。</span><br><span class="line">        if (default_hstate_size != 0) &#123;</span><br><span class="line">            pr_err(&quot;HugeTLB: unsupported default_hugepagesz %lu. Reverting to %lu\n&quot;,</span><br><span class="line">                   default_hstate_size, HPAGE_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default_hstate_size = HPAGE_SIZE;</span><br><span class="line">        if (!size_to_hstate(default_hstate_size))</span><br><span class="line">            hugetlb_add_hstate(HUGETLB_PAGE_ORDER);</span><br><span class="line">    &#125;</span><br><span class="line">    default_hstate_idx = hstate_index(size_to_hstate(default_hstate_size));---默认Huge Page在hstates中对应索引号。</span><br><span class="line">    if (default_hstate_max_huge_pages) &#123;</span><br><span class="line">        if (!default_hstate.max_huge_pages)</span><br><span class="line">            default_hstate.max_huge_pages = default_hstate_max_huge_pages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hugetlb_init_hstates();---------------------------------------------------根据当前hstate-&gt;order，初始化order小于MAX_ORDER的Huge Page内存池。较大的部分在之前已经进行分配。</span><br><span class="line">    gather_bootmem_prealloc();</span><br><span class="line">    report_hugepages();-------------------------------------------------------输出当前系统支持的不同Huge Page大小以及分配页数。</span><br><span class="line"></span><br><span class="line">    hugetlb_sysfs_init();-----------------------------------------------------在/sys/kernel/mm/hugepages目录下针对不同大小的Huge Paeg创建目录。</span><br><span class="line">    hugetlb_register_all_nodes();---------------------------------------------处理NUMA架构下不同node的Huge Page。</span><br><span class="line">    hugetlb_cgroup_file_init();-----------------------------------------------创建/sys/fs/cgroup/hugetlb下节点：hugetlb.2MB.failcnt、hugetlb.2MB.limit_in_bytes、hugetlb.2MB.max_usage_in_bytes、hugetlb.2MB.usage_in_bytes。</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">    num_fault_mutexes = roundup_pow_of_two(8 * num_possible_cpus());</span><br><span class="line">#else</span><br><span class="line">    num_fault_mutexes = 1;</span><br><span class="line">#endif</span><br><span class="line">    hugetlb_fault_mutex_table =</span><br><span class="line">        kmalloc(sizeof(struct mutex) * num_fault_mutexes, GFP_KERNEL);</span><br><span class="line">    BUG_ON(!hugetlb_fault_mutex_table);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; num_fault_mutexes; i++)</span><br><span class="line">        mutex_init(&amp;hugetlb_fault_mutex_table[i]);----------------------------创建hugetlb mutex。</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __init hugetlb_add_hstate(unsigned int order)</span><br><span class="line">&#123;</span><br><span class="line">    struct hstate *h;</span><br><span class="line">    unsigned long i;</span><br><span class="line"></span><br><span class="line">    if (size_to_hstate(PAGE_SIZE &lt;&lt; order)) &#123;------------------避免同大小两次加入。</span><br><span class="line">        pr_warn(&quot;hugepagesz= specified twice, ignoring\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    BUG_ON(hugetlb_max_hstate &gt;= HUGE_MAX_HSTATE);</span><br><span class="line">    BUG_ON(order == 0);</span><br><span class="line">    h = &amp;hstates[hugetlb_max_hstate++];------------------------设置hstates中对应Huge Page池属性。</span><br><span class="line">    h-&gt;order = order;</span><br><span class="line">    h-&gt;mask = ~((1ULL &lt;&lt; (order + PAGE_SHIFT)) - 1);</span><br><span class="line">    h-&gt;nr_huge_pages = 0;</span><br><span class="line">    h-&gt;free_huge_pages = 0;</span><br><span class="line">    for (i = 0; i &lt; MAX_NUMNODES; ++i)</span><br><span class="line">        INIT_LIST_HEAD(&amp;h-&gt;hugepage_freelists[i]);</span><br><span class="line">    INIT_LIST_HEAD(&amp;h-&gt;hugepage_activelist);</span><br><span class="line">    h-&gt;next_nid_to_alloc = first_memory_node;</span><br><span class="line">    h-&gt;next_nid_to_free = first_memory_node;</span><br><span class="line">    snprintf(h-&gt;name, HSTATE_NAME_LEN, &quot;hugepages-%lukB&quot;,</span><br><span class="line">                    huge_page_size(h)/1024);</span><br><span class="line"></span><br><span class="line">    parsed_hstate = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/14028825.html#hugetlb_sysfs_init">hugetlb_sysfs_init</a>()对不同大小的Huge Page创建&#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;hugepages对应的目录，对每个目录中属性节点进行配置达到配置Huge Page池的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static void __init hugetlb_sysfs_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct hstate *h;</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    hugepages_kobj = kobject_create_and_add(&quot;hugepages&quot;, mm_kobj);</span><br><span class="line">    if (!hugepages_kobj)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    for_each_hstate(h) &#123;</span><br><span class="line">        err = hugetlb_sysfs_add_hstate(h, hugepages_kobj,</span><br><span class="line">                     hstate_kobjs, &amp;hstate_attr_group);</span><br><span class="line">        if (err)</span><br><span class="line">            pr_err(&quot;Hugetlb: Unable to add hstate %s&quot;, h-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int hugetlb_sysfs_add_hstate(struct hstate *h, struct kobject *parent,</span><br><span class="line">                    struct kobject **hstate_kobjs,</span><br><span class="line">                    const struct attribute_group *hstate_attr_group)</span><br><span class="line">&#123;</span><br><span class="line">    int retval;</span><br><span class="line">    int hi = hstate_index(h);</span><br><span class="line"></span><br><span class="line">    hstate_kobjs[hi] = kobject_create_and_add(h-&gt;name, parent);</span><br><span class="line">    if (!hstate_kobjs[hi])</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    retval = sysfs_create_group(hstate_kobjs[hi], hstate_attr_group);</span><br><span class="line">    if (retval)</span><br><span class="line">        kobject_put(hstate_kobjs[hi]);</span><br><span class="line"></span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct attribute_group hstate_attr_group = &#123;</span><br><span class="line">    .attrs = hstate_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct attribute *hstate_attrs[] = &#123;</span><br><span class="line">    &amp;nr_hugepages_attr.attr,</span><br><span class="line">    &amp;nr_overcommit_hugepages_attr.attr,</span><br><span class="line">    &amp;free_hugepages_attr.attr,</span><br><span class="line">    &amp;resv_hugepages_attr.attr,</span><br><span class="line">    &amp;surplus_hugepages_attr.attr,</span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">    &amp;nr_hugepages_mempolicy_attr.attr,</span><br><span class="line">#endif</span><br><span class="line">    NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改nr_hugepaegs对Huge Page页面数进行配置，核心是<a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/14028825.html#set_max_huge_pages">set_max_huge_pages</a>()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t nr_hugepages_show_common(struct kobject *kobj,</span><br><span class="line">                    struct kobj_attribute *attr, char *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct hstate *h;</span><br><span class="line">    unsigned long nr_huge_pages;</span><br><span class="line">    int nid;</span><br><span class="line"></span><br><span class="line">    h = kobj_to_hstate(kobj, &amp;nid);</span><br><span class="line">    if (nid == NUMA_NO_NODE)</span><br><span class="line">        nr_huge_pages = h-&gt;nr_huge_pages;</span><br><span class="line">    else</span><br><span class="line">        nr_huge_pages = h-&gt;nr_huge_pages_node[nid];</span><br><span class="line"></span><br><span class="line">    return sprintf(buf, &quot;%lu\n&quot;, nr_huge_pages);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t __nr_hugepages_store_common(bool obey_mempolicy,</span><br><span class="line">                       struct hstate *h, int nid,</span><br><span class="line">                       unsigned long count, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">    int err;</span><br><span class="line">    NODEMASK_ALLOC(nodemask_t, nodes_allowed, GFP_KERNEL | __GFP_NORETRY);</span><br><span class="line"></span><br><span class="line">    if (hstate_is_gigantic(h) &amp;&amp; !gigantic_page_supported()) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nid == NUMA_NO_NODE) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * global hstate attribute</span><br><span class="line">         */</span><br><span class="line">        if (!(obey_mempolicy &amp;&amp;</span><br><span class="line">                init_nodemask_of_mempolicy(nodes_allowed))) &#123;</span><br><span class="line">            NODEMASK_FREE(nodes_allowed);</span><br><span class="line">            nodes_allowed = &amp;node_states[N_MEMORY];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (nodes_allowed) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * per node hstate attribute: adjust count to global,</span><br><span class="line">         * but restrict alloc/free to the specified node.</span><br><span class="line">         */</span><br><span class="line">        count += h-&gt;nr_huge_pages - h-&gt;nr_huge_pages_node[nid];</span><br><span class="line">        init_nodemask_of_node(nodes_allowed, nid);</span><br><span class="line">    &#125; else</span><br><span class="line">        nodes_allowed = &amp;node_states[N_MEMORY];</span><br><span class="line"></span><br><span class="line">    h-&gt;max_huge_pages = set_max_huge_pages(h, count, nodes_allowed);</span><br><span class="line"></span><br><span class="line">    if (nodes_allowed != &amp;node_states[N_MEMORY])</span><br><span class="line">        NODEMASK_FREE(nodes_allowed);</span><br><span class="line"></span><br><span class="line">    return len;</span><br><span class="line">out:</span><br><span class="line">    NODEMASK_FREE(nodes_allowed);</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t nr_hugepages_store_common(bool obey_mempolicy,</span><br><span class="line">                     struct kobject *kobj, const char *buf,</span><br><span class="line">                     size_t len)</span><br><span class="line">&#123;</span><br><span class="line">    struct hstate *h;</span><br><span class="line">    unsigned long count;</span><br><span class="line">    int nid;</span><br><span class="line">    int err;</span><br><span class="line"></span><br><span class="line">    err = kstrtoul(buf, 10, &amp;count);</span><br><span class="line">    if (err)</span><br><span class="line">        return err;</span><br><span class="line"></span><br><span class="line">    h = kobj_to_hstate(kobj, &amp;nid);</span><br><span class="line">    return __nr_hugepages_store_common(obey_mempolicy, h, nid, count, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t nr_hugepages_show(struct kobject *kobj,</span><br><span class="line">                       struct kobj_attribute *attr, char *buf)</span><br><span class="line">&#123;</span><br><span class="line">    return nr_hugepages_show_common(kobj, attr, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t nr_hugepages_store(struct kobject *kobj,</span><br><span class="line">           struct kobj_attribute *attr, const char *buf, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">    return nr_hugepages_store_common(false, kobj, buf, len);</span><br><span class="line">&#125;</span><br><span class="line">HSTATE_ATTR(nr_hugepages);</span><br><span class="line"></span><br><span class="line">#define persistent_huge_pages(h) (h-&gt;nr_huge_pages - h-&gt;surplus_huge_pages)</span><br><span class="line">static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,</span><br><span class="line">                        nodemask_t *nodes_allowed)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long min_count, ret;</span><br><span class="line"></span><br><span class="line">    if (hstate_is_gigantic(h) &amp;&amp; !gigantic_page_supported())</span><br><span class="line">        return h-&gt;max_huge_pages;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Increase the pool size</span><br><span class="line">     * First take pages out of surplus state.  Then make up the</span><br><span class="line">     * remaining difference by allocating fresh huge pages.</span><br><span class="line">     *</span><br><span class="line">     * We might race with __alloc_buddy_huge_page() here and be unable</span><br><span class="line">     * to convert a surplus huge page to a normal huge page. That is</span><br><span class="line">     * not critical, though, it just means the overall size of the</span><br><span class="line">     * pool might be one hugepage larger than it needs to be, but</span><br><span class="line">     * within all the constraints specified by the sysctls.</span><br><span class="line">     */</span><br><span class="line">    spin_lock(&amp;hugetlb_lock);</span><br><span class="line">    while (h-&gt;surplus_huge_pages &amp;&amp; count &gt; persistent_huge_pages(h)) &#123;</span><br><span class="line">        if (!adjust_pool_surplus(h, nodes_allowed, -1))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (count &gt; persistent_huge_pages(h)) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * If this allocation races such that we no longer need the</span><br><span class="line">         * page, free_huge_page will handle it by freeing the page</span><br><span class="line">         * and reducing the surplus.</span><br><span class="line">         */</span><br><span class="line">        spin_unlock(&amp;hugetlb_lock);</span><br><span class="line"></span><br><span class="line">        /* yield cpu to avoid soft lockup */</span><br><span class="line">        cond_resched();</span><br><span class="line"></span><br><span class="line">        if (hstate_is_gigantic(h))</span><br><span class="line">            ret = alloc_fresh_gigantic_page(h, nodes_allowed);</span><br><span class="line">        else</span><br><span class="line">            ret = alloc_fresh_huge_page(h, nodes_allowed);</span><br><span class="line">        spin_lock(&amp;hugetlb_lock);</span><br><span class="line">        if (!ret)</span><br><span class="line">            goto out;</span><br><span class="line"></span><br><span class="line">        /* Bail for signals. Probably ctrl-c from user */</span><br><span class="line">        if (signal_pending(current))</span><br><span class="line">            goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Decrease the pool size</span><br><span class="line">     * First return free pages to the buddy allocator (being careful</span><br><span class="line">     * to keep enough around to satisfy reservations).  Then place</span><br><span class="line">     * pages into surplus state as needed so the pool will shrink</span><br><span class="line">     * to the desired size as pages become free.</span><br><span class="line">     *</span><br><span class="line">     * By placing pages into the surplus state independent of the</span><br><span class="line">     * overcommit value, we are allowing the surplus pool size to</span><br><span class="line">     * exceed overcommit. There are few sane options here. Since</span><br><span class="line">     * __alloc_buddy_huge_page() is checking the global counter,</span><br><span class="line">     * though, we&#x27;ll note that we&#x27;re not allowed to exceed surplus</span><br><span class="line">     * and won&#x27;t grow the pool anywhere else. Not until one of the</span><br><span class="line">     * sysctls are changed, or the surplus pages go out of use.</span><br><span class="line">     */</span><br><span class="line">    min_count = h-&gt;resv_huge_pages + h-&gt;nr_huge_pages - h-&gt;free_huge_pages;</span><br><span class="line">    min_count = max(count, min_count);</span><br><span class="line">    try_to_free_low(h, min_count, nodes_allowed);</span><br><span class="line">    while (min_count &lt; persistent_huge_pages(h)) &#123;</span><br><span class="line">        if (!free_pool_huge_page(h, nodes_allowed, 0))</span><br><span class="line">            break;</span><br><span class="line">        cond_resched_lock(&amp;hugetlb_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    while (count &lt; persistent_huge_pages(h)) &#123;</span><br><span class="line">        if (!adjust_pool_surplus(h, nodes_allowed, 1))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    ret = persistent_huge_pages(h);</span><br><span class="line">    spin_unlock(&amp;hugetlb_lock);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他属性包括：nr_overcommit_hugepages配置Huge Page池超额使用页面数；free_hugepages、resv_hugepages、surplus_hugepages等属性都是只读。</p>
<p>对于非NUMA架构，nr_overcommit_hugepages、free_hugepages、resv_hugepages、surplus_hugepages分别对应struct hstate中的nr_overcommit_huge_pages、free_huge_pages、resv_huge_pages、surplus_huge_pages。</p>
<h3 id="2-2-hugetlbfs"><a href="#2-2-hugetlbfs" class="headerlink" title="2.2 hugetlbfs"></a><strong>2.2 hugetlbfs</strong></h3><p>hugetlbfs中创建的文件可以被读系统调用操作，但是不允许被写系统调用操作。如果需要些内容，可以修改mmap之后的内存。</p>
<p>chown&#x2F;chgrp&#x2F;chmod等修改问文件属性的命令仍然可以被使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">fs_initcall(init_hugetlbfs_fs)</span><br><span class="line"></span><br><span class="line">static int __init init_hugetlbfs_fs(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct hstate *h;</span><br><span class="line">    int error;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if (!hugepages_supported()) &#123;</span><br><span class="line">        pr_info(&quot;disabling because there are no supported hugepage sizes\n&quot;);</span><br><span class="line">        return -ENOTSUPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    hugetlbfs_inode_cachep = kmem_cache_create(&quot;hugetlbfs_inode_cache&quot;,</span><br><span class="line">                    sizeof(struct hugetlbfs_inode_info),</span><br><span class="line">                    0, SLAB_ACCOUNT, init_once);-------------------------初始化hugetlbfs文件系统inode slab缓存。</span><br><span class="line">    if (hugetlbfs_inode_cachep == NULL)</span><br><span class="line">        goto out2;</span><br><span class="line"></span><br><span class="line">    error = register_filesystem(&amp;hugetlbfs_fs_type);---------------------注册hugetlbfs文件系统。</span><br><span class="line">    if (error)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    i = 0;</span><br><span class="line">    for_each_hstate(h) &#123;</span><br><span class="line">        char buf[50];</span><br><span class="line">        unsigned ps_kb = 1U &lt;&lt; (h-&gt;order + PAGE_SHIFT - 10);</span><br><span class="line"></span><br><span class="line">        snprintf(buf, sizeof(buf), &quot;pagesize=%uK&quot;, ps_kb);</span><br><span class="line">        hugetlbfs_vfsmount[i] = kern_mount_data(&amp;hugetlbfs_fs_type,</span><br><span class="line">                            buf);</span><br><span class="line"></span><br><span class="line">        if (IS_ERR(hugetlbfs_vfsmount[i])) &#123;</span><br><span class="line">            pr_err(&quot;Cannot mount internal hugetlbfs for &quot;</span><br><span class="line">                &quot;page size %uK&quot;, ps_kb);</span><br><span class="line">            error = PTR_ERR(hugetlbfs_vfsmount[i]);</span><br><span class="line">            hugetlbfs_vfsmount[i] = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Non default hstates are optional */</span><br><span class="line">    if (!IS_ERR_OR_NULL(hugetlbfs_vfsmount[default_hstate_idx]))</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    kmem_cache_destroy(hugetlbfs_inode_cachep);</span><br><span class="line"> out2:</span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hugetlbfs文件系统目录、文件、块等操作函数集如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">static struct file_system_type hugetlbfs_fs_type = &#123;</span><br><span class="line">    .name        = &quot;hugetlbfs&quot;,</span><br><span class="line">    .mount        = hugetlbfs_mount,</span><br><span class="line">    .kill_sb    = kill_litter_super,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct dentry *hugetlbfs_mount(struct file_system_type *fs_type,</span><br><span class="line">    int flags, const char *dev_name, void *data)</span><br><span class="line">&#123;</span><br><span class="line">    return mount_nodev(fs_type, flags, data, hugetlbfs_fill_super);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct hugetlbfs_config config;</span><br><span class="line">    struct hugetlbfs_sb_info *sbinfo;</span><br><span class="line"></span><br><span class="line">    config.max_hpages = -1; /* No limit on size by default */</span><br><span class="line">    config.nr_inodes = -1; /* No limit on number of inodes by default */</span><br><span class="line">    config.uid = current_fsuid();</span><br><span class="line">    config.gid = current_fsgid();</span><br><span class="line">    config.mode = 0755;</span><br><span class="line">    config.hstate = &amp;default_hstate;</span><br><span class="line">    config.min_hpages = -1; /* No default minimum size */</span><br><span class="line">    ret = hugetlbfs_parse_options(data, &amp;config);</span><br><span class="line">    if (ret)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    sbinfo = kmalloc(sizeof(struct hugetlbfs_sb_info), GFP_KERNEL);</span><br><span class="line">    if (!sbinfo)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    sb-&gt;s_fs_info = sbinfo;</span><br><span class="line">    sbinfo-&gt;hstate = config.hstate;</span><br><span class="line">    spin_lock_init(&amp;sbinfo-&gt;stat_lock);</span><br><span class="line">    sbinfo-&gt;max_inodes = config.nr_inodes;</span><br><span class="line">    sbinfo-&gt;free_inodes = config.nr_inodes;</span><br><span class="line">    sbinfo-&gt;spool = NULL;</span><br><span class="line">    sbinfo-&gt;uid = config.uid;</span><br><span class="line">    sbinfo-&gt;gid = config.gid;</span><br><span class="line">    sbinfo-&gt;mode = config.mode;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Allocate and initialize subpool if maximum or minimum size is</span><br><span class="line">     * specified.  Any needed reservations (for minimim size) are taken</span><br><span class="line">     * taken when the subpool is created.</span><br><span class="line">     */</span><br><span class="line">    if (config.max_hpages != -1 || config.min_hpages != -1) &#123;</span><br><span class="line">        sbinfo-&gt;spool = hugepage_new_subpool(config.hstate,</span><br><span class="line">                            config.max_hpages,</span><br><span class="line">                            config.min_hpages);</span><br><span class="line">        if (!sbinfo-&gt;spool)</span><br><span class="line">            goto out_free;</span><br><span class="line">    &#125;</span><br><span class="line">    sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;</span><br><span class="line">    sb-&gt;s_blocksize = huge_page_size(config.hstate);</span><br><span class="line">    sb-&gt;s_blocksize_bits = huge_page_shift(config.hstate);</span><br><span class="line">    sb-&gt;s_magic = HUGETLBFS_MAGIC;</span><br><span class="line">    sb-&gt;s_op = &amp;hugetlbfs_ops;</span><br><span class="line">    sb-&gt;s_time_gran = 1;</span><br><span class="line">    sb-&gt;s_root = d_make_root(hugetlbfs_get_root(sb, &amp;config));</span><br><span class="line">    if (!sb-&gt;s_root)</span><br><span class="line">        goto out_free;</span><br><span class="line">    return 0;</span><br><span class="line">out_free:</span><br><span class="line">    kfree(sbinfo-&gt;spool);</span><br><span class="line">    kfree(sbinfo);</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct super_operations hugetlbfs_ops = &#123;</span><br><span class="line">    .alloc_inode    = hugetlbfs_alloc_inode,</span><br><span class="line">    .destroy_inode  = hugetlbfs_destroy_inode,</span><br><span class="line">    .evict_inode    = hugetlbfs_evict_inode,</span><br><span class="line">    .statfs        = hugetlbfs_statfs,</span><br><span class="line">    .put_super    = hugetlbfs_put_super,</span><br><span class="line">    .show_options    = hugetlbfs_show_options,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct inode_operations hugetlbfs_dir_inode_operations = &#123;</span><br><span class="line">    .create        = hugetlbfs_create,</span><br><span class="line">    .lookup        = simple_lookup,</span><br><span class="line">    .link        = simple_link,</span><br><span class="line">    .unlink        = simple_unlink,</span><br><span class="line">    .symlink    = hugetlbfs_symlink,</span><br><span class="line">    .mkdir        = hugetlbfs_mkdir,</span><br><span class="line">    .rmdir        = simple_rmdir,</span><br><span class="line">    .mknod        = hugetlbfs_mknod,</span><br><span class="line">    .rename        = simple_rename,</span><br><span class="line">    .setattr    = hugetlbfs_setattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct inode_operations hugetlbfs_inode_operations = &#123;</span><br><span class="line">    .setattr    = hugetlbfs_setattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const struct file_operations hugetlbfs_file_operations = &#123;--------------可以看出hugetlbfs文件系统中文件只支持read/mmap/ummap等操作，不支持write。</span><br><span class="line">    .read_iter        = hugetlbfs_read_iter,</span><br><span class="line">    .mmap            = hugetlbfs_file_mmap,</span><br><span class="line">    .fsync            = noop_fsync,</span><br><span class="line">    .get_unmapped_area    = hugetlb_get_unmapped_area,</span><br><span class="line">    .llseek            = default_llseek,</span><br><span class="line">    .fallocate        = hugetlbfs_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-mmap和shmget-x2F-shmat"><a href="#2-3-mmap和shmget-x2F-shmat" class="headerlink" title="2.3 mmap和shmget&#x2F;shmat"></a><strong>2.3 mmap和shmget&#x2F;shmat</strong></h3><p>用户空间在hugetlbfs文件系统创建文件，或者使用MAP_HUGETLB属性时，在mmap系统调用中执行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,</span><br><span class="line">        unsigned long, prot, unsigned long, flags,</span><br><span class="line">        unsigned long, fd, unsigned long, pgoff)</span><br><span class="line">&#123;</span><br><span class="line">    struct file *file = NULL;</span><br><span class="line">    unsigned long retval;</span><br><span class="line"></span><br><span class="line">    if (!(flags &amp; MAP_ANONYMOUS)) &#123;-----------------------------------有名文件映射。</span><br><span class="line">        audit_mmap_fd(fd, flags);</span><br><span class="line">        file = fget(fd);</span><br><span class="line">        if (!file)</span><br><span class="line">            return -EBADF;</span><br><span class="line">        if (is_file_hugepages(file))----------------------------------如果是hugetlbfs文件系统文件，将文件大小对齐到页面大小。</span><br><span class="line">            len = ALIGN(len, huge_page_size(hstate_file(file)));</span><br><span class="line">        retval = -EINVAL;</span><br><span class="line">        if (unlikely(flags &amp; MAP_HUGETLB &amp;&amp; !is_file_hugepages(file)))</span><br><span class="line">            goto out_fput;</span><br><span class="line">    &#125; else if (flags &amp; MAP_HUGETLB) &#123;--------------------------------匿名Huge Page映射。</span><br><span class="line">        struct user_struct *user = NULL;</span><br><span class="line">        struct hstate *hs;</span><br><span class="line"></span><br><span class="line">        hs = hstate_sizelog((flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK);</span><br><span class="line">        if (!hs)</span><br><span class="line">            return -EINVAL;</span><br><span class="line"></span><br><span class="line">        len = ALIGN(len, huge_page_size(hs));------------------------大小对齐到Huge Page大小。</span><br><span class="line">        /*</span><br><span class="line">         * VM_NORESERVE is used because the reservations will be</span><br><span class="line">         * taken when vm_ops-&gt;mmap() is called</span><br><span class="line">         * A dummy user value is used because we are not locking</span><br><span class="line">         * memory so no accounting is necessary</span><br><span class="line">         */</span><br><span class="line">        file = hugetlb_file_setup(HUGETLB_ANON_FILE, len,</span><br><span class="line">                VM_NORESERVE,</span><br><span class="line">                &amp;user, HUGETLB_ANONHUGE_INODE,</span><br><span class="line">                (flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK);----------创建文件，使用hugetlbfs_file_operations作为操作函数集。</span><br><span class="line">        if (IS_ERR(file))</span><br><span class="line">            return PTR_ERR(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE);</span><br><span class="line"></span><br><span class="line">    retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);----调用hugetlbfs的mmap函数hugetlbfs_file_mmap()进行映射。</span><br><span class="line">out_fput:</span><br><span class="line">    if (file)</span><br><span class="line">        fput(file);</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用SysV共享内存进行Huge Page映射时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static int newseg(struct ipc_namespace *ns, struct ipc_params *params)</span><br><span class="line">&#123;</span><br><span class="line">    key_t key = params-&gt;key;</span><br><span class="line">    int shmflg = params-&gt;flg;</span><br><span class="line">    size_t size = params-&gt;u.size;</span><br><span class="line">    int error;</span><br><span class="line">    struct shmid_kernel *shp;</span><br><span class="line">    size_t numpages = (size + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    struct file *file;</span><br><span class="line">    char name[13];</span><br><span class="line">    vm_flags_t acctflag = 0;</span><br><span class="line">...</span><br><span class="line">    sprintf(name, &quot;SYSV%08x&quot;, key);</span><br><span class="line">    if (shmflg &amp; SHM_HUGETLB) &#123;</span><br><span class="line">        struct hstate *hs;</span><br><span class="line">        size_t hugesize;</span><br><span class="line"></span><br><span class="line">        hs = hstate_sizelog((shmflg &gt;&gt; SHM_HUGE_SHIFT) &amp; SHM_HUGE_MASK);--------Huge Page页面大小对齐。</span><br><span class="line">        if (!hs) &#123;</span><br><span class="line">            error = -EINVAL;</span><br><span class="line">            goto no_file;</span><br><span class="line">        &#125;</span><br><span class="line">        hugesize = ALIGN(size, huge_page_size(hs));</span><br><span class="line"></span><br><span class="line">        /* hugetlb_file_setup applies strict accounting */</span><br><span class="line">        if (shmflg &amp; SHM_NORESERVE)</span><br><span class="line">            acctflag = VM_NORESERVE;</span><br><span class="line">        file = hugetlb_file_setup(name, hugesize, acctflag,</span><br><span class="line">                  &amp;shp-&gt;mlock_user, HUGETLB_SHMFS_INODE,</span><br><span class="line">                (shmflg &gt;&gt; SHM_HUGE_SHIFT) &amp; SHM_HUGE_MASK);---------------------创建hugetlbfs文件。</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    error = PTR_ERR(file);</span><br><span class="line">    if (IS_ERR(file))</span><br><span class="line">        goto no_file;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存映射在do_shmat()中进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations shm_file_operations_huge = &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">long do_shmat(int shmid, char __user *shmaddr, int shmflg,</span><br><span class="line">          ulong *raddr, unsigned long shmlba)</span><br><span class="line">&#123;</span><br><span class="line">    struct shmid_kernel *shp;</span><br><span class="line">    unsigned long addr = (unsigned long)shmaddr;</span><br><span class="line">...</span><br><span class="line">    file = alloc_file(&amp;path, f_mode,</span><br><span class="line">              is_file_hugepages(shp-&gt;shm_file) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br><span class="line">...</span><br><span class="line">    addr = do_mmap_pgoff(file, addr, size, prot, flags, 0, &amp;populate, NULL);----调用shm_mmap()进行映射。</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-HugePage缺页异常"><a href="#2-4-HugePage缺页异常" class="headerlink" title="2.4 HugePage缺页异常"></a><strong>2.4 HugePage缺页异常</strong></h3><p>do_page_fault()是系统处理缺页异常的入口，如果是Huge Page类型的缺页异常则调用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/14028825.html#hugetlb_fault">hugetlb_fault</a>()进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">do_page_fault</span><br><span class="line">  -&gt;__do_page_fault</span><br><span class="line">    -&gt;handle_mm_fault</span><br><span class="line"></span><br><span class="line">int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span><br><span class="line">        unsigned int flags)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    if (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line">        ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);</span><br><span class="line">    else</span><br><span class="line">        ret = __handle_mm_fault(vma, address, flags);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span><br><span class="line">            unsigned long address, unsigned int flags)</span><br><span class="line">&#123;</span><br><span class="line">    pte_t *ptep, entry;</span><br><span class="line">    spinlock_t *ptl;</span><br><span class="line">    int ret;</span><br><span class="line">    u32 hash;</span><br><span class="line">    pgoff_t idx;</span><br><span class="line">    struct page *page = NULL;</span><br><span class="line">    struct page *pagecache_page = NULL;</span><br><span class="line">    struct hstate *h = hstate_vma(vma);</span><br><span class="line">    struct address_space *mapping;</span><br><span class="line">    int need_wait_lock = 0;</span><br><span class="line"></span><br><span class="line">    address &amp;= huge_page_mask(h);</span><br><span class="line"></span><br><span class="line">    ptep = huge_pte_offset(mm, address, huge_page_size(h));</span><br><span class="line">    if (ptep) &#123;</span><br><span class="line">        entry = huge_ptep_get(ptep);</span><br><span class="line">        if (unlikely(is_hugetlb_entry_migration(entry))) &#123;</span><br><span class="line">            migration_entry_wait_huge(vma, mm, ptep);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))</span><br><span class="line">            return VM_FAULT_HWPOISON_LARGE |</span><br><span class="line">                VM_FAULT_SET_HINDEX(hstate_index(h));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ptep = huge_pte_alloc(mm, address, huge_page_size(h));</span><br><span class="line">        if (!ptep)</span><br><span class="line">            return VM_FAULT_OOM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping = vma-&gt;vm_file-&gt;f_mapping;</span><br><span class="line">    idx = vma_hugecache_offset(h, vma, address);</span><br><span class="line"></span><br><span class="line">    hash = hugetlb_fault_mutex_hash(h, mm, vma, mapping, idx, address);</span><br><span class="line">    mutex_lock(&amp;hugetlb_fault_mutex_table[hash]);</span><br><span class="line"></span><br><span class="line">    entry = huge_ptep_get(ptep);</span><br><span class="line">    if (huge_pte_none(entry)) &#123;</span><br><span class="line">        ret = hugetlb_no_page(mm, vma, mapping, idx, address, ptep, flags);</span><br><span class="line">        goto out_mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = 0;</span><br><span class="line"></span><br><span class="line">    if (!pte_present(entry))</span><br><span class="line">        goto out_mutex;</span><br><span class="line"></span><br><span class="line">    if ((flags &amp; FAULT_FLAG_WRITE) &amp;&amp; !huge_pte_write(entry)) &#123;</span><br><span class="line">        if (vma_needs_reservation(h, vma, address) &lt; 0) &#123;</span><br><span class="line">            ret = VM_FAULT_OOM;</span><br><span class="line">            goto out_mutex;</span><br><span class="line">        &#125;</span><br><span class="line">        /* Just decrements count, does not deallocate */</span><br><span class="line">        vma_end_reservation(h, vma, address);</span><br><span class="line"></span><br><span class="line">        if (!(vma-&gt;vm_flags &amp; VM_MAYSHARE))</span><br><span class="line">            pagecache_page = hugetlbfs_pagecache_page(h,</span><br><span class="line">                                vma, address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptl = huge_pte_lock(h, mm, ptep);</span><br><span class="line"></span><br><span class="line">    /* Check for a racing update before calling hugetlb_cow */</span><br><span class="line">    if (unlikely(!pte_same(entry, huge_ptep_get(ptep))))</span><br><span class="line">        goto out_ptl;</span><br><span class="line"></span><br><span class="line">    page = pte_page(entry);</span><br><span class="line">    if (page != pagecache_page)</span><br><span class="line">        if (!trylock_page(page)) &#123;</span><br><span class="line">            need_wait_lock = 1;</span><br><span class="line">            goto out_ptl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    get_page(page);</span><br><span class="line"></span><br><span class="line">    if (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">        if (!huge_pte_write(entry)) &#123;</span><br><span class="line">            ret = hugetlb_cow(mm, vma, address, ptep,</span><br><span class="line">                      pagecache_page, ptl);</span><br><span class="line">            goto out_put_page;</span><br><span class="line">        &#125;</span><br><span class="line">        entry = huge_pte_mkdirty(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    entry = pte_mkyoung(entry);</span><br><span class="line">    if (huge_ptep_set_access_flags(vma, address, ptep, entry,</span><br><span class="line">                        flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line">        update_mmu_cache(vma, address, ptep);</span><br><span class="line">out_put_page:</span><br><span class="line">    if (page != pagecache_page)</span><br><span class="line">        unlock_page(page);</span><br><span class="line">    put_page(page);</span><br><span class="line">out_ptl:</span><br><span class="line">    spin_unlock(ptl);</span><br><span class="line"></span><br><span class="line">    if (pagecache_page) &#123;</span><br><span class="line">        unlock_page(pagecache_page);</span><br><span class="line">        put_page(pagecache_page);</span><br><span class="line">    &#125;</span><br><span class="line">out_mutex:</span><br><span class="line">    mutex_unlock(&amp;hugetlb_fault_mutex_table[hash]);</span><br><span class="line"></span><br><span class="line">    if (need_wait_lock)</span><br><span class="line">        wait_on_page_locked(page);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-HugePage配置"><a href="#3-HugePage配置" class="headerlink" title="3. HugePage配置"></a><strong>3. HugePage配置</strong></h2><p>获取当前系统使用页面大小命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf PAGESIZE</span><br></pre></td></tr></table></figure>

<p>通过&#x2F;proc&#x2F;meminfo查看HugePage信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MemTotal:       16310112 kB</span><br><span class="line">MemFree:          586168 kB</span><br><span class="line">MemAvailable:   10733508 kB</span><br><span class="line">...</span><br><span class="line">HugePages_Total:       0---------------------HugePage池中大小。</span><br><span class="line">HugePages_Free:        0---------------------HugePage池中未被分配HugePage数量。</span><br><span class="line">HugePages_Rsvd:        0---------------------HugePage池中承诺被分配但还未执行分配操作的HugePage数量。</span><br><span class="line">HugePages_Surp:        0---------------------HugePage池中超出/proc/sys/vm/nr_hugepages。最大不超过/proc/sys/vm/nr_overcommit_hugepages。</span><br><span class="line">Hugepagesize:       2048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>内核可以在命令行设置hugepages和hugepagesz，分别表示HugePage页面数量和页面大小。当系统支持多种大小HugePage时，默认HugePage大小通过default_huagepaegsz指定。 </p>
<h3 id="3-1-命令行参数"><a href="#3-1-命令行参数" class="headerlink" title="3.1 命令行参数"></a><strong>3.1 命令行参数</strong></h3><p>通过命令行分别设置nr_hugepages和default_hugepagesz，可以设置HugePage页面数量和大小。以及x86_64特有的配置选项。</p>
<p>由于__setup()在initcall()之前执行，所以下面的命令都在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/14028825.html#hugetlb_init">hugetlb_init</a>()之前执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">static int __init hugetlb_nrpages_setup(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long *mhp;</span><br><span class="line">    static unsigned long *last_mhp;</span><br><span class="line"></span><br><span class="line">    if (!parsed_valid_hugepagesz) &#123;</span><br><span class="line">        pr_warn(&quot;hugepages = %s preceded by &quot;</span><br><span class="line">            &quot;an unsupported hugepagesz, ignoring\n&quot;, s);</span><br><span class="line">        parsed_valid_hugepagesz = true;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     * !hugetlb_max_hstate means we haven&#x27;t parsed a hugepagesz= parameter yet,</span><br><span class="line">     * so this hugepages= parameter goes to the &quot;default hstate&quot;.</span><br><span class="line">     */</span><br><span class="line">    else if (!hugetlb_max_hstate)</span><br><span class="line">        mhp = &amp;default_hstate_max_huge_pages;-----------如果hugepagesz没有被解析过，则hugepages解析值保存在default_hstate_max_huge_pages中；否则保存在parsed_hstate-&gt;max_huge_pages中。</span><br><span class="line">    else</span><br><span class="line">        mhp = &amp;parsed_hstate-&gt;max_huge_pages;</span><br><span class="line"></span><br><span class="line">    if (mhp == last_mhp) &#123;</span><br><span class="line">        pr_warn(&quot;hugepages= specified twice without interleaving hugepagesz=, ignoring\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (sscanf(s, &quot;%lu&quot;, mhp) &lt;= 0)---------------------保存命令行解析的hugepages值。</span><br><span class="line">        *mhp = 0;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Global state is always initialized later in hugetlb_init.</span><br><span class="line">     * But we need to allocate &gt;= MAX_ORDER hstates here early to still</span><br><span class="line">     * use the bootmem allocator.</span><br><span class="line">     */</span><br><span class="line">    if (hugetlb_max_hstate &amp;&amp; parsed_hstate-&gt;order &gt;= MAX_ORDER)---必须满足hugetlb_max_hstate被初始化过，并且parsed_hstate-&gt;order不小于MAX_ORDER才提前分配内存。</span><br><span class="line">        hugetlb_hstate_alloc_pages(parsed_hstate);</span><br><span class="line"></span><br><span class="line">    last_mhp = mhp;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">__setup(&quot;hugepages=&quot;, hugetlb_nrpages_setup);</span><br><span class="line"></span><br><span class="line">static int __init hugetlb_default_setup(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    default_hstate_size = memparse(s, &amp;s);---------------解析default_hugepagesz值到default_hstate_size中，表示默认的Huge Page大小。后续系统可能存在多种Huge Page大小。</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">__setup(&quot;default_hugepagesz=&quot;, hugetlb_default_setup);</span><br><span class="line"></span><br><span class="line">static __init int setup_hugepagesz(char *opt)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long ps = memparse(opt, &amp;opt);--------------x86_64特有属性值。</span><br><span class="line">    if (ps == PMD_SIZE) &#123;</span><br><span class="line">        hugetlb_add_hstate(PMD_SHIFT - PAGE_SHIFT);</span><br><span class="line">    &#125; else if (ps == PUD_SIZE &amp;&amp; boot_cpu_has(X86_FEATURE_GBPAGES)) &#123;</span><br><span class="line">        hugetlb_add_hstate(PUD_SHIFT - PAGE_SHIFT);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        hugetlb_bad_size();</span><br><span class="line">        printk(KERN_ERR &quot;hugepagesz: Unsupported page size %lu M\n&quot;,</span><br><span class="line">            ps &gt;&gt; 20);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">__setup(&quot;hugepagesz=&quot;, setup_hugepagesz);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-配置节点"><a href="#3-2-配置节点" class="headerlink" title="3.2 配置节点"></a><strong>3.2 配置节点</strong></h3><p>内核每一个不同尺寸的Huge Page都有一对应的目录：&#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;hugepages&#x2F;hugepages-*kB&#x2F;。包含如下文件节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nr_hugepages</span><br><span class="line">nr_hugepages_mempolicy</span><br><span class="line">nr_overcommit_hugepages</span><br><span class="line">free_hugepages</span><br><span class="line">resv_hugepages</span><br><span class="line">surplus_hugepages</span><br></pre></td></tr></table></figure>

<h4 id="nr-hugepages-读写"><a href="#nr-hugepages-读写" class="headerlink" title="nr_hugepages(读写)"></a><strong>nr_hugepages</strong><strong>(读写)</strong></h4><p>系统运行起来后，可以通过&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;nr_hugepages设置，系统根据实际情况分配或释放HugePages。</p>
<p>当增加nr_hugepages之后，系统优先使用surplus中页面。然后才会分配新的Huge Page来满足需求。</p>
<p>当减小nr_hugepages，导致使用中页面大于nr_hugepages时，将使用中页面转换成surplus页面。</p>
<p>当减小nr_hugepaes，导致用中页面大于nr_hugepages+nr_overcommit_hugepages时，同样会将超出nr_hugepages的页面转成surplus页面。直到nr_hugepages+nr_overcommit_hugepages足够大，或者释放足够多的surplus页面，否则不会继续申请surplus页面。</p>
<h4 id="free-hugepages-只读"><a href="#free-hugepages-只读" class="headerlink" title="free_hugepages(只读)"></a><strong>free_hugepages(只读)</strong></h4><p>表示系统中persistent Huge Page页面数量。</p>
<h4 id="resv-hugepages-只读"><a href="#resv-hugepages-只读" class="headerlink" title="resv_hugepages(只读)"></a><strong>resv_hugepages(只读)</strong></h4><p>表示已经被分配但是未被实际使用的Huge Page数量。</p>
<h4 id="surplus-hugepages-只读"><a href="#surplus-hugepages-只读" class="headerlink" title="surplus_hugepages(只读)"></a><strong>surplus_hugepages(只读)</strong></h4><p>使用中的overcommit Huge Page页面数量。</p>
<h4 id="nr-overcommit-hugepages-读写"><a href="#nr-overcommit-hugepages-读写" class="headerlink" title="nr_overcommit_hugepages(读写)"></a><strong>nr_overcommit_hugepages</strong><strong>(读写)</strong></h4><p>系统允许的最大overcommit页面数量。</p>
<p>表示当当前系统可以从HugePage池中分配超过nr_hugepages数量的HugePage数。这些页面被称为surplus Huge Pages，当这些页面不被使用后，可以被释放返回给系统。</p>
<p>HugePage为2MB情况下，分别设置nr_hugepages&#x3D;128、nr_overcommit_hugepages&#x3D;128。分别通过mmap申请100MB、300MB、512MB后关系如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Item</td>
<td>nr_hugepages</td>
<td>free_hugepages</td>
<td>resv_hugepages</td>
<td>nr_overcommit_hugepages</td>
<td>surplus_hugepages</td>
</tr>
<tr>
<td>初始值</td>
<td>128</td>
<td>128</td>
<td>0</td>
<td>128</td>
<td>0</td>
</tr>
<tr>
<td>100MB</td>
<td>128</td>
<td>78</td>
<td>0</td>
<td>128</td>
<td>0</td>
</tr>
<tr>
<td>300MB</td>
<td>150</td>
<td>0</td>
<td>0</td>
<td>128</td>
<td>22</td>
</tr>
<tr>
<td>512M</td>
<td>256</td>
<td>0</td>
<td>0</td>
<td>128</td>
<td>128</td>
</tr>
</tbody></table>
<h4 id="hugepages-treat-as-movable"><a href="#hugepages-treat-as-movable" class="headerlink" title="hugepages_treat_as_movable"></a><strong>hugepages_treat_as_movable</strong></h4><p>分配的Huge Page页面将具备__GFP_MOVABLE标志。</p>
<h2 id="4-HugePage优缺点"><a href="#4-HugePage优缺点" class="headerlink" title="4. HugePage优缺点"></a><strong>4. HugePage优缺点</strong></h2><p>使用HugePage的优点：</p>
<ul>
<li>系统使用HugePage则内存页数量会减少，从而需要更少的页表，节约了页表所占用的内存数量。</li>
<li>所需的地址转化也减少了，TLB缓存失效的次数也减少了，从而提高内存访问的性能。</li>
<li>地址转换所需信息一般保存在CPU缓存中，HugePage使用让地址转换信息减少，减少了CPU缓存的使用。</li>
<li>HugePage页面是不支持swap的，所以没有page table lookups。所以大内存情况下，kswapd也不会频繁被调用。</li>
</ul>
<p> 当然HugePage在某些场景下也存在缺点：</p>
<ul>
<li>当申请一块大内存，但是使用内存并不多，比如：每个2MB，写4KB内容。使用HugePage就会导致实际占用的物理内存相对于4KB页面大很多。</li>
</ul>
<h2 id="5-HugePage使用"><a href="#5-HugePage使用" class="headerlink" title="5. HugePage使用"></a><strong>5. HugePage使用</strong></h2><p>有两种方式使用HugePage：mmap和SYSV共享内存，其中mmap可以有名映射或者匿名映射。</p>
<p>共享内存和mmap通过MAP_HUGETLB使用HugePage是不需要挂载HugePage文件系统的。</p>
<p>通过libhugetlbfs可以对HugePage进行扩展，更方便使用。</p>
<h3 id="5-1-mmap"><a href="#5-1-mmap" class="headerlink" title="5.1 mmap"></a><strong>5.1 mmap</strong></h3><h4 id="5-1-1-mmap有名映射HugePage"><a href="#5-1-1-mmap有名映射HugePage" class="headerlink" title="5.1.1 mmap有名映射HugePage"></a><strong>5.1.1 mmap有名映射HugePage</strong></h4><p>挂载HugePage文件系统</p>
<p>mount none &#x2F;mnt&#x2F;huge -t hugetlbfs </p>
<p> 使用如下代码创建huge&#x2F;hugepagefile文件，然后使用256M映射： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#define FILE_NAME &quot;huge/hugepagefile&quot;</span><br><span class="line">#define LENGTH (256UL*1024*1024)</span><br><span class="line">#define PROTECTION (PROT_READ | PROT_WRITE)</span><br><span class="line"></span><br><span class="line">/* Only ia64 requires this */</span><br><span class="line">#ifdef __ia64__</span><br><span class="line">#define ADDR (void *)(0x8000000000000000UL)</span><br><span class="line">#define FLAGS (MAP_SHARED | MAP_FIXED)</span><br><span class="line">#else</span><br><span class="line">#define ADDR (void *)(0x0UL)</span><br><span class="line">#define FLAGS (MAP_SHARED)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static void check_bytes(char *addr)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;First hex is %x\n&quot;, *((unsigned int *)addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void write_bytes(char *addr)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; LENGTH; i++)</span><br><span class="line">        *(addr + i) = (char)i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int read_bytes(char *addr)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long i;</span><br><span class="line"></span><br><span class="line">    check_bytes(addr);</span><br><span class="line">    for (i = 0; i &lt; LENGTH; i++)</span><br><span class="line">        if (*(addr + i) != (char)i) &#123;</span><br><span class="line">            printf(&quot;Mismatch at %lu\n&quot;, i);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *addr;</span><br><span class="line">    int fd, ret;</span><br><span class="line"></span><br><span class="line">    fd = open(FILE_NAME, O_CREAT | O_RDWR, 0755);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;Open failed&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = mmap(ADDR, LENGTH, PROTECTION, FLAGS, fd, 0);</span><br><span class="line">    if (addr == MAP_FAILED) &#123;</span><br><span class="line">        perror(&quot;mmap&quot;);</span><br><span class="line">        unlink(FILE_NAME);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Returned address is %p\n&quot;, addr);</span><br><span class="line">    check_bytes(addr);</span><br><span class="line">    write_bytes(addr);</span><br><span class="line">    ret = read_bytes(addr);</span><br><span class="line"></span><br><span class="line">    sleep(10);</span><br><span class="line"></span><br><span class="line">    munmap(addr, LENGTH);</span><br><span class="line">    close(fd);</span><br><span class="line">    unlink(FILE_NAME);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Returned address is 0x7f2d8ba00000</span><br><span class="line">First hex is 0</span><br><span class="line">First hex is 3020100</span><br></pre></td></tr></table></figure>

<p>查看进程maps如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">7f2d8ba00000-7f2d9ba00000 rw-s 00000000 00:9b 10940003                   /home/al/hugepage/huge/hugepagefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>查看文件系统：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 258M 11月 29 23:06 hugepagefile</span><br></pre></td></tr></table></figure>

<h4 id="5-1-2-mmap匿名映射HugePage"><a href="#5-1-2-mmap匿名映射HugePage" class="headerlink" title="5.1.2 mmap匿名映射HugePage"></a><strong>5.1.2 mmap匿名映射HugePage</strong></h4><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#define LENGTH (256UL*1024*1024)</span><br><span class="line">#define PROTECTION (PROT_READ | PROT_WRITE)</span><br><span class="line"></span><br><span class="line">#ifndef MAP_HUGETLB</span><br><span class="line">#define MAP_HUGETLB 0x40000 /* arch specific */</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/* Only ia64 requires this */</span><br><span class="line">#ifdef __ia64__</span><br><span class="line">#define ADDR (void *)(0x8000000000000000UL)</span><br><span class="line">#define FLAGS (MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB | MAP_FIXED)</span><br><span class="line">#else</span><br><span class="line">#define ADDR (void *)(0x0UL)</span><br><span class="line">#define FLAGS (MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static void check_bytes(char *addr)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;First hex is %x\n&quot;, *((unsigned int *)addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void write_bytes(char *addr)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; LENGTH; i++)</span><br><span class="line">        *(addr + i) = (char)i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int read_bytes(char *addr)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long i;</span><br><span class="line"></span><br><span class="line">    check_bytes(addr);</span><br><span class="line">    for (i = 0; i &lt; LENGTH; i++)</span><br><span class="line">        if (*(addr + i) != (char)i) &#123;</span><br><span class="line">            printf(&quot;Mismatch at %lu\n&quot;, i);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *addr;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    addr = mmap(ADDR, LENGTH, PROTECTION, FLAGS, 0, 0);</span><br><span class="line">    if (addr == MAP_FAILED) &#123;</span><br><span class="line">        perror(&quot;mmap&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Returned address is %p\n&quot;, addr);</span><br><span class="line">    check_bytes(addr);</span><br><span class="line">    write_bytes(addr);</span><br><span class="line">    ret = read_bytes(addr);</span><br><span class="line">    sleep(10);</span><br><span class="line">    /* munmap() length of MAP_HUGETLB memory must be hugepage aligned */</span><br><span class="line">    if (munmap(addr, LENGTH)) &#123;</span><br><span class="line">        perror(&quot;munmap&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Returned address is 0x7ff600200000</span><br><span class="line">First hex is 0</span><br><span class="line">First hex is 3020100</span><br></pre></td></tr></table></figure>

<p>查看进程的maps如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">7ff600200000-7ff610200000 rw-p 00000000 00:0f 10940472                   /anon_hugepage (deleted)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="5-2-SYSV共享内存使用HugePage"><a href="#5-2-SYSV共享内存使用HugePage" class="headerlink" title="5.2 SYSV共享内存使用HugePage"></a><strong>5.2 SYSV共享内存使用HugePage</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef SHM_HUGETLB</span><br><span class="line">#define SHM_HUGETLB 04000</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define LENGTH (256UL*1024*1024)</span><br><span class="line"></span><br><span class="line">#define dprintf(x)  printf(x)</span><br><span class="line"></span><br><span class="line">/* Only ia64 requires this */</span><br><span class="line">#ifdef __ia64__</span><br><span class="line">#define ADDR (void *)(0x8000000000000000UL)</span><br><span class="line">#define SHMAT_FLAGS (SHM_RND)</span><br><span class="line">#else</span><br><span class="line">#define ADDR (void *)(0x0UL)</span><br><span class="line">#define SHMAT_FLAGS (0)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int shmid;</span><br><span class="line">    unsigned long i;</span><br><span class="line">    char *shmaddr;</span><br><span class="line"></span><br><span class="line">    shmid = shmget(0x12345678, LENGTH, SHM_HUGETLB | IPC_CREAT | SHM_R | SHM_W);</span><br><span class="line">    if (shmid &lt; 0) &#123;</span><br><span class="line">        perror(&quot;shmget&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;shmid: %d\n&quot;, shmid);</span><br><span class="line"></span><br><span class="line">    shmaddr = shmat(shmid, ADDR, SHMAT_FLAGS);</span><br><span class="line">    if (shmaddr == (char *)-1) &#123;</span><br><span class="line">        perror(&quot;Shared memory attach failure&quot;);</span><br><span class="line">        shmctl(shmid, IPC_RMID, NULL);</span><br><span class="line">        exit(2);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;shmaddr: %p\n&quot;, shmaddr);</span><br><span class="line"></span><br><span class="line">    dprintf(&quot;Starting the writes:\n&quot;);</span><br><span class="line">    for (i = 0; i &lt; LENGTH; i++) &#123;</span><br><span class="line">        shmaddr[i] = (char)(i);</span><br><span class="line">        if (!(i % (1024 * 1024)))</span><br><span class="line">            dprintf(&quot;.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    dprintf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    dprintf(&quot;Starting the Check...&quot;);</span><br><span class="line">    for (i = 0; i &lt; LENGTH; i++)</span><br><span class="line">        if (shmaddr[i] != (char)i) &#123;</span><br><span class="line">            printf(&quot;\nIndex %lu mismatched\n&quot;, i);</span><br><span class="line">            exit(3);</span><br><span class="line">        &#125;</span><br><span class="line">    dprintf(&quot;Done.\n&quot;);</span><br><span class="line">    sleep(10);</span><br><span class="line"></span><br><span class="line">    if (shmdt((const void *)shmaddr) != 0) &#123;</span><br><span class="line">        perror(&quot;Detach failure&quot;);</span><br><span class="line">        shmctl(shmid, IPC_RMID, NULL);</span><br><span class="line">        exit(4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shmctl(shmid, IPC_RMID, NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shmid: 32407590</span><br><span class="line">shmaddr: 0x7f1fc2c00000</span><br><span class="line">Starting the writes:</span><br><span class="line">................................................................................................................................................................................................................................................................</span><br><span class="line">Starting the Check...Done.</span><br></pre></td></tr></table></figure>

<p>查看进程maps如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">7f1fc2c00000-7f1fd2c00000 rw-s 00000000 00:0f 32407590                   /SYSV12345678 (deleted)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>共享内存使用情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">...        </span><br><span class="line">0x12345678 32407590   root       600        268435456  1                      </span><br></pre></td></tr></table></figure>

<h3 id="5-3-mmap、SYSV共享内存异同"><a href="#5-3-mmap、SYSV共享内存异同" class="headerlink" title="5.3 mmap、SYSV共享内存异同"></a><strong>5.3 mmap、SYSV共享内存异同</strong></h3><p>mmap有名和匿名，以及SysV共享内存都使用内核中HugePage。</p>
<p>有名mmap需要借助hugetlbfs文件系统；匿名mmap和SysV共享内存只需要使用特殊标志位(MAP_HUGETLB&#x2F;SHM_HUGETLB)。</p>
<p>有名mmap和SYSV共享内存都可以跨进程访问；匿名mmap只能本进程访问。</p>
<h3 id="5-4-libhugetlbfs做回归测试"><a href="#5-4-libhugetlbfs做回归测试" class="headerlink" title="5.4 libhugetlbfs做回归测试"></a><strong>5.4 libhugetlbfs做回归测试</strong></h3><p>源码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/libhugetlbfs/libhugetlbfs">https://github.com/libhugetlbfs/libhugetlbfs</a></p>
<p>《HOWTO》对libhugetlbfs做了详细介绍：</p>
<ol>
<li>通过libhugetlbfs对使用hugetlbfs提供了一套方便的应用程序接口；使用libhugetblfs替代目前库中malloc()函数，使内存分配在HugePage上进行；libhugetlbfs能使进程test&#x2F;data&#x2F;bss段在HugePage上分配。</li>
<li>支持libhugetlbfs的硬件、内核、工具链、配置。</li>
<li>如何编译安装libhugetlbfs。</li>
<li>如何使用libhugetlbfs：替代malloc()、共享内存、进程text&#x2F;data&#x2F;bss段。</li>
</ol>
<p>安装libhugetlgfs：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libhugetlbfs libhugetlbfs-tests</span><br></pre></td></tr></table></figure>

<p>建立挂载点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount none /home/al/hugepage/huge -t hugetlbfs</span><br></pre></td></tr></table></figure>

<p>使用hugeadm查看挂载情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hugeadm --list-all-mounts：</span><br><span class="line">libhugetlbfs: ERROR: Line too long when parsing mounts</span><br><span class="line">Mount Point            Options</span><br><span class="line">/dev/hugepages         rw,relatime,pagesize=2M</span><br><span class="line">/home/al/hugepage/huge rw,relatime,pagesize=2M</span><br><span class="line">hugeadm --pool-list：</span><br><span class="line">libhugetlbfs: ERROR: Line too long when parsing mounts</span><br><span class="line">      Size  Minimum  Current  Maximum  Default</span><br><span class="line">   2097152      512      512      512        *</span><br><span class="line">1073741824        0        0        0</span><br></pre></td></tr></table></figure>

<p>使用如下脚本进行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/lib/libhugetlbfs/tests/run_tests.py</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">run_tests.py: The 32 bit word size is not compatible with 2M pages</span><br><span class="line">zero_filesize_segment (2M: 64):    PASS</span><br><span class="line">test_root (2M: 64):    PASS</span><br><span class="line">meminfo_nohuge (2M: 64):    PASS</span><br><span class="line">gethugepagesize (2M: 64):    PASS</span><br><span class="line">gethugepagesizes (2M: 64):    PASS</span><br><span class="line">HUGETLB_VERBOSE=1 empty_mounts (2M: 64):    PASS</span><br><span class="line">HUGETLB_VERBOSE=1 large_mounts (2M: 64):    PASS</span><br><span class="line">find_path (2M: 64):    PASS</span><br><span class="line">unlinked_fd (2M: 64):    PASS</span><br><span class="line">readback (2M: 64):    PASS</span><br><span class="line">truncate (2M: 64):    PASS</span><br><span class="line">shared (2M: 64):    PASS</span><br><span class="line">mprotect (2M: 64):    PASS</span><br><span class="line">mlock (2M: 64):    PASS</span><br><span class="line">misalign (2M: 64):    PASS</span><br><span class="line">ptrace-write-hugepage (2M: 64):    PASS</span><br><span class="line">icache-hygiene (2M: 64):    PASS</span><br><span class="line">slbpacaflush (2M: 64):    PASS (inconclusive)</span><br><span class="line">straddle_4GB_static (2M: 64):    PASS</span><br><span class="line">huge_at_4GB_normal_below_static (2M: 64):    PASS</span><br><span class="line">huge_below_4GB_normal_above_static (2M: 64):    PASS</span><br><span class="line">map_high_truncate_2 (2M: 64):    PASS</span><br><span class="line">misaligned_offset (2M: 64):    PASS (inconclusive)</span><br><span class="line">truncate_above_4GB (2M: 64):    PASS</span><br><span class="line">brk_near_huge (2M: 64):    brk_near_huge: malloc.c:2401: sysmalloc: Assertion `(old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)&#x27; failed.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="6-性能对比"><a href="#6-性能对比" class="headerlink" title="6. 性能对比"></a><strong>6. 性能对比</strong></h2><p>构建测试用例：分别在2MB HugePagemmap()和4K页面内存上映射256M内存，然后每隔4KB写一个字节，再读出进行验证。最后munmap()解除映射。</p>
<p>如此确保每个256M空间每个页面都会被申请到，其中HugePage内存每隔2MB才会发生缺页异常；4K页面每次都会发生缺页异常，总量是2MB的512倍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define PAGE_4K (0x1000)</span><br><span class="line">#define LENGTH (256UL*1024*1024)</span><br><span class="line">#define PROTECTION (PROT_READ | PROT_WRITE)</span><br><span class="line"></span><br><span class="line">#ifndef MAP_HUGETLB</span><br><span class="line">#define MAP_HUGETLB 0x40000 /* arch specific */</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define ADDR (void *)(0x0UL)</span><br><span class="line">#define FLAGS_HP (MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB)</span><br><span class="line">#define FLAGS (MAP_PRIVATE | MAP_ANONYMOUS)</span><br><span class="line"></span><br><span class="line">static void write_bytes(char *addr)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; LENGTH/PAGE_4K; i++)</span><br><span class="line">        *(addr + PAGE_4K*i) = (char)i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int read_bytes(char *addr)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; LENGTH/PAGE_4K; i++)</span><br><span class="line">        if (*(addr + PAGE_4K*i) != (char)i) &#123;</span><br><span class="line">            printf(&quot;Mismatch at %lu\n&quot;, i);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long int mmap_perf_test(int flags)</span><br><span class="line">&#123;</span><br><span class="line">    void *addr;</span><br><span class="line">    int ret;</span><br><span class="line">    struct timespec time_start, time_end;</span><br><span class="line">    long int duration = 0;</span><br><span class="line"></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;time_start);</span><br><span class="line">    addr = mmap(ADDR, LENGTH, PROTECTION, flags, 0, 0);</span><br><span class="line">    if (addr == MAP_FAILED) &#123;</span><br><span class="line">        perror(&quot;mmap&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write_bytes(addr);</span><br><span class="line">    ret = read_bytes(addr);</span><br><span class="line">    /* munmap() length of MAP_HUGETLB memory must be hugepage aligned */</span><br><span class="line">    if (munmap(addr, LENGTH)) &#123;</span><br><span class="line">        perror(&quot;munmap&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;time_end);</span><br><span class="line">    duration = (time_end.tv_sec - time_start.tv_sec)*1000000000 + (time_end.tv_nsec - time_start.tv_nsec);</span><br><span class="line">    return duration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    long int ret_hp = 0, ret = 0;</span><br><span class="line">    float percentage = 0.0;</span><br><span class="line"></span><br><span class="line">    if(argc != 2)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    int count=atoi(argv[1]);</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        ret_hp = mmap_perf_test(FLAGS_HP);</span><br><span class="line">        ret = mmap_perf_test(FLAGS);</span><br><span class="line">        percentage = (float)ret_hp/(float)ret*100.0;</span><br><span class="line">        printf(&quot;%d, %ld, %ld, %f\n&quot;, i+1, ret_hp, ret, percentage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别进行1次和连续50次对比如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">al@al-B250-HD3:~/hugepage$ ./cmp_hugepage 1</span><br><span class="line">1, 19186196, 81868224, 23.435461</span><br><span class="line">al@al-B250-HD3:~/hugepage$ ./cmp_hugepage 1</span><br><span class="line">1, 45560431, 83335020, 54.671406</span><br><span class="line">al@al-B250-HD3:~/hugepage$ ./cmp_hugepage 1</span><br><span class="line">1, 17648359, 82351069, 21.430639</span><br><span class="line">al@al-B250-HD3:~/hugepage$ ./cmp_hugepage 1</span><br><span class="line">1, 43837351, 83531347, 52.480125</span><br><span class="line">al@al-B250-HD3:~/hugepage$ ./cmp_hugepage 1</span><br><span class="line">1, 45677763, 83840517, 54.481728</span><br></pre></td></tr></table></figure>

<p>可以看出只执行1次，HugePage上耗时不太稳定。耗时可能是20%或50%左右。(原因细节未继续跟进)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">al@al-B250-HD3:~/hugepage$ ./cmp_hugepage 50</span><br><span class="line">1, 18256274, 81718710, 22.340384</span><br><span class="line">2, 15377806, 82897401, 18.550407</span><br><span class="line">3, 14953090, 81918232, 18.253677</span><br><span class="line">...</span><br><span class="line">48, 15206444, 83194584, 18.278166</span><br><span class="line">49, 15137777, 85130700, 17.781807</span><br><span class="line">50, 15088148, 83927648, 17.977566</span><br></pre></td></tr></table></figure>

<p>当执行50的时候，第1次可能是20%或50%，但是后面基本在20%左右。</p>
<p>所以说在本Case下，最坏情况HugePage领先4K 50%，最好领先80%左右。</p>
<p>通过读取trace event &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#x2F;exceptionspage_fault_user，可以看出缺页异常次数对比。</p>
<p>当执行256M 4KB页面，内核do_page_fault()次数为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/kernel/debug/tracing/trace | grep 0x4006cd | wc -l</span><br><span class="line">65536</span><br></pre></td></tr></table></figure>

<p>当使用HugePage后，内核do_page_fault()次数为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/kernel/debug/tracing/trace | grep 0x4006cd | wc -l</span><br><span class="line">128</span><br></pre></td></tr></table></figure>

<p>其中0x4006cd 是写内存的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void write_bytes(char *addr)</span><br><span class="line">&#123;</span><br><span class="line">  4006ac:    55                       push   %rbp</span><br><span class="line">  4006ad:    48 89 e5                 mov    %rsp,%rbp</span><br><span class="line">  4006b0:    48 89 7d e8              mov    %rdi,-0x18(%rbp)</span><br><span class="line">    unsigned long i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; LENGTH; i++)</span><br><span class="line">  4006b4:    48 c7 45 f8 00 00 00     movq   $0x0,-0x8(%rbp)</span><br><span class="line">  4006bb:    00 </span><br><span class="line">  4006bc:    eb 16                    jmp    4006d4 &lt;write_bytes+0x28&gt;</span><br><span class="line">        *(addr + i) = (char)i;</span><br><span class="line">  4006be:    48 8b 55 e8              mov    -0x18(%rbp),%rdx</span><br><span class="line">  4006c2:    48 8b 45 f8              mov    -0x8(%rbp),%rax</span><br><span class="line">  4006c6:    48 01 d0                 add    %rdx,%rax</span><br><span class="line">  4006c9:    48 8b 55 f8              mov    -0x8(%rbp),%rdx</span><br><span class="line">  4006cd:    88 10                    mov    %dl,(%rax)</span><br></pre></td></tr></table></figure>

<p>目前使用动态巨页的进程—-无</p>
<p> $ sudo grep -r AnonHugePages &#x2F;proc&#x2F;*&#x2F;smaps | grep -v ‘0 kB’ </p>
<p># 系统支持的巨页大小 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hugeadm --page-sizes-all </span><br><span class="line">2097152 </span><br><span class="line">536870912 </span><br><span class="line">17179869184</span><br></pre></td></tr></table></figure>

<p> # 挂载的巨页 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hugeadm --list-all-mounts </span><br><span class="line">Mount Point         Options </span><br><span class="line">/dev/hugepages      rw,relatime,pagesize=512M </span><br></pre></td></tr></table></figure>

<p># 各级巨页的数量 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hugeadm --pool-list </span><br><span class="line">Size Minimum Current Maximum Default </span><br><span class="line">2097152 0 0 0 </span><br><span class="line">536870912 0 0 0 * # 系统默认的巨页是512MB </span><br><span class="line">17179869184 0 0 0 </span><br></pre></td></tr></table></figure>
</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ps/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  Ps
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2024/01/23/01%20OS/Linux/%E6%8C%87%E4%BB%A4/mount/">
                Mount
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>

	</div>
	<div id="footer">
	<p>
	©2022-<span id="footerYear"></span> 
	<a href="/">Leah Ge</a> 
	
	
	<br>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>
