<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>01 原理</title>
      <link href="/2024/01/21/%E4%BC%98%E5%8C%96/03%20%E7%A3%81%E7%9B%98IO/01%20%E5%8E%9F%E7%90%86/"/>
      <url>/2024/01/21/%E4%BC%98%E5%8C%96/03%20%E7%A3%81%E7%9B%98IO/01%20%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>CPU的Cache、内存和磁盘之间的访问速度差异很大，当CPU计算所需要的数据并没有及时加载到内存或Cache中时，CPU将会浪费很多时间等待磁盘的读取。<br>高负载下，磁盘成为平静，CPU持续空闲以等待磁盘I&#x2F;O结束，发现并消除这些瓶颈能让性能和应用程序吞吐量提升几个数量。<br>计算机系统通过cache、RAM、固态盘、磁盘等多级存储结构，并配合多种调度算法，来消除或缓解这种速度不对等的影响。但是缓存空间总是有限的，我们可以利用局部性原理，尽可能的将热点数据提前从磁盘中读取出来，降低CPU等待磁盘的时间浪费。因此我们的部分优化手段其实是围绕着如何更充分的利用Cache获得更好的IO性能。<br>1 关闭mtime<br>2.磁盘块大小</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-4%20%E9%81%BF%E5%85%8D%E8%B7%A8numa%E8%AE%BF%E5%AD%98/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-4%20%E9%81%BF%E5%85%8D%E8%B7%A8numa%E8%AE%BF%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="numactl"><a href="#numactl" class="headerlink" title="numactl"></a>numactl</h1><p>不同NUMA内的CPU core访问同一个位置的内存，性能不同。内存访问延时从高到低为：跨CPU &gt; 跨NUMA不跨CPU &gt; NUMA内。</p><p>因此在应用程序运行时要尽可能的避免跨NUMA访问内存，我们可以通过设置线程的CPU亲和性来实现<br>通过numactl启动程序，如下面的启动命令表示启动test程序，只能在CPU core 28到core31运行（-C控制）,内存限定在numa node 0（-m 控制）。<br>numactl -C 28-31 -m 0 .&#x2F;test</p><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>numactl可以限制程序的cpu和内存所在numa节点，但是内核可能夸numa，导致程序调用内核时出现跨numa访问。<br>查询内核所在内存位置：<br>·cat &#x2F;proc&#x2F;iomem |grep Kernel·<br>查询各numa访存起止地址<br>·dmesg｜grep node·<br>从而计算出内核所在numa节点<br>如果内核和程序不在同一node，可以使用虚拟化方式，比如在docker内运行程序，从而让让程序调用的内核和程序在同一节点，从而减少跨node访问</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-3%20%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-3%20%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<p>TLB（Translation lookaside buffer）为页表（存放虚拟地址的页地址和物理地址的页地址的映射关系）在CPU内部的高速缓存。TLB的命中率越高，页表查询性能就越好。</p><p>TLB的一行为一个页的映射关系，也就是管理了一个页大小的内存：</p><p>TLB管理的内存大小 &#x3D; TLB行数 x 内存的页大小</p><p>同一个CPU的TLB行数固定，因此内存页越大，管理的内存越大，相同业务场景下的TLB命中率就越高。<br><strong>修改方式</strong></p><ul><li>调整内核内存页大小</li><li>设置内存大页</li><li>设置透明大页</li></ul><h1 id="设置内核内存页大小"><a href="#设置内核内存页大小" class="headerlink" title="设置内核内存页大小"></a>设置内核内存页大小</h1><p>修改Linux内核的内存页大小，需要在修改内核编译选项后重新编译内核（详情可参考内核源码编译安装），简要步骤如下所示：</p><ol><li>执行make menuconfig</li><li>选择PAGESIZE大小为64K</li><li>Kernel Features–&gt;Page size(64KB)</li><li>编译和安装内核</li></ol><h1 id="设置内存大页"><a href="#设置内存大页" class="headerlink" title="设置内存大页"></a>设置内存大页</h1><p>方法一： 在内核启动阶段设置，通过grub.cfg配置内核启动参数：</p><ul><li>hugepages：定义启动时内核中配置的内存大页的数量。</li><li>hugepagesz：定义启动时在内核中配置的内存大页的大小。</li><li>default_hugepagesz：定义启动时在内核中配置的内存大页的默认大小。<br>方法二：在运行时设置<br>例如：设置node中2 MB大页的数量为20。<br><code># echo 20 &gt; /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages</code></li></ul><h1 id="设置透明大页"><a href="#设置透明大页" class="headerlink" title="设置透明大页"></a>设置透明大页</h1><p>透明大页是以上内存大页的升级版，使用透明大页，内核会自动为进程分配大页，因此无需手动保留大页。</p><p>设置&#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled的值为：</p><ul><li>always:在整个系统范围内启用THP，如果有进程大量使用连续的虚拟内存，则内核会尝试将大页分配给该进程。</li><li>madvise:内核仅将大页分配给madvise()系统调用指定的单个进程的内存区域。</li><li>never:禁用透明大页。<br>例如关闭透明大页的设置方法：</li></ul><p><code># echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-2%E5%86%85%E6%A0%B8%E5%8F%AF%E8%B0%83%E5%8F%82%E6%95%B0/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-2%E5%86%85%E6%A0%B8%E5%8F%AF%E8%B0%83%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>vm.dirty_background_bytes</td><td>触发pflush后台回写的脏内存字节数</td></tr><tr><td>vm.dirty_background_ratio</td><td>触发pflush后台回写的脏内存所占百分比</td></tr><tr><td>vm.dirty_bytes</td><td>触发一个写进程开始回写的脏内存字节数</td></tr><tr><td>vm.dirty_ratio</td><td>触发一个写进程开始回写的脏内存所占百分比</td></tr><tr><td>vm.dirty_expire_centisecs</td><td>适于pflush的脏内存的最小时间</td></tr><tr><td>vm.dirty_writeback_centisecs</td><td>pflush活跃时间间隔</td></tr><tr><td>vm.nr_hugepages</td><td>内存大页的数量</td></tr><tr><td>vm.max_map_count</td><td>定义一个进程可以使用的最大内存映射区域数量</td></tr><tr><td>vm.min_free_kbytes</td><td>设置期望的空闲内存数</td></tr><tr><td>vm.overcommit_memory</td><td>0：利用探索法允许合理的过度分配 <br>1：始终过度分配，这可以提高内存密集型任务的性能 <br>2：禁止过度分配</td></tr><tr><td>vm.swappiness</td><td>内核倾向于使用换页来释放内存的程度</td></tr><tr><td>kernel.numa_balancing</td><td>启动自动NUMA页平衡</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-8%20%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-8%20%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<p>中断负载均衡：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-7%20%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-7%20%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-6%20RCB/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-6%20RCB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-5%20Time%20Tick%E4%B8%AD%E6%96%AD/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-5%20Time%20Tick%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-4%20%E7%8B%AC%E5%8D%A0/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-4%20%E7%8B%AC%E5%8D%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-3%20%E4%BA%B2%E5%92%8C%E6%80%A7/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-3%20%E4%BA%B2%E5%92%8C%E6%80%A7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-2%20%E9%A2%84%E5%8F%96/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-2%20%E9%A2%84%E5%8F%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-1%20%E4%B8%BB%E9%A2%91/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-1%20%E4%B8%BB%E9%A2%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/02%20%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/02%20%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td>free</td><td>系统已用、可用、剩余内存和缓存、交换</td></tr><tr><td>&#x2F;proc&#x2F;meminfo</td><td>系统已用、可用、剩余内存和缓存、巨页</td></tr><tr><td>top  ps</td><td>进程虚拟、常驻、共享内存以及缺页异常</td></tr><tr><td>slabtop</td><td>系统slab缓存使用情况</td></tr><tr><td>vmstat</td><td>虚拟内存和物理内存统计信息</td></tr><tr><td>pidstat</td><td>进程&#x2F;线程内存、缓存信息</td></tr><tr><td>sar</td><td>历史统计信息</td></tr><tr><td>swapon</td><td>交换设备使用率</td></tr><tr><td>numactl</td><td>NUMA分配管理</td></tr><tr><td>numastat</td><td>NUMA分析</td></tr><tr><td>perf</td><td>内存PMC和跟踪点分析</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/01%20%E5%8E%9F%E7%90%86/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/01%20%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>同 CPU 管理一样，内存管理也是操作系统最核心的功能之一。内存主要用来存储系统和应用程序的指令、数据、缓存等。<br>1.提高命中率<br>2.降低伪共享<br>3.多路处理器架构中，连接到CPU本地内存相对于远程CPU访存时延更低，因此内存本地性也是个重要因素</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-1%E5%86%85%E5%AD%98%E6%9D%A1%E9%80%89%E6%8B%A9/"/>
      <url>/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-1%E5%86%85%E5%AD%98%E6%9D%A1%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="内存主频"><a href="#内存主频" class="headerlink" title="内存主频"></a>内存主频</h1><p>理论上提高内存条主频，性能会提升。但是也有可能造成性能下降，需要结合实际业务情况选择合适的主频。<br>可以在bios设置内存主频，步骤如下：</p><h1 id="内存颗粒"><a href="#内存颗粒" class="headerlink" title="内存颗粒"></a>内存颗粒</h1><p>不同内存颗粒的刷新速度不同，刷新速度会导致访存时延的差异。</p><h1 id="内存插法"><a href="#内存插法" class="headerlink" title="内存插法"></a>内存插法</h1><p>不同的内存插法会影响访存时延<br>TODO：补充数据</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux协议栈--NAPI机制</title>
      <link href="/2022/10/31/01%20OS/Linux/network/napi/"/>
      <url>/2022/10/31/01%20OS/Linux/network/napi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux协议栈–NAPI机制"><a href="#Linux协议栈–NAPI机制" class="headerlink" title="Linux协议栈–NAPI机制"></a>Linux协议栈–NAPI机制</h1><h3 id="Linux内核中的NAPI机制介绍"><a href="#Linux内核中的NAPI机制介绍" class="headerlink" title="Linux内核中的NAPI机制介绍"></a>Linux内核中的NAPI机制介绍</h3><p>本文将介绍Linux内核中的NAPI：Linux网络设备驱动程序中的一种支持新一代网络适配器的架构。</p><p><code>New API（NAPI）</code>用于支持高速网卡处理网络数据包的一种机制 - 例如在Linux 2.6内核版本中引入的千兆以太网卡，后来又被移植到了2.4.x版本中。<br>以前的网络设备驱动程序架构已经不能适用于每秒产生数千个中断的高速网络设备，并且它可能导致整个系统处于<code>饥饿</code>状态（译者注：<code>饥饿</code>状态的意思是系统忙于处理中断程序，没有时间执行其他程序）。<br>有些网络设备具有中断合并，或者将多个数据包组合在一起来减少中断请求这种高级功能。</p><p>在内核没有使用NAPI来支持这些高级特性之前，这些功能只能全部在设备驱动程序中结合抢占机制（例如基于定时器中断），甚至中断程序范围之外的轮询程序（例如：内核线程，tasklet等）中实现。<br>正如我们看到的，网络子系统中加入的这个新特性是用于更好的支持中断缓解和数据包限制等功能，更重要的是它允许内核通过<code>round-robin</code>策略将负载分发到不同网络设备上。<br>NAPI特性的添加不会影响内核的向后兼容性。</p><h3 id="非NAPI帧的接收"><a href="#非NAPI帧的接收" class="headerlink" title="非NAPI帧的接收"></a>非NAPI帧的接收</h3><p>我们将讨论内核在接收一个数据帧后的大致处理流程，不会详细叙述所有细节。<br>我们认为有必要先了解一下传统的数据包处理流程以便更好的理解NAPI和传统收包方式的区别。<br>在传统的收包方式中（如下图1）数据帧向网络协议栈中传递发生在中断上下文（在接收数据帧时）中调用<code>netif_rx</code>的函数中。 这个函数还有一个变体<code>netif_rx_ni</code>，他被用于中断上下文之外。<br><img src="./a8_fig1_en.jpg"><br>图1 - Non-NAPI frame reception<br><code>netif_rx</code>函数将网卡中收到的数据包（包装在一个socket buffer中）放到系统中的接收队列中（<code>input_pkt_queue</code>），前提是这个接收队列的长度没有大于<code>netdev_max_backlog</code>。这个参数和另外一些参数可以在<code>/proc</code>文件系统中看到（&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core文件中，可以手动调整这个数值）。</p><p>清单1 - <code>softnet_data</code>结构体的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Incoming packets are placed on per-cpu queues so that</span><br><span class="line"> * no locking is needed.</span><br><span class="line"> */</span><br><span class="line">struct softnet_data</span><br><span class="line">&#123;</span><br><span class="line">    struct net_device *output_queue;</span><br><span class="line">    struct sk_buff_head input_pkt_queue;</span><br><span class="line">    struct list_head poll_list;</span><br><span class="line">    struct sk_buff *completion_queue;</span><br><span class="line">    struct net_device backlog_dev;</span><br><span class="line">#ifdef CONFIG_NET_DMA</span><br><span class="line">    struct dma_chan *net_dma;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如清单1所示，<code>input_pkt_queue</code>是<code>softnet_data</code>结构体中的一个成员，定义在<code>netdevice.h</code>文件中。<br>如果接收到的数据包没有因为<code>input_pkt_queue</code>队列已满而被丢弃，它会被<code>netif_rx_schedule</code>函数调度给软中断<code>NET_RX_SOFTIRQ</code>处理，<code>netif_rx_schedule</code>函数在<code>netif_rx</code>函数内部被调用。<br>软中断<code>NET_RX_SOFTIRQ</code>的处理逻辑在<code>net_rx_action</code>函数中实现。<br>此时，我们可以说此函数将数据包从<code>input_pkt_queue</code>队列中传递给了网络协议栈，现在数据包可以被处理了。</p><h3 id="NAPI帧的接收"><a href="#NAPI帧的接收" class="headerlink" title="NAPI帧的接收"></a>NAPI帧的接收</h3><p>在NAPI架构中（如图2），当接收到数据包产生中断时，驱动程序会通知网络子系统有新的数据包到来（而不是立即处理数据包），这样就可以在ISR（Interrupt Service Routines - 中断服务程序）上下文之外使用轮询的方式来一次性接收多个数据包。<br><img src="./a8_fig2_en.jpg"><br>图2 - NAPI frame reception<br>因此网卡支持NAPI必须满足几个条件：驱动程序不再使用数据包接收队列，网卡本身需要维护一个缓冲区来保存接收到数据包，并且可以禁止中断。<br>这种方法减少了中断的产生并且在突发情况下减少了丢包的可能性，避免了接收队列的饱和。<br>从NAPI实现的角度来看，与传统收包方式的不同地方在中断程序和轮询函数上（在<code>net_device</code>结构体中定义），定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*poll)(struct net_device *dev, int *budget);</span><br></pre></td></tr></table></figure><p>除此之外，<code>net_device</code>结构体中还有另外两个属性<code>quota</code>和<code>weight</code>，他们用于在一个轮询周期中实现抢占机制（译者注：意思是通过这两个参数来控制一个轮询周期的运行时间）我们将在后面详细讨论。<br>NAPI模型中的中断函数将数据帧传送到协议栈的任务交给<code>poll</code>函数执行。 换句话说中断函数的工作被简化为禁用网络设备中断（再此期间设备可以继续接收数据帧），和确认中断然后调度（通过<code>netif_rx_schedule</code>函数调度）软中断<code>NET_RX_SOFTIRQ</code>关联的<code>net_rx_action</code>函数。<br>等待被轮询的设备通过<code>netif_rx_schedule</code>函数将<code>net_device</code>结构体实例的指针加入到<code>poll_list</code>链表中。 在调用<code>net_rx_action</code>函数执行软中断<code>NET_RX_SOFTIRQ</code>时会遍历<code>poll_list</code>链表，然后调用每个设备的<code>poll()</code>函数将数据帧存放在<code>socket buffers</code>中并通知上层协议栈。</p><p><code>net_rx_action</code>函数的执行步骤如下：</p><ol><li>回收当前处理器的<code>poll_list</code>链表的引用。</li><li>将<code>jiffies</code>的值保存在<code>start_time</code>变量中。</li><li>设置轮询的<code>budget</code>（预算，可处理的数据包数量）为<code>netdev_budget</code>变量的初始值（这个值可以通过<code>/proc/sys/net/core/netdev_budget</code>来配置）</li><li>轮询<code>poll_list</code>链表中的每个设备，直到你的<code>budget</code>用完，当你的运行时间还没有超过一个<code>jiffies</code>时:<br>a) 如果<code>quantum</code>（配额）为正值则调用设备的<code>poll()</code>函数，否则将<code>weight</code>的值加到<code>quantum</code>中，将设备放回<code>poll_list</code>链表；<br>a.1) 如果<code>poll()</code>函数返回一个非零值，将<code>weight</code>的值设置到<code>quantum</code>中然后将设备放回<code>poll_list</code>链表；<br>a.2) 如果<code>poll()</code>函数返回零值，说明设备已经被移除<code>poll_list</code>链表（不再处于轮询状态）。</li></ol><p><code>budget</code>的值和<code>net_device</code>结构体的指针会传递到<code>poll()</code>函数中。<code>poll()</code>函数应该根据数据帧的处理数量来减小<code>budget</code>的值。数据帧从网络设备的缓冲区中复制出来包装在<code>socket buffers</code>中，然后通过<code>netif_receive_skb</code>函数传递到协议栈中去。</p><p>抢占策略是依赖<code>budget</code>变量的配额机制实现的：<code>poll()</code>函数必须根据分配给设备的最大配额来决定可以传递多少个数据包给内核。 当配额使用完就不允许在传递数据包给内核了，应该轮询<code>poll_list</code>链表中的下一个设备了。因此<code>poll()</code>必须和减小<code>budget</code>的值一样根据数据帧的处理数量来减小<code>quota</code>的值。</p><p>如果驱动在用完了所有的<code>quota</code>之后还没有传递完队列中所有的数据包，<code>poll()</code>函数必须停止运行并返回一个非NULL值。<br>如果所有数据包都传递到了协议栈，驱动程序必须再次使能设备的中断并停止轮询，然后调用<code>netif_rx_complete</code>函数（它会将设备从<code>poll_list</code>链表去除），最后停止运行并返回零值给调用者（<code>net_rx_action</code>函数）。</p><p><code>net_device</code>结构体中的另一个重要成员<code>weight</code>，它用于每次调用<code>poll()</code>函数时重置<code>quota</code>的值。 很明显<code>weight</code>的值必须被初始化为一个固定的正值。通常对于高速网卡这个值一般在16和32之间，对于千兆网卡来说这个值会大一点（通常时64）。<br>从<code>net_rx_action</code>函数的实现中我们可以看到当<code>weight</code>的值设置太大时，驱动使用的<code>budget</code>会超过<code>quantum</code>，此时会导致一个轮询周期的时间变长。</p><p>在清单 2中我们给出了设备驱动程序接收中断并执行轮询函数的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t sample_netdev_intr(int irq, void *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct net_device *netdev = dev;</span><br><span class="line">    struct nic *nic = netdev_priv(netdev);</span><br><span class="line"></span><br><span class="line">    if (! nic-&gt;irq_pending())</span><br><span class="line">        return IRQ_NONE;</span><br><span class="line"></span><br><span class="line">    /* Ack interrupt(s) */</span><br><span class="line">    nic-&gt;ack_irq();</span><br><span class="line"></span><br><span class="line">    nic-&gt;disable_irq();  </span><br><span class="line"></span><br><span class="line">    netif_rx_schedule(netdev);</span><br><span class="line"></span><br><span class="line">    return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int sample_netdev_poll(struct net_device *netdev, int *budget)</span><br><span class="line">&#123;</span><br><span class="line">    struct nic *nic = netdev_priv(netdev);</span><br><span class="line"></span><br><span class="line">    unsigned int work_to_do = min(netdev-&gt;quota, *budget);</span><br><span class="line">    unsigned int work_done = 0;</span><br><span class="line"></span><br><span class="line">    nic-&gt;announce(&amp;work_done, work_to_do);</span><br><span class="line"></span><br><span class="line">    /* If no Rx announce was done, exit polling state. */</span><br><span class="line"></span><br><span class="line">    if(work_done == 0) || !netif_running(netdev)) &#123;</span><br><span class="line"></span><br><span class="line">    netif_rx_complete(netdev);</span><br><span class="line">    nic-&gt;enable_irq();  </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *budget -= work_done;</span><br><span class="line">    netdev-&gt;quota -= work_done;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图3、图4分别展示了非NAPI和NAPI模型中数据包接收处理过程的时序图：<br><img src="./a8_fig3_en.jpg"><br>图3 - 非NAPI模型的时序图<br><img src="./a8_fig4_en.jpg"><br>图4 - NAPI模型的时序图</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>本文翻译自<a href="http://www.eantcal.eu/home/articles-and-publications/articles-eng/linux-napi-compliant-network-device-driver">Linux NAPI-compliant network device driver</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux Kernel 编译选项</title>
      <link href="/2022/10/31/01%20OS/Linux/Kernel/kernel_config/"/>
      <url>/2022/10/31/01%20OS/Linux/Kernel/kernel_config/</url>
      
        <content type="html"><![CDATA[<p>有时候我们需要查看Linux系统的内核是否在编译的时候的编译选项，从而确定某个模块是否已经加入到内核以及参数设置等等。</p><p>方法有两种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># zcat /proc/config.gz</span><br><span class="line"></span><br><span class="line"># cat /boot/config-$(uname -r)</span><br></pre></td></tr></table></figure><p>第一种方法要求在内核编译时增减相应的选项才会生成，很多系统找不到&#x2F;proc&#x2F;config.gz这个文件。不过第二种方法通常不会遇到什么问题。准确的说，这两个文件就是内核编译使使用的config文件。</p><p>比如查看bcache是否编译进了内核：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat /boot/config-$(uname -r) | grep BCACHE</span><br></pre></td></tr></table></figure><p>Ubuntu除以上外，还可以：</p><ol><li>文件下查看<br>&#x2F;usr&#x2F;src&#x2F;linux-headers-$(version)-generic&#x2F;.config</li></ol><p>Redhat 除以上外，还可以从系统&#x2F;usr&#x2F;src&#x2F;kernel目录下获取</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># uname -r</span></span><br><span class="line"><span class="number">4.9</span><span class="number">.77</span></span><br><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># cd /usr/src/kernels</span></span><br><span class="line">[<span class="meta">root@localhost kernels</span>]<span class="meta"># ls</span></span><br><span class="line"><span class="number">4.9</span><span class="number">.77</span><span class="number">-30.</span>el7.x86_64</span><br><span class="line">[<span class="meta">root@localhost kernels</span>]<span class="meta"># cd 4.9.77-30.el7.x86_64/</span></span><br><span class="line">[<span class="meta">root@localhost 4.9.77-30.el7.x86_64</span>]<span class="meta"># ls -a</span></span><br><span class="line">.     block   .config      drivers   include  Kconfig  Makefile        net      security    tools</span><br><span class="line">..    certs   .config.old  firmware  <span class="keyword">init</span>     kernel   mm              samples  sound       usr</span><br><span class="line">arch  config  crypto       fs        ipc      lib      Module.symvers  scripts  System.map  virt</span><br></pre></td></tr></table></figure><p>如上所示，当前内核的编译配置文件为：.config</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux Kernel 网络协议栈之GRO</title>
      <link href="/2022/10/31/01%20OS/Linux/network/gro/"/>
      <url>/2022/10/31/01%20OS/Linux/network/gro/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-kernel-网络协议栈之GRO-Generic-receive-offload"><a href="#linux-kernel-网络协议栈之GRO-Generic-receive-offload" class="headerlink" title="linux kernel 网络协议栈之GRO(Generic receive offload)"></a>linux kernel 网络协议栈之GRO(Generic receive offload)</h1><p>GRO(Generic receive offload)在内核2.6.29之后合并进去的，作者是一个华裔Herbert Xu ,GRO的简介可以看这里：</p><p><a href="http://lwn.net/Articles/358910/">http://lwn.net/Articles/358910/</a></p><p>先来描述一下GRO的作用，GRO是针对网络接受包的处理的，并且只是针对NAPI类型的驱动，因此如果要支持GRO，不仅要内核支持，而且驱动也必须调用相应的借口，用ethtool -K gro on来设置，如果报错就说明网卡驱动本身就不支持GRO。</p><p>GRO类似tso，可是tso只支持发送数据包，这样你tcp层大的段会在网卡被切包，然后再传递给对端，而如果没有gro，则小的段会被一个个送到协议栈，有了gro之后，就会在接收端做一个反向的操作(想对于tso).也就是将tso切好的数据包组合成大包再传递给协议栈。</p><p>如果实现了GRO支持的驱动是这样子处理数据的，在NAPI的回调poll方法中读取数据包，然后调用GRO的接口napi_gro_receive或者napi_gro_frags来将数据包feed进协议栈。而具体GRO的工作就是在这两个函数中进行的，他们最终都会调用__napi_gro_receive。下面就是napi_gro_receive，它最终会调用napi_skb_finish以及__napi_gro_receive。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">gro_result_t</span> <span class="title">napi_gro_receive</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">skb_gro_reset_offset</span>(skb);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">napi_skb_finish</span>(__napi_gro_receive(napi, skb), skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后GRO什么时候会将数据feed进协议栈呢，这里会有两个退出点，一个是在napi_skb_finish里，他会通过判断__napi_gro_receive的返回值，来决定是需要将数据包立即feed进协议栈还是保存起来，还有一个点是当napi的循环执行完毕时，也就是执行napi_complete的时候，先来看napi_skb_finish,napi_complete我们后面会详细介绍。</p><p>在NAPI驱动中，直接调用netif_receive_skb会将数据feed 进协议栈，因此这里如果返回值是NORMAL，则直接调用netif_receive_skb来将数据送进协议栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">gro_result_t</span> <span class="title">napi_skb_finish</span><span class="params">(<span class="type">gro_result_t</span> ret, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> GRO_NORMAL:</span><br><span class="line"><span class="comment">//将数据包送进协议栈</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">netif_receive_skb</span>(skb))</span><br><span class="line">ret = GRO_DROP;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//表示skb可以被free，因为gro已经将skb合并并保存起来。</span></span><br><span class="line"><span class="keyword">case</span> GRO_DROP:</span><br><span class="line"><span class="keyword">case</span> GRO_MERGED_FREE:</span><br><span class="line"><span class="comment">//free skb</span></span><br><span class="line"><span class="built_in">kfree_skb</span>(skb);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//这个表示当前数据已经被gro保存起来，但是并没有进行合并，因此skb还需要保存。</span></span><br><span class="line"><span class="keyword">case</span> GRO_HELD:</span><br><span class="line"><span class="keyword">case</span> GRO_MERGED:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GRO的主要思想就是，组合一些类似的数据包(基于一些数据域，后面会介绍到)为一个大的数据包(一个skb)，然后feed给协议栈，这里主要是利用Scatter-gather IO，也就是skb的struct skb_shared_info域(我前面的blog讲述ip分片的时候有详细介绍这个域)来合并数据包。</p><p>在每个NAPI的实例都会包括一个域叫gro_list,保存了我们积攒的数据包(将要被merge的).然后每次进来的skb都会在这个链表里面进行查找，看是否需要merge。而gro_count表示当前的gro_list中的skb的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">napi_struct</span> &#123;</span><br><span class="line">................................................</span><br><span class="line"><span class="comment">//个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>gro_count;</span><br><span class="line">......................................</span><br><span class="line"><span class="comment">//积攒的数据包</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span>*gro_list;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span>*skb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>紧接着是gro最核心的一个数据结构napi_gro_cb,它是保存在skb的cb域中，它保存了gro要使用到的一些上下文，这里每个域kernel的注释都比较清楚。到后面我们会看到这些域的具体用途。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">napi_gro_cb</span> &#123;</span><br><span class="line"><span class="comment">/* Virtual address of skb_shinfo(skb)-&gt;frags[0].page + offset. */</span></span><br><span class="line"><span class="type">void</span> *frag0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Length of frag0. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> frag0_len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This indicates where we are processing relative to skb-&gt;data. */</span></span><br><span class="line"><span class="type">int</span> data_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is non-zero if the packet may be of the same flow. */</span></span><br><span class="line"><span class="type">int</span> same_flow;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is non-zero if the packet cannot be merged with the new skb. */</span></span><br><span class="line"><span class="type">int</span> flush;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of segments aggregated. */</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free the skb? */</span></span><br><span class="line"><span class="type">int</span> free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一层协议都实现了自己的gro回调函数，gro_receive和gro_complete，gro系统会根据协议来调用对应回调函数，其中gro_receive是将输入skb尽量合并到我们gro_list中。而gro_complete则是当我们需要提交gro合并的数据包到协议栈时被调用的。</p><p>下面就是ip层和tcp层对应的回调方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">net_protocol</span> tcp_protocol = &#123;</span><br><span class="line">.handler =tcp_v4_rcv,</span><br><span class="line">.err_handler =tcp_v4_err,</span><br><span class="line">.gso_send_check = tcp_v4_gso_send_check,</span><br><span class="line">.gso_segment =tcp_tso_segment,</span><br><span class="line"><span class="comment">//gso回调</span></span><br><span class="line">.gro_receive =tcp4_gro_receive,</span><br><span class="line">.gro_complete =tcp4_gro_complete,</span><br><span class="line">.no_policy =<span class="number">1</span>,</span><br><span class="line">.netns_ok =<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">packet_type</span> ip_packet_type __read_mostly = &#123;</span><br><span class="line">.type = <span class="built_in">cpu_to_be16</span>(ETH_P_IP),</span><br><span class="line">.func = ip_rcv,</span><br><span class="line">.gso_send_check = inet_gso_send_check,</span><br><span class="line">.gso_segment = inet_gso_segment,</span><br><span class="line"><span class="comment">//gso回调</span></span><br><span class="line">.gro_receive = inet_gro_receive,</span><br><span class="line">.gro_complete = inet_gro_complete,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>gro的入口函数是napi_gro_receive，它的实现很简单，就是将skb包含的gro上下文reset，然后调用__napi_gro_receive,最终通过napi_skb_finis来判断是否需要讲数据包feed进协议栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">gro_result_t</span> <span class="title">napi_gro_receive</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//reset gro对应的域</span></span><br><span class="line"><span class="built_in">skb_gro_reset_offset</span>(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">napi_skb_finish</span>(__napi_gro_receive(napi, skb), skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>napi_skb_finish一开始已经介绍过了，这个函数主要是通过判断传递进来的ret(__napi_gro_receive的返回值),来决定是否需要feed数据进协议栈。它的第二个参数是前面处理过的skb。</p><p>这里再来看下skb_gro_reset_offset，首先要知道一种情况，那就是skb本身不包含数据(包括头也没有),而所有的数据都保存在skb_shared_info中(支持S&#x2F;G的网卡有可能会这么做).此时我们如果想要合并的话，就需要将包头这些信息取出来，也就是从skb_shared_info的frags[0]中去的，在 skb_gro_reset_offset中就有做这个事情,而这里就会把头的信息保存到napi_gro_cb 的frags0中。并且此时frags必然不会在high mem,要么是线性区，要么是dma(S&#x2F;G io)。 来看skb_gro_reset_offset。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">skb_gro_reset_offset</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;data_offset = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;frag0 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;frag0_len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//如果mac_header和skb-&gt;tail相等并且地址不在高端内存，则说明包头保存在skb_shinfo中，所以我们需要从frags中取得对应的数据包</span></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;mac_header == skb-&gt;tail &amp;&amp;</span><br><span class="line">    !<span class="built_in">PageHighMem</span>(<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].page)) &#123;</span><br><span class="line"><span class="comment">//可以看到frag0保存的就是对应的skb的frags的第一个元素的地址</span></span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;frag0 =</span><br><span class="line"><span class="built_in">page_address</span>(<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].page) +</span><br><span class="line"><span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].page_offset;</span><br><span class="line"><span class="comment">//然后保存对应的大小。</span></span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;frag0_len = <span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是__napi_gro_receive，它主要是遍历gro_list,然后给same_flow赋值，这里要注意，same_flow是一个标记，表示某个skb是否有可能会和当前要处理的skb是相同的流,而这里的相同会在每层都进行判断，也就是在设备层，ip层，tcp层都会判断，这里就是设备层的判断了。这里的判断很简单，有2个条件：<br>1 设备是否相同<br>2 mac的头必须相等</p><p>如果上面两个条件都满足，则说明两个skb有可能是相同的flow，所以设置same_flow,以便与我们后面合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">gro_result_t</span></span><br><span class="line">__napi_gro_receive(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">netpoll_rx_on</span>(skb))</span><br><span class="line"><span class="keyword">return</span> GRO_NORMAL;</span><br><span class="line"><span class="comment">//遍历gro_list,然后判断是否有可能两个skb 相似。</span></span><br><span class="line"><span class="keyword">for</span> (p = napi-&gt;gro_list; p; p = p-&gt;next) &#123;</span><br><span class="line"><span class="comment">//给same_flow赋值</span></span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(p)-&gt;same_flow =</span><br><span class="line">(p-&gt;dev == skb-&gt;dev) &amp;&amp;</span><br><span class="line">!<span class="built_in">compare_ether_header</span>(<span class="built_in">skb_mac_header</span>(p),</span><br><span class="line">      <span class="built_in">skb_gro_mac_header</span>(skb));</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(p)-&gt;flush = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用dev_gro_receiv</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dev_gro_receive</span>(napi, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来来看dev_gro_receive，这个函数我们分做两部分来看，第一部分是正常处理部分，第二部份是处理frag0的部分。</p><p>来看如何判断是否支持GRO，这里每个设备的features会在驱动初始化的时候被初始化，然后如果支持GRO，则会包括NETIF_F_GRO。 还有要注意的就是，gro不支持切片的ip包，因为ip切片的组包在内核的ip会做一遍，因此这里gro如果合并的话，没有多大意义，而且还增加复杂度。</p><p>在dev_gro_receive中会遍历对应的ptype(也就是协议的类链表，以前的blog有详细介绍),然后调用对应的回调函数，一般来说这里会调用文章开始说的ip_packet_type，也就是 inet_gro_receive。</p><p>而 inet_gro_receive的返回值表示我们需要立刻feed 进协议栈的数据包，如果为空，则说明不需要feed数据包进协议栈。后面会分析到这里他的详细算法。</p><p>而如果当inet_gro_receive正确返回后，如果same_flow没有被设置，则说明gro list中不存在能和当前的skb合并的项，因此此时需要将skb插入到gro list中。这个时候的返回值就是HELD。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> gro_result <span class="title">dev_gro_receive</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span> **pp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">packet_type</span> *ptype;</span><br><span class="line">__be16 type = skb-&gt;protocol;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> *head = &amp;ptype_base[<span class="built_in">ntohs</span>(type) &amp; PTYPE_HASH_MASK];</span><br><span class="line"><span class="type">int</span> same_flow;</span><br><span class="line"><span class="type">int</span> mac_len;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">gro_result</span> ret;</span><br><span class="line"><span class="comment">//判断是否支持gro</span></span><br><span class="line"><span class="keyword">if</span> (!(skb-&gt;dev-&gt;features &amp; NETIF_F_GRO))</span><br><span class="line"><span class="keyword">goto</span> normal;</span><br><span class="line"><span class="comment">//判断是否为切片的ip包</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">skb_is_gso</span>(skb) || <span class="built_in">skb_has_frags</span>(skb))</span><br><span class="line"><span class="keyword">goto</span> normal;</span><br><span class="line"></span><br><span class="line"><span class="built_in">rcu_read_lock</span>();</span><br><span class="line"><span class="comment">//开始遍历对应的协议表</span></span><br><span class="line"><span class="built_in">list_for_each_entry_rcu</span>(ptype, head, list) &#123;</span><br><span class="line"><span class="keyword">if</span> (ptype-&gt;type != type || ptype-&gt;dev || !ptype-&gt;gro_receive)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">skb_set_network_header</span>(skb, <span class="built_in">skb_gro_offset</span>(skb));</span><br><span class="line">mac_len = skb-&gt;network_header - skb-&gt;mac_header;</span><br><span class="line">skb-&gt;mac_len = mac_len;</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;same_flow = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;flush = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;free = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//调用对应的gro接收函数</span></span><br><span class="line">pp = ptype-&gt;<span class="built_in">gro_receive</span>(&amp;napi-&gt;gro_list, skb);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rcu_read_unlock</span>();</span><br><span class="line"><span class="comment">//如果是没有实现gro的协议则也直接调到normal处理</span></span><br><span class="line"><span class="keyword">if</span> (&amp;ptype-&gt;list == head)</span><br><span class="line"><span class="keyword">goto</span> normal;</span><br><span class="line"></span><br><span class="line"><span class="comment">//到达这里，则说明gro_receive已经调用过了，因此进行后续的处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到same_flow</span></span><br><span class="line">same_flow = <span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;same_flow;</span><br><span class="line"><span class="comment">//看是否有需要free对应的skb</span></span><br><span class="line">ret = <span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;free ? GRO_MERGED_FREE : GRO_MERGED;</span><br><span class="line"><span class="comment">//如果返回值pp部位空，则说明pp需要马上被feed进协议栈</span></span><br><span class="line"><span class="keyword">if</span> (pp) &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span> *nskb = *pp;</span><br><span class="line"></span><br><span class="line">*pp = nskb-&gt;next;</span><br><span class="line">nskb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//调用napi_gro_complete 将pp刷进协议栈</span></span><br><span class="line"><span class="built_in">napi_gro_complete</span>(nskb);</span><br><span class="line">napi-&gt;gro_count--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果same_flow有设置，则说明skb已经被正确的合并，因此直接返回。</span></span><br><span class="line"><span class="keyword">if</span> (same_flow)</span><br><span class="line"><span class="keyword">goto</span> ok;</span><br><span class="line"><span class="comment">//查看是否有设置flush和gro list的个数是否已经超过限制</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;flush || napi-&gt;gro_count &gt;= MAX_GRO_SKBS)</span><br><span class="line"><span class="keyword">goto</span> normal;</span><br><span class="line"></span><br><span class="line"><span class="comment">//到达这里说明skb对应gro list来说是一个新的skb，也就是说当前的gro list并不存在可以和skb合并的数据包，因此此时将这个skb插入到gro_list的头。</span></span><br><span class="line">napi-&gt;gro_count++;</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;count = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">skb_shinfo</span>(skb)-&gt;gso_size = <span class="built_in">skb_gro_len</span>(skb);</span><br><span class="line"><span class="comment">//将skb插入到gro list的头</span></span><br><span class="line">skb-&gt;next = napi-&gt;gro_list;</span><br><span class="line">napi-&gt;gro_list = skb;</span><br><span class="line"><span class="comment">//设置返回值</span></span><br><span class="line">ret = GRO_HELD;</span><br></pre></td></tr></table></figure><p>然后就是处理frag0的部分，以及不支持gro的处理。</p><p>这里要需要对skb_shinfo的结构比较了解，我在以前的blog对这个有很详细的介绍，可以去查阅。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pull:</span><br><span class="line"><span class="comment">//是否需要拷贝头</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">skb_headlen</span>(skb) &lt; <span class="built_in">skb_gro_offset</span>(skb)) &#123;</span><br><span class="line"><span class="comment">//得到对应的头的大小</span></span><br><span class="line"><span class="type">int</span> grow = <span class="built_in">skb_gro_offset</span>(skb) - <span class="built_in">skb_headlen</span>(skb);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BUG_ON</span>(skb-&gt;end - skb-&gt;tail &lt; grow);</span><br><span class="line"><span class="comment">//开始拷贝</span></span><br><span class="line"><span class="built_in">memcpy</span>(<span class="built_in">skb_tail_pointer</span>(skb), <span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;frag0, grow);</span><br><span class="line"></span><br><span class="line">skb-&gt;tail += grow;</span><br><span class="line">skb-&gt;data_len -= grow;</span><br><span class="line"><span class="comment">//更新对应的frags[0]</span></span><br><span class="line"><span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].page_offset += grow;</span><br><span class="line"><span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].size -= grow;</span><br><span class="line"><span class="comment">//如果size为0了，则说明第一个页全部包含头，因此需要将后面的页全部移动到前面。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].size)) &#123;</span><br><span class="line"><span class="built_in">put_page</span>(<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].page);</span><br><span class="line"><span class="comment">//开始移动。</span></span><br><span class="line"><span class="built_in">memmove</span>(<span class="built_in">skb_shinfo</span>(skb)-&gt;frags,</span><br><span class="line"><span class="built_in">skb_shinfo</span>(skb)-&gt;frags + <span class="number">1</span>,</span><br><span class="line">--<span class="built_in">skb_shinfo</span>(skb)-&gt;nr_frags * <span class="built_in">sizeof</span>(<span class="type">skb_frag_t</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">normal:</span><br><span class="line">ret = GRO_NORMAL;</span><br><span class="line"><span class="keyword">goto</span> pull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是inet_gro_receive，这个函数是ip层的gro receive回调函数，函数很简单，首先取得ip头，然后判断是否需要从frag复制数据，如果需要则复制数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到偏移</span></span><br><span class="line">off = <span class="built_in">skb_gro_offset</span>(skb);</span><br><span class="line"><span class="comment">//得到头的整个长度(mac+ip)</span></span><br><span class="line">hlen = off + <span class="built_in">sizeof</span>(*iph);</span><br><span class="line"><span class="comment">//得到ip头</span></span><br><span class="line">iph = <span class="built_in">skb_gro_header_fast</span>(skb, off);</span><br><span class="line"><span class="comment">//是否需要复制</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">skb_gro_header_hard</span>(skb, hlen)) &#123;</span><br><span class="line">iph = <span class="built_in">skb_gro_header_slow</span>(skb, hlen, off);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!iph))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是一些校验工作，比如协议是否支持gro_reveive,ip头是否合法等等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">proto = iph-&gt;protocol &amp; (MAX_INET_PROTOS - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">rcu_read_lock</span>();</span><br><span class="line">ops = <span class="built_in">rcu_dereference</span>(inet_protos[proto]);</span><br><span class="line"><span class="comment">//是否支持gro</span></span><br><span class="line"><span class="keyword">if</span> (!ops || !ops-&gt;gro_receive)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="comment">//ip头是否合法</span></span><br><span class="line"><span class="keyword">if</span> (*(u8 *)iph != <span class="number">0x45</span>)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="comment">//ip头教研</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">ip_fast_csum</span>((u8 *)iph, iph-&gt;ihl)))</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br></pre></td></tr></table></figure><p>然后就是核心的处理部分，它会遍历整个gro_list,然后进行same_flow和是否需要flush的判断。</p><p>这里ip层设置same_flow是根据下面的规则的:<br>1 4层的协议必须相同<br>2 tos域必须相同<br>3 源，目的地址必须相同</p><p>如果3个条件一个不满足，则会设置same_flow为0。<br>这里还有一个就是判断是否需要flush 对应的skb到协议栈，这里的判断条件是这样子的。<br>1 ip包的ttl不一样<br>2 ip包的id顺序不对<br>3 如果是切片包</p><p>如果上面两个条件某一个满足，则说明skb需要被flush出gro。</p><p>不过这里要注意只有两个数据包是same flow的情况下，才会进行flush判断。原因很简单，都不是有可能进行merge的包，自然没必要进行flush了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出id</span></span><br><span class="line">id = <span class="built_in">ntohl</span>(*(__be32 *)&amp;iph-&gt;id);</span><br><span class="line"><span class="comment">//判断是否需要切片</span></span><br><span class="line">flush = (u16)((<span class="built_in">ntohl</span>(*(__be32 *)iph) ^ <span class="built_in">skb_gro_len</span>(skb)) | (id ^ IP_DF));</span><br><span class="line">id &gt;&gt;= <span class="number">16</span>;</span><br><span class="line"><span class="comment">//开始遍历gro list</span></span><br><span class="line"><span class="keyword">for</span> (p = *head; p; p = p-&gt;next) &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iphdr</span> *iph2;</span><br><span class="line"><span class="comment">//如果上一层已经不可能same flow则直接继续下一个</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NAPI_GRO_CB</span>(p)-&gt;same_flow)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//取出ip头</span></span><br><span class="line">iph2 = <span class="built_in">ip_hdr</span>(p);</span><br><span class="line"><span class="comment">//开始same flow的判断</span></span><br><span class="line"><span class="keyword">if</span> ((iph-&gt;protocol ^ iph2-&gt;protocol) |</span><br><span class="line">    (iph-&gt;tos ^ iph2-&gt;tos) |</span><br><span class="line">    ((__force u32)iph-&gt;saddr ^ (__force u32)iph2-&gt;saddr) |</span><br><span class="line">    ((__force u32)iph-&gt;daddr ^ (__force u32)iph2-&gt;daddr)) &#123;</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(p)-&gt;same_flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始flush的判断。这里注意如果不是same_flow的话，就没必要进行flush的判断。</span></span><br><span class="line"><span class="comment">/* All fields must match except length and checksum. */</span></span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(p)-&gt;flush |=</span><br><span class="line">(iph-&gt;ttl ^ iph2-&gt;ttl) |</span><br><span class="line">((u16)(<span class="built_in">ntohs</span>(iph2-&gt;id) + <span class="built_in">NAPI_GRO_CB</span>(p)-&gt;count) ^ id);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(p)-&gt;flush |= flush;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;flush |= flush;</span><br><span class="line"><span class="comment">//pull ip头进gro，这里更新data_offset</span></span><br><span class="line"><span class="built_in">skb_gro_pull</span>(skb, <span class="built_in">sizeof</span>(*iph));</span><br><span class="line"><span class="comment">//设置传输层的头的位置</span></span><br><span class="line"><span class="built_in">skb_set_transport_header</span>(skb, <span class="built_in">skb_gro_offset</span>(skb));</span><br><span class="line"><span class="comment">//调用传输层的reveive方法。</span></span><br><span class="line">pp = ops-&gt;<span class="built_in">gro_receive</span>(head, skb);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line"><span class="built_in">rcu_read_unlock</span>();</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;flush |= flush;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是tcp层的gro方法，它的主要实现函数是tcp_gro_receive，他的流程和inet_gro_receiv类似，就是取得tcp的头，然后对gro list进行遍历，最终会调用合并方法。</p><p>首先来看gro list遍历的部分,它对same flow的要求就是source必须相同，如果不同则设置same flow为0.如果相同则跳到found部分，进行合并处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历gro list</span></span><br><span class="line"><span class="keyword">for</span> (; (p = *head); head = &amp;p-&gt;next) &#123;</span><br><span class="line"><span class="comment">//如果ip层已经不可能same flow则直接进行下一次匹配</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NAPI_GRO_CB</span>(p)-&gt;same_flow)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">th2 = <span class="built_in">tcp_hdr</span>(p);</span><br><span class="line"><span class="comment">//判断源地址</span></span><br><span class="line"><span class="keyword">if</span> (*(u32 *)&amp;th-&gt;source ^ *(u32 *)&amp;th2-&gt;source) &#123;</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(p)-&gt;same_flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是当找到能够合并的skb的时候的处理，这里首先来看flush的设置,这里会有4个条件：<br>1 拥塞状态被设置(TCP_FLAG_CWR).<br>2 tcp的ack的序列号不匹配 (这是肯定的，因为它只是对tso或者说gso进行反向操作)<br>3 skb的flag和从gro list中查找到要合并skb的flag 如果他们中的不同位 不包括TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH，这三个任意一个域。<br>4 tcp的option域不同</p><p>如果上面4个条件有一个满足，则会设置flush为1，也就是找到的这个skb(gro list中)必须被刷出到协议栈。</p><p>这里谈一下flags域的设置问题首先如果当前的skb设置了cwr，也就是发生了拥塞，那么自然前面被缓存的数据包需要马上被刷到协议栈，以便与tcp的拥塞控制马上进行。</p><p>而FIN和PSH这两个flag自然不需要一致，因为这两个和其他的不是互斥的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">found:</span><br><span class="line">flush = <span class="built_in">NAPI_GRO_CB</span>(p)-&gt;flush;</span><br><span class="line"><span class="comment">//如果设置拥塞，则肯定需要刷出skb到协议栈</span></span><br><span class="line">flush |= (__force <span class="type">int</span>)(flags &amp; TCP_FLAG_CWR);</span><br><span class="line"><span class="comment">//如果相差的域是除了这3个中的，就需要flush出skb</span></span><br><span class="line">flush |= (__force <span class="type">int</span>)((flags ^ <span class="built_in">tcp_flag_word</span>(th2)) &amp;</span><br><span class="line">  ~(TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH));</span><br><span class="line"><span class="comment">//ack的序列号必须一致</span></span><br><span class="line">flush |= (__force <span class="type">int</span>)(th-&gt;ack_seq ^ th2-&gt;ack_seq);</span><br><span class="line"><span class="comment">//tcp的option头必须一致</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="built_in">sizeof</span>(*th); i &lt; thlen; i += <span class="number">4</span>)</span><br><span class="line">flush |= *(u32 *)((u8 *)th + i) ^</span><br><span class="line"> *(u32 *)((u8 *)th2 + i);</span><br><span class="line"></span><br><span class="line">mss = <span class="built_in">skb_shinfo</span>(p)-&gt;gso_size;</span><br><span class="line"></span><br><span class="line">flush |= (len - <span class="number">1</span>) &gt;= mss;</span><br><span class="line">flush |= (<span class="built_in">ntohl</span>(th2-&gt;seq) + <span class="built_in">skb_gro_len</span>(p)) ^ <span class="built_in">ntohl</span>(th-&gt;seq);</span><br><span class="line"><span class="comment">//如果flush有设置则不会调用 skb_gro_receive，也就是不需要进行合并，否则调用skb_gro_receive进行数据包合并</span></span><br><span class="line"><span class="keyword">if</span> (flush || <span class="built_in">skb_gro_receive</span>(head, skb)) &#123;</span><br><span class="line">mss = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> out_check_final;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = *head;</span><br><span class="line">th2 = <span class="built_in">tcp_hdr</span>(p);</span><br><span class="line"><span class="comment">//更新p的头。到达这里说明合并完毕，因此需要更新合并完的新包的头。</span></span><br><span class="line"><span class="built_in">tcp_flag_word</span>(th2) |= flags &amp; (TCP_FLAG_FIN | TCP_FLAG_PSH);</span><br></pre></td></tr></table></figure><p>从上面我们可以看到如果tcp的包被设置了一些特殊的flag比如PSH，SYN这类的就必须马上把数据包刷出到协议栈。</p><p>下面就是最终的一些flags判断,比如第一个数据包进来都会到这里来判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">out_check_final:</span><br><span class="line">flush = len &lt; mss;</span><br><span class="line"><span class="comment">//根据flag得到flush</span></span><br><span class="line">flush |= (__force <span class="type">int</span>)(flags &amp; (TCP_FLAG_URG | TCP_FLAG_PSH |</span><br><span class="line">TCP_FLAG_RST | TCP_FLAG_SYN |</span><br><span class="line">TCP_FLAG_FIN));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; (!<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;same_flow || flush))</span><br><span class="line">pp = head;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;flush |= flush;</span><br></pre></td></tr></table></figure><p>这里要知道每次我们只会刷出gro list中的一个skb节点，这是因为每次进来的数据包我们也只会匹配一个。因此如果遇到需要刷出的数据包，会在dev_gro_receive中先刷出gro list中的，然后再将当前的skb feed进协议栈。</p><p>最后就是gro最核心的一个函数skb_gro_receive，它的主要工作就是合并，它有2个参数，第一个是gro list中和当前处理的skb是same flow的skb，第二个就是我们需要合并的skb。</p><p>这里要注意就是farg_list,其实gro对待skb_shared_info和ip层切片，组包很类似，就是frags放Scatter-Gather I&#x2F;O的数据包，frag_list放线性数据。这里gro 也是这样的，如果过来的skb支持Scatter-Gather I&#x2F;O并且数据是只放在frags中，则会合并frags，如果过来的skb不支持Scatter-Gather I&#x2F;O(数据头还是保存在skb中)，则合并很简单，就是新建一个skb然后拷贝当前的skb，并将gro list中的skb直接挂载到farg_list。</p><p>先来看支持Scatter-Gather I&#x2F;O的处理部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一些需要用到的变量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span> *p = *head;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span> *nskb;</span><br><span class="line"><span class="comment">//当前的skb的 share_ino</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">skb_shared_info</span> *skbinfo = <span class="built_in">skb_shinfo</span>(skb);</span><br><span class="line"><span class="comment">//当前的gro list中的要合并的skb的share_info</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">skb_shared_info</span> *pinfo = <span class="built_in">skb_shinfo</span>(p);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> headroom;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> len = <span class="built_in">skb_gro_len</span>(skb);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset = <span class="built_in">skb_gro_offset</span>(skb);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> headlen = <span class="built_in">skb_headlen</span>(skb);</span><br><span class="line"><span class="comment">//如果有frag_list的话，则直接去非Scatter-Gather I/O部分处理，也就是合并到frag_list.</span></span><br><span class="line"><span class="keyword">if</span> (pinfo-&gt;frag_list)</span><br><span class="line"><span class="keyword">goto</span> merge;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (headlen &lt;= offset) &#123;</span><br><span class="line"><span class="comment">//支持Scatter-Gather I/O的处理</span></span><br><span class="line"><span class="type">skb_frag_t</span> *frag;</span><br><span class="line"><span class="type">skb_frag_t</span> *frag2;</span><br><span class="line"><span class="type">int</span> i = skbinfo-&gt;nr_frags;</span><br><span class="line"><span class="comment">//这里遍历是从后向前。</span></span><br><span class="line"><span class="type">int</span> nr_frags = pinfo-&gt;nr_frags + i;</span><br><span class="line"></span><br><span class="line">offset -= headlen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr_frags &gt; MAX_SKB_FRAGS)</span><br><span class="line"><span class="keyword">return</span> -E2BIG;</span><br><span class="line"><span class="comment">//设置pinfo的frags的大小，可以看到就是加上skb的frags的大小</span></span><br><span class="line">pinfo-&gt;nr_frags = nr_frags;</span><br><span class="line">skbinfo-&gt;nr_frags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">frag = pinfo-&gt;frags + nr_frags;</span><br><span class="line">frag2 = skbinfo-&gt;frags + i;</span><br><span class="line"><span class="comment">//遍历赋值，其实就是地址赋值，这里就是将skb的frag加到pinfo的frgas后面。</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">*--frag = *--frag2;</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line"><span class="comment">//更改page_offet的值</span></span><br><span class="line">frag-&gt;page_offset += offset;</span><br><span class="line"><span class="comment">//修改size大小</span></span><br><span class="line">frag-&gt;size -= offset;</span><br><span class="line"><span class="comment">//更新skb的相关值</span></span><br><span class="line">skb-&gt;truesize -= skb-&gt;data_len;</span><br><span class="line">skb-&gt;len -= skb-&gt;data_len;</span><br><span class="line">skb-&gt;data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;free = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//最终完成</span></span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">skb_gro_len</span>(p) != pinfo-&gt;gso_size)</span><br><span class="line"><span class="keyword">return</span> -E2BIG;</span><br></pre></td></tr></table></figure><p>这里gro list中的要被合并的skb我们叫做skb_s.</p><p>接下来就是不支持支持Scatter-Gather I&#x2F;O(skb的头放在skb中)的处理。这里处理也比较简单，就是复制一个新的nskb，然后它的头和skb_s一样，然后将skb_s挂载到nskb的frag_list上，并且把新建的nskb挂在到gro list中，代替skb_s的位置，而当前的skb</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">headroom = <span class="built_in">skb_headroom</span>(p);</span><br><span class="line">nskb = <span class="built_in">alloc_skb</span>(headroom + <span class="built_in">skb_gro_offset</span>(p), GFP_ATOMIC);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">unlikely</span>(!nskb))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="comment">//复制头</span></span><br><span class="line">__copy_skb_header(nskb, p);</span><br><span class="line">nskb-&gt;mac_len = p-&gt;mac_len;</span><br><span class="line"></span><br><span class="line"><span class="built_in">skb_reserve</span>(nskb, headroom);</span><br><span class="line">__skb_put(nskb, <span class="built_in">skb_gro_offset</span>(p));</span><br><span class="line"><span class="comment">//设置各层的头</span></span><br><span class="line"><span class="built_in">skb_set_mac_header</span>(nskb, <span class="built_in">skb_mac_header</span>(p) - p-&gt;data);</span><br><span class="line"><span class="built_in">skb_set_network_header</span>(nskb, <span class="built_in">skb_network_offset</span>(p));</span><br><span class="line"><span class="built_in">skb_set_transport_header</span>(nskb, <span class="built_in">skb_transport_offset</span>(p));</span><br><span class="line"></span><br><span class="line">__skb_pull(p, <span class="built_in">skb_gro_offset</span>(p));</span><br><span class="line"><span class="comment">//复制数据</span></span><br><span class="line"><span class="built_in">memcpy</span>(<span class="built_in">skb_mac_header</span>(nskb), <span class="built_in">skb_mac_header</span>(p),</span><br><span class="line">       p-&gt;data - <span class="built_in">skb_mac_header</span>(p));</span><br><span class="line"><span class="comment">//对应的gro 域的赋值</span></span><br><span class="line">*<span class="built_in">NAPI_GRO_CB</span>(nskb) = *<span class="built_in">NAPI_GRO_CB</span>(p);</span><br><span class="line"><span class="comment">//可以看到frag_list被赋值</span></span><br><span class="line"><span class="built_in">skb_shinfo</span>(nskb)-&gt;frag_list = p;</span><br><span class="line"><span class="built_in">skb_shinfo</span>(nskb)-&gt;gso_size = pinfo-&gt;gso_size;</span><br><span class="line">pinfo-&gt;gso_size = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">skb_header_release</span>(p);</span><br><span class="line">nskb-&gt;prev = p;</span><br><span class="line"><span class="comment">//更新新的skb的数据段</span></span><br><span class="line">nskb-&gt;data_len += p-&gt;len;</span><br><span class="line">nskb-&gt;truesize += p-&gt;len;</span><br><span class="line">nskb-&gt;len += p-&gt;len;</span><br><span class="line"><span class="comment">//将新的skb插入到gro list中</span></span><br><span class="line">*head = nskb;</span><br><span class="line">nskb-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = nskb;</span><br><span class="line"></span><br><span class="line">merge:</span><br><span class="line"><span class="keyword">if</span> (offset &gt; headlen) &#123;</span><br><span class="line">skbinfo-&gt;frags[<span class="number">0</span>].page_offset += offset - headlen;</span><br><span class="line">skbinfo-&gt;frags[<span class="number">0</span>].size -= offset - headlen;</span><br><span class="line">offset = headlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__skb_pull(skb, offset);</span><br><span class="line"><span class="comment">//将skb插入新的skb的(或者老的skb，当frag list本身存在)fraglist</span></span><br><span class="line">p-&gt;prev-&gt;next = skb;</span><br><span class="line">p-&gt;prev = skb;</span><br><span class="line"><span class="built_in">skb_header_release</span>(skb);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PMU计数器</title>
      <link href="/2022/10/28/01%20OS/Linux/Perf/perf_event/"/>
      <url>/2022/10/28/01%20OS/Linux/Perf/perf_event/</url>
      
        <content type="html"><![CDATA[<p>task-clock：任务真正占用的处理器时间，单位为ms。CPUs utilized &#x3D; task-clock &#x2F; time elapsed，CPU的占用率。</p><p>context-switches：上下文的切换次数。</p><p>CPU-migrations：处理器迁移次数。Linux为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个CPU迁移到另一个CPU。</p><p>page-faults：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外TLB不命中，页面访问权限不匹配等情况也会触发缺页异常。</p><p>cycles：</p><p>stalled-cycles-frontend：略过。</p><p>stalled-cycles-backend：略过。</p><p>instructions：执行了多少条指令。IPC为平均每个cpu cycle执行了多少条指令。</p><p>branches：遇到的分支指令数。branch-misses是预测错误的分支指令数。</p><p>cpu-cycles：某段时间内的CPU cycle数 （硬件事件）。如果把被ls使用的cpu cycles看成是一个处理器的，那么它的主频为2.486GHz。可以用cycles &#x2F; task-clock算出。</p><p>cpu-clock：某段时间内的cpu时钟数；</p><p>CPU cycles事件和cpu-clock事件因比较常用，我们说一下它们的区别：<br>cpu-clock可以用来表示程序执行经过的真实时间，而无论CPU处于什么状态（Pn（n非0）或者是C状态）；<br>而CPU cycles则用来表示执行程序指令花费的时钟周期数，如果CPU处于Pn（n非0）或者是C状态，则cycles的产生速度会减慢。<br>也即，如果你想查看哪些代码消耗的真实时间多，则可以使用cpu-clock事件；而如果你想查看哪些代码消耗的时钟周期多，则可以使用CPU cycles事件。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程状态：S 和D状态</title>
      <link href="/2022/10/28/01%20OS/Linux/%E8%BF%9B%E7%A8%8B/status/"/>
      <url>/2022/10/28/01%20OS/Linux/%E8%BF%9B%E7%A8%8B/status/</url>
      
        <content type="html"><![CDATA[<h1 id="linux进程D状态-转"><a href="#linux进程D状态-转" class="headerlink" title="linux进程D状态_转"></a><a href="https://www.cnblogs.com/embedded-linux/p/7043569.html">linux进程D状态_转</a></h1><p><strong>Linux进程状态：S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。</strong></p><p>处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。</p><p>通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。</p><p><strong>Linux进程状态：D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。</strong></p><p>与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。<br>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。</p><p>而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。（参见《linux内核异步中断浅析》）<br>在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</p><p>linux系统中也存在容易捕捉的TASK_UNINTERRUPTIBLE状态。执行vfork系统调用后，父进程将进入TASK_UNINTERRUPTIBLE状态，直到子进程调用exit或exec（参见《神奇的vfork》）。<br>通过下面的代码就能得到处于TASK_UNINTERRUPTIBLE状态的进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include   </span><br><span class="line">void main() &#123;  </span><br><span class="line">if (!vfork()) sleep(100);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，然后ps一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kouu@kouu-one:~/test$ ps -ax | grep a\.out  </span><br><span class="line">4371 pts/0    D+     0:00 ./a.out  </span><br><span class="line">4372 pts/0    S+     0:00 ./a.out  </span><br><span class="line">4374 pts/1    S+     0:00 grep a.out</span><br></pre></td></tr></table></figure><p>然后我们可以试验一下TASK_UNINTERRUPTIBLE状态的威力。不管kill还是kill -9，这个TASK_UNINTERRUPTIBLE状态的父进程依然屹立不倒。</p><p><strong>进程为什么会被置于uninterruptible sleep状态呢？</strong>处于uninterruptiblesleep状态的进程通常是在等待IO，比如磁盘IO，网络IO，其他外设IO，如果进程正在等待的IO在较长的时间内都没有响应，那么就很会不幸地被ps看到了，同时也就意味着很有可能有IO出了问题，可能是外设本身出了故障，也可能是比如挂载的远程文件系统已经不可访问了（由down掉的NFS服务器引起的D状态）。</p><p>正是因为得不到IO的相应，进程才进入了uninterruptible sleep状态，所以要想使进程从uninterruptiblesleep状态恢复，就得使进程等待的IO恢复，比如如果是因为从远程挂载的NFS卷不可访问导致进程进入uninterruptiblesleep状态的，那么可以通过恢复该NFS卷的连接来使进程的IO请求得到满足。</p><p><strong>D状态，往往是由于 I&#x2F;O 资源得不到满足，而引发等待</strong>，在内核源码 fs&#x2F;proc&#x2F;array.c 里，其文字定义为“ “D (disk sleep)”, &#x2F;* 2 *&#x2F; ”（由此可知 D 原是Disk的打头字母），对应着 include&#x2F;linux&#x2F;sched.h 里的“ #define TASK_UNINTERRUPTIBLE 2 ”。举个例子，当 NFS 服务端关闭之时，若未事先 umount 相关目录，在 NFS 客户端执行 df 就会挂住整个登录会话，按 Ctrl+C 、Ctrl+Z 都无济于事。断开连接再登录，执行 ps axf 则看到刚才的 df 进程状态位已变成了 D ，kill -9 无法杀灭。正确的处理方式，是马上恢复 NFS 服务端，再度提供服务，刚才挂起的 df 进程发现了其苦苦等待的资源，便完成任务，自动消亡。若 NFS 服务端无法恢复服务，在 reboot 之前也应将 &#x2F;etc&#x2F;mtab 里的相关 NFS mount 项删除，以免 reboot 过程例行调用 netfs stop 时再次发生等待资源，导致系统重启过程挂起。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sar</title>
      <link href="/2022/10/27/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sar/"/>
      <url>/2022/10/27/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sar/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-sar命令详解：分析系统性能"><a href="#Linux-sar命令详解：分析系统性能" class="headerlink" title="Linux sar命令详解：分析系统性能"></a>Linux sar命令详解：分析系统性能</h1><p>sar 命令很强大，是分析系统性能的重要工具之一，通过该命令可以全面地获取系统的 CPU、运行队列、磁盘读写（I&#x2F;O）、分区（交换区）、内存、CPU 中断和网络等性能数据。</p><p>sar 命令的基本格式如下：</p><p>[root@localhost ~]# sar [options] [-o filename] interval [count]</p><p>此命令格式中，各个参数的含义如下：</p><ul><li>-o filename：其中，filename 为文件名，此选项表示将命令结果以二进制格式存放在文件中；</li><li>interval：表示采样间隔时间，该参数必须手动设置；</li><li>count：表示采样次数，是可选参数，其默认值为 1；</li><li>options：为命令行选项，由于 sar 命令提供的选项很多，这里不再一一介绍，仅列举出常用的一些选项及对应的功能，如表 1 所示。</li></ul><table><thead><tr><th>sar命令选项</th><th>功能</th></tr></thead><tbody><tr><td>-A</td><td>显示系统所有资源设备（CPU、内存、磁盘）的运行状况。</td></tr><tr><td>-u</td><td>显示系统所有 CPU 在采样时间内的负载状态。</td></tr><tr><td>-P</td><td>显示当前系统中指定 CPU 的使用情况。</td></tr><tr><td>-d</td><td>显示系统所有硬盘设备在采样时间内的使用状态。</td></tr><tr><td>-r</td><td>显示系统内存在采样时间内的使用情况。</td></tr><tr><td>-b</td><td>显示缓冲区在采样时间内的使用情况。</td></tr><tr><td>-v</td><td>显示 inode 节点、文件和其他内核表的统计信息。</td></tr><tr><td>-n</td><td>显示网络运行状态，此选项后可跟 DEV（显示网络接口信息）、EDEV（显示网络错误的统计数据）、SOCK（显示套接字信息）和 FULL（等同于使用 DEV、EDEV和SOCK）等，有关更多的选项，可通过执行 man sar 命令查看。</td></tr><tr><td>-q</td><td>显示运行列表中的进程数、进程大小、系统平均负载等。</td></tr><tr><td>-R</td><td>显示进程在采样时的活动情况。</td></tr><tr><td>-y</td><td>显示终端设备在采样时间的活动情况。</td></tr><tr><td>-w</td><td>显示系统交换活动在采样时间内的状态。</td></tr></tbody></table><blockquote><p>有关 sar 命令更多可用的选项及功能，可通过执行 man sar 命令查看。</p></blockquote><h2 id="1-CPU资源监控"><a href="#1-CPU资源监控" class="headerlink" title="1. CPU资源监控"></a>1. CPU资源监控</h2><p>例如，每10秒采样一次，连续采样3次，观察CPU 的使用情况，并将采样结果以二进制形式存入当前目录下的文件test中，需键入如下命令：</p><p>sar -u -o test 10 3</p><p>屏幕显示如下：</p><p>17:06:16 CPU %user %nice %system %iowait %steal %idle</p><p>17:06:26 all 0.00 0.00 0.20 0.00 0.00 99.80</p><p>17:06:36 all 0.00 0.00 0.20 0.00 0.00 99.80</p><p>17:06:46 all 0.00 0.00 0.10 0.00 0.00 99.90</p><p>Average: all 0.00 0.00 0.17 0.00 0.00 99.83</p><p>输出项说明：</p><p>CPU：all 表示统计信息为所有 CPU 的平均值。</p><p>%user：显示在用户级别(application)运行使用 CPU 总时间的百分比。</p><p>%nice：显示在用户级别，用于nice操作，所占用 CPU 总时间的百分比。</p><p>%system：在核心级别(kernel)运行所使用 CPU 总时间的百分比。</p><p>%iowait：显示用于等待<a href="https://link.zhihu.com/?target=http://lovesoo.org/tag/io">I&#x2F;O</a>操作占用 CPU 总时间的百分比。</p><p>%steal：管理程序(hypervisor)为另一个虚拟进程提供服务而等待虚拟 CPU 的百分比。</p><p>%idle：显示 CPU 空闲时间占用 CPU 总时间的百分比。</p><p>\1. 若 %iowait 的值过高，表示硬盘存在I&#x2F;O瓶颈</p><p>\2. 若 %idle 的值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量</p><p>\3. 若 %idle 的值持续低于1，则系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU 。</p><p>如果要查看二进制文件test中的内容，需键入如下sar命令：</p><p>sar -u -f test</p><h2 id="2-inode、文件和其他内核表监控"><a href="#2-inode、文件和其他内核表监控" class="headerlink" title="2. inode、文件和其他内核表监控"></a>2. inode、文件和其他内核表监控</h2><p>例如，每10秒采样一次，连续采样3次，观察核心表的状态，需键入如下命令：</p><p>sar -v 10 3</p><p>屏幕显示如下：</p><p>17:10:49 dentunusd file-nr inode-nr pty-nr</p><p>17:10:59 6301 5664 12037 4</p><p>17:11:09 6301 5664 12037 4</p><p>17:11:19 6301 5664 12037 4</p><p>Average: 6301 5664 12037 4</p><p>输出项说明：</p><p>dentunusd：目录高速缓存中未被使用的条目数量</p><p>file-nr：文件句柄（file handle）的使用数量</p><p>inode-nr：索引节点句柄（inode handle）的使用数量</p><p>pty-nr：使用的pty数量</p><h2 id="3-内存和交换空间监控"><a href="#3-内存和交换空间监控" class="headerlink" title="3. 内存和交换空间监控"></a>3. 内存和交换空间监控</h2><p>例如，每10秒采样一次，连续采样3次，监控内存分页：</p><p>sar -r 10 3</p><p>屏幕显示如下：</p><p>输出项说明：</p><p>kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</p><p>kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</p><p>%memused：这个值是kbmemused和内存总量(不包括swap)的一个百分比.</p><p>kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.</p><p>kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</p><p>%commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.</p><h2 id="4-内存分页监控"><a href="#4-内存分页监控" class="headerlink" title="4. 内存分页监控"></a>4. 内存分页监控</h2><p>例如，每10秒采样一次，连续采样3次，监控内存分页：</p><p>sar -B 10 3</p><p>屏幕显示如下：</p><p>输出项说明：</p><p>pgpgin&#x2F;s：表示每秒从<a href="https://link.zhihu.com/?target=http://lovesoo.org/tag/%E7%A3%81%E7%9B%98">磁盘</a>或SWAP置换到内存的字节数(KB)</p><p>pgpgout&#x2F;s：表示每秒从内存置换到<a href="https://link.zhihu.com/?target=http://lovesoo.org/tag/%E7%A3%81%E7%9B%98">磁盘</a>或SWAP的字节数(KB)</p><p>fault&#x2F;s：每秒钟系统产生的缺页数,即主缺页与次缺页之和(major + minor)</p><p>majflt&#x2F;s：每秒钟产生的主缺页数.</p><p>pgfree&#x2F;s：每秒被放入空闲队列中的页个数</p><p>pgscank&#x2F;s：每秒被kswapd扫描的页个数</p><p>pgscand&#x2F;s：每秒直接被扫描的页个数</p><p>pgsteal&#x2F;s：每秒钟从cache中被清除来满足内存需要的页个数</p><p>%vmeff：每秒清除的页(pgsteal)占总扫描页(pgscank+pgscand)的百分比</p><h2 id="5-I-x2F-O和传送速率监控"><a href="#5-I-x2F-O和传送速率监控" class="headerlink" title="5. I&#x2F;O和传送速率监控"></a>5. I&#x2F;O和传送速率监控</h2><p>例如，每10秒采样一次，连续采样3次，报告缓冲区的使用情况，需键入如下命令：</p><p>sar -b 10 3</p><p>屏幕显示如下：</p><p>18:51:05 tps rtps wtps bread&#x2F;s bwrtn&#x2F;s</p><p>18:51:15 0.00 0.00 0.00 0.00 0.00</p><p>18:51:25 1.92 0.00 1.92 0.00 22.65</p><p>18:51:35 0.00 0.00 0.00 0.00 0.00</p><p>Average: 0.64 0.00 0.64 0.00 7.59</p><p>输出项说明：</p><p>tps：每秒钟物理设备的 I&#x2F;O 传输总量</p><p>rtps：每秒钟从物理设备读入的数据总量</p><p>wtps：每秒钟向物理设备写入的数据总量</p><p>bread&#x2F;s：每秒钟从物理设备读入的数据量，单位为 块&#x2F;s</p><p>bwrtn&#x2F;s：每秒钟向物理设备写入的数据量，单位为 块&#x2F;s</p><h2 id="6-进程队列长度和平均负载状态监控"><a href="#6-进程队列长度和平均负载状态监控" class="headerlink" title="6. 进程队列长度和平均负载状态监控"></a>6. 进程队列长度和平均负载状态监控</h2><p>例如，每10秒采样一次，连续采样3次，监控进程队列长度和平均负载状态：</p><p>sar -q 10 3</p><p>屏幕显示如下：</p><p>19:25:50 runq-sz plist-sz ldavg-1 ldavg-5 ldavg-15</p><p>19:26:00 0 259 0.00 0.00 0.00</p><p>19:26:10 0 259 0.00 0.00 0.00</p><p>19:26:20 0 259 0.00 0.00 0.00</p><p>Average: 0 259 0.00 0.00 0.00</p><p>输出项说明：</p><p>runq-sz：运行队列的长度（等待运行的进程数）</p><p>plist-sz：进程列表中进程（processes）和线程（threads）的数量</p><p>ldavg-1：最后1分钟的系统平均负载（System load average）</p><p>ldavg-5：过去5分钟的系统平均负载</p><p>ldavg-15：过去15分钟的系统平均负载</p><h2 id="7-系统交换活动信息监控"><a href="#7-系统交换活动信息监控" class="headerlink" title="7. 系统交换活动信息监控"></a>7. 系统交换活动信息监控</h2><p>例如，每10秒采样一次，连续采样3次，监控系统交换活动信息：</p><p>sar - W 10 3</p><p>屏幕显示如下：</p><p>19:39:50 pswpin&#x2F;s pswpout&#x2F;s</p><p>19:40:00 0.00 0.00</p><p>19:40:10 0.00 0.00</p><p>19:40:20 0.00 0.00</p><p>Average: 0.00 0.00</p><p>输出项说明：</p><p>pswpin&#x2F;s：每秒系统换入的交换页面（swap page）数量</p><p>pswpout&#x2F;s：每秒系统换出的交换页面（swap page）数量</p><h2 id="8-设备使用情况监控"><a href="#8-设备使用情况监控" class="headerlink" title="8. 设备使用情况监控"></a>8. 设备使用情况监控</h2><p>例如，每10秒采样一次，连续采样3次，报告设备使用情况，需键入如下命令：</p><p># sar -d 10 3 –p</p><p>屏幕显示如下：</p><p>17:45:54 DEV tps rd_sec&#x2F;s wr_sec&#x2F;s avgrq-sz avgqu-sz await svctm %util</p><p>17:46:04 scd0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00</p><p>17:46:04 sda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00</p><p>17:46:04 vg_livedvd-lv_root 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00</p><p>17:46:04 vg_livedvd-lv_swap 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00</p><p>其中：</p><p>参数-p可以打印出sda,hdc等磁盘设备名称,如果不用参数-p,设备节点则有可能是dev8-0,dev22-0</p><p>tps:每秒从物理磁盘I&#x2F;O的次数.多个逻辑请求会被合并为一个I&#x2F;O磁盘请求,一次传输的大小是不确定的.</p><p>rd_sec&#x2F;s:每秒读扇区的次数.</p><p>wr_sec&#x2F;s:每秒写扇区的次数.</p><p>avgrq-sz:平均每次设备I&#x2F;O操作的数据大小(扇区).</p><p>avgqu-sz:磁盘请求队列的平均长度.</p><p>await:从请求磁盘操作到系统完成处理,每次请求的平均消耗时间,包括请求队列等待时间,单位是毫秒(1秒&#x3D;1000毫秒).</p><p>svctm:系统处理每次请求的平均时间,不包括在请求队列中消耗的时间.</p><p>%util:I&#x2F;O请求占CPU的百分比,比率越大,说明越饱和.</p><p>\1. avgqu-sz 的值较低时，设备的利用率较高。</p><p>\2. 当%util的值接近 1% 时，表示设备带宽已经占满。</p><h2 id="要判断系统瓶颈问题，有时需几个-sar-命令选项结合起来"><a href="#要判断系统瓶颈问题，有时需几个-sar-命令选项结合起来" class="headerlink" title="要判断系统瓶颈问题，有时需几个 sar 命令选项结合起来"></a>要判断系统瓶颈问题，有时需几个 sar 命令选项结合起来</h2><p>怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看</p><p>怀疑内存存在瓶颈，可用 sar -B、sar -r 和 sar -W 等来查看</p><p>怀疑I&#x2F;O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网卡多队列配置和中断绑定</title>
      <link href="/2022/10/27/01%20OS/Linux/network/irq/"/>
      <url>/2022/10/27/01%20OS/Linux/network/irq/</url>
      
        <content type="html"><![CDATA[<h1 id="网卡多队列配置"><a href="#网卡多队列配置" class="headerlink" title="网卡多队列配置"></a>网卡多队列配置</h1><h2 id="处理步骤"><a href="#处理步骤" class="headerlink" title="处理步骤"></a>处理步骤</h2><p>以下步骤云服务器默认主网卡为 <code>eth0</code>，网卡队列个数为2。</p><ol><li><p>执行以下命令，查看当前网卡队列个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -l eth0</span><br></pre></td></tr></table></figure><p>返回如下结果，表示当前队列个数设置小于最大网卡队列个数，设置不合理，需进行修复。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Channel parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:             0</span><br><span class="line">TX:             0</span><br><span class="line">Other:          0</span><br><span class="line">Combined:       2         ### 服务器支持的最大网卡队列个数</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:             0</span><br><span class="line">TX:             0</span><br><span class="line">Other:          0</span><br><span class="line">Combined:       1        ###当前设置的网卡队列个数</span><br></pre></td></tr></table></figure></li><li><p>执行以下命令，设置当前网卡队列个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -L eth0  combined 2</span><br></pre></td></tr></table></figure><p>命令中队列数设置为2，可根据实际情况调整，设置值为服务器支持的最大网卡队列个数。</p></li><li><p>执行以下命令，检查当前网卡队列个数配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -l eth</span><br></pre></td></tr></table></figure><p>服务器支持的最大网卡队列个数与当前设置的网卡队列个数相等，即为配置成功。</p></li></ol><h2 id="Linux-多核下绑定硬件中断到不同-CPU"><a href="#Linux-多核下绑定硬件中断到不同-CPU" class="headerlink" title="Linux 多核下绑定硬件中断到不同 CPU"></a>Linux 多核下绑定硬件中断到不同 CPU</h2><p>硬件中断发生频繁，是件很消耗 CPU 资源的事情，在多核 CPU 条件下如果有办法把大量硬件中断分配给不同的 CPU (core) 处理显然能很好的平衡性能。现在的服务器上动不动就是多 CPU 多核、多网卡、多硬盘，如果能让网卡中断独占1个 CPU (core)、磁盘 IO 中断独占1个 CPU 的话将会大大减轻单一 CPU 的负担、提高整体处理效率。VPSee 前天收到一位网友的邮件提到了 SMP IRQ Affinity，引发了今天的话题：D，以下操作在 SUN FIre X2100 M2 服务器＋ 64位版本 CentOS 5.5 + Linux 2.6.18-194.3.1.el5 上执行。</p><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><p>中文教材上对 “中断” 的定义太生硬了，简单的说就是，每个硬件设备（如：硬盘、网卡等）都需要和 CPU 有某种形式的通信以便 CPU 及时知道发生了什么事情，这样 CPU 可能就会放下手中的事情去处理应急事件，硬件设备主动打扰 CPU 的现象就可称为硬件中断，就像你正在工作的时候受到 QQ 干扰一样，一次 QQ 摇头就可以被称为中断。</p><p>中断是一种比较好的 CPU 和硬件沟通的方式，还有一种方式叫做轮询（polling），就是让 CPU 定时对硬件状态进行查询然后做相应处理，就好像你每隔5分钟去检查一下 QQ 看看有没有人找你一样，这种方式是不是很浪费你（CPU）的时间？所以中断是硬件主动的方式，比轮询（CPU 主动）更有效一些。</p><p>好了，这里又有了一个问题，每个硬件设备都中断，那么如何区分不同硬件呢？不同设备同时中断如何知道哪个中断是来自硬盘、哪个来自网卡呢？这个很容易，不是每个 QQ 号码都不相同吗？同样的，系统上的每个硬件设备都会被分配一个 IRQ 号，通过这个唯一的 IRQ 号就能区别张三和李四了。</p><p>在计算机里，中断是一种电信号，由硬件产生，并直接送到中断控制器（如 8259A）上，然后再由中断控制器向 CPU 发送信号，CPU 检测到该信号后，就中断当前的工作转而去处理中断。然后，处理器会通知操作系统已经产生中断，这样操作系统就会对这个中断进行适当的处理。现在来看一下中断控制器，常见的中断控制器有两种：可编程中断控制器 8259A 和高级可编程中断控制器（APIC），中断控制器应该在大学的硬件接口和计算机体系结构的相关课程中都学过。传统的 8259A 只适合单 CPU 的情况，现在都是多 CPU 多核的 SMP 体系，所以为了充分利用 SMP 体系结构、把中断传递给系统上的每个 CPU 以便更好实现并行和提高性能，Intel 引入了高级可编程中断控制器（APIC）。</p><p>光有高级可编程中断控制器的硬件支持还不够，Linux 内核还必须能利用到这些硬件特质，所以只有 kernel 2.4 以后的版本才支持把不同的硬件中断请求（IRQs）分配到特定的 CPU 上，这个绑定技术被称为 SMP IRQ Affinity. 更多介绍请参看 Linux 内核源代码自带的文档：linux-2.6.31.8&#x2F;Documentation&#x2F;IRQ-affinity.txt</p><h2 id="如何绑定中断处理CPU"><a href="#如何绑定中断处理CPU" class="headerlink" title="如何绑定中断处理CPU"></a>如何绑定中断处理CPU</h2><p>先看看系统上的中断是怎么分配在 CPU 上的，很显然 CPU0 上处理的中断多一些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/interrupts   </span><br><span class="line">           CPU0       CPU1         </span><br><span class="line">  0:  918926335          0    IO-APIC-edge  timer  </span><br><span class="line">  1:          2          0    IO-APIC-edge  i8042  </span><br><span class="line">  8:          0          0    IO-APIC-edge  rtc  </span><br><span class="line">  9:          0          0   IO-APIC-level  acpi  </span><br><span class="line"> 12:          4          0    IO-APIC-edge  i8042  </span><br><span class="line"> 14:    8248017          0    IO-APIC-edge  ide0  </span><br><span class="line"> 50:        194          0   IO-APIC-level  ohci_hcd:usb2  </span><br><span class="line"> 58:      31673          0   IO-APIC-level  sata_nv  </span><br><span class="line"> 90:    1070374          0         PCI-MSI  eth0  </span><br><span class="line">233:         10          0   IO-APIC-level  ehci_hcd:usb1  </span><br><span class="line">NMI:       5077       2032   </span><br><span class="line">LOC:  918809969  918809894   </span><br><span class="line">ERR:          0  </span><br><span class="line">MIS:          0  </span><br></pre></td></tr></table></figure><p>即能看到中断号，也能看到每个CPU的中断处理次数。</p><p>为了不让 CPU0 很累怎么把部分中断转移到 CPU1 上呢？或者说如何把 eth0 网卡的中断转到 CPU1 上呢？先查看一下 IRQ 90 中断的 smp affinity，看看当前中断是怎么分配在不同 CPU 上的（ffffffff 意味着分配在所有可用 CPU 上）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/irq/90/smp_affinity   </span><br><span class="line">7fffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff  </span><br></pre></td></tr></table></figure><p>在进一步动手之前我们需要先停掉 IRQ 自动调节的服务进程，这样才能手动绑定 IRQ 到不同 CPU，否则自己手动绑定做的更改将会被自动调节进程给覆盖掉。如果想修改 IRQ 90 的中断处理，绑定到第2个 CPU（CPU1）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/irqbalance stop  </span><br><span class="line"></span><br><span class="line"># echo &quot;2&quot; &gt; /proc/irq/90/smp_affinity  </span><br></pre></td></tr></table></figure><p>（上面的 echo “2” 是怎么来的？为什么是 ”2“？请参考本文末尾：计算 SMP IRQ Affinity）过段时间在看 &#x2F;proc&#x2F;interrupts，是不是 90:eth0 在 CPU1 上的中断增加了（145）、在 CPU0 上的中断没变？不断打印 &#x2F;proc&#x2F;interrupts 就会发现 eth0 在 CPU0 上的中断数始终保持不变，而在 CPU1 上的中断数是持续增加的，这正是我们想要的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/interrupts   </span><br><span class="line">           CPU0       CPU1         </span><br><span class="line">  0:  922506515          0    IO-APIC-edge  timer  </span><br><span class="line">  1:          2          0    IO-APIC-edge  i8042  </span><br><span class="line">  8:          0          0    IO-APIC-edge  rtc  </span><br><span class="line">  9:          0          0   IO-APIC-level  acpi  </span><br><span class="line"> 12:          4          0    IO-APIC-edge  i8042  </span><br><span class="line"> 14:    8280147          0    IO-APIC-edge  ide0  </span><br><span class="line"> 50:        194          0   IO-APIC-level  ohci_hcd:usb2  </span><br><span class="line"> 58:      31907          0   IO-APIC-level  sata_nv  </span><br><span class="line"> 90:    1073399        145         PCI-MSI  eth0  </span><br><span class="line">233:         10          0   IO-APIC-level  ehci_hcd:usb1  </span><br><span class="line">NMI:       5093       2043   </span><br><span class="line">LOC:  922389696  922389621   </span><br><span class="line">ERR:          0  </span><br><span class="line">MIS:          0  </span><br></pre></td></tr></table></figure><h2 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h2><p>在网络非常 heavy 的情况下，对于文件服务器、高流量 Web 服务器这样的应用来说，把不同的网卡 IRQ 均衡绑定到不同的 CPU 上将会减轻某个 CPU 的负担，提高多个 CPU 整体处理中断的能力；对于数据库服务器这样的应用来说，把磁盘控制器绑到一个 CPU、把网卡绑定到另一个 CPU 将会提高数据库的响应时间、优化性能。合理的根据自己的生产环境和应用的特点来平衡 IRQ 中断有助于提高系统的整体吞吐能力和性能。</p><p>VPSee 经常收到网友来信问到如何优化 Linux、优化 VPS、这个问题不太好回答，要记住的是性能优化是一个过程而不是结果，不是看了些文档改了改参数就叫优化了，后面还需要大量的测试、监测以及持续的观察和改进。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>把irqbalance 停掉會不會有其他問題出玩?</p><p>不会有什么严重问题，但是没有 irqbalance 也没有合理的做手动 irq 绑定的话会有性能问题。手动 irq 只推荐给很 heavy、很特殊的情况，比如带多网卡多硬盘的网络存储服务器，一般机器一般应用还是用 irqbalance 省心。</p><p>事实上以前 Linux 是不推荐使用 irqbalance 的，原因在于当时的 irqbalance 实现很简单，没有什么优化作用，后来的 irqbalance (cache topology + power aware) 有了很大改进，在多核上表现良好。</p><h2 id="计算-SMP-IRQ-Affinity"><a href="#计算-SMP-IRQ-Affinity" class="headerlink" title="计算 SMP IRQ Affinity"></a>计算 SMP IRQ Affinity</h2><p>“echo 2 &gt; &#x2F;proc&#x2F;irq&#x2F;90&#x2F;smp_affinity” 中的 ”2“ 是怎么来的，这其实是个二进制数字，代表 00000010，00000001 代表 CPU0 的话，00000010 就代表 CPU1， “echo 2 &gt; &#x2F;proc&#x2F;irq&#x2F;90&#x2F;smp_affinity” 的意思就是说把 90 中断绑定到 00000010（CPU1）上。所以各个 CPU 用二进制和十六进制表示就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">           Binary       Hex   </span><br><span class="line">CPU 0    00000001         1   </span><br><span class="line">CPU 1    00000010         2  </span><br><span class="line">CPU 2    00000100         4  </span><br><span class="line">CPU 3    00001000         8  </span><br></pre></td></tr></table></figure><p>如果我想把 IRQ 绑定到 CPU2 上就是 00000100＝4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;4&quot; &gt; /proc/irq/90/smp_affinity  </span><br></pre></td></tr></table></figure><p>如果我想把 IRQ 同时平衡到 CPU0 和 CPU2 上就是 00000001＋00000100＝00000101＝5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;5&quot; &gt; /proc/irq/90/smp_affinity  </span><br></pre></td></tr></table></figure><p>需要注意的是，在手动绑定 IRQ 到 CPU 之前需要先停掉 irqbalance 这个服务，irqbalance 是个服务进程、是用来自动绑定和平衡 IRQ 的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /etc/init.d/irqbalance stop  </span><br></pre></td></tr></table></figure><p>还有一个限制就是，IO-APIC 有两种工作模式：</p><p>logic 和 physical，</p><p>在 logic 模式下 IO-APIC 可以同时分布同一种 IO 中断到8颗 CPU (core) 上（受到 bitmask 寄存器的限制，因为 bitmask 只有8位长。）；</p><p>在 physical 模式下不能同时分布同一中断到不同 CPU 上，比如，不能让 eth0 中断同时由 CPU0 和 CPU1 处理，这个时候只能定位 eth0 到 CPU0、eth1 到 CPU1，也就是说 eth0 中断不能像 logic 模式那样可以同时由多个 CPU 处理。</p><p>下面给大家提供一个计算小脚本值提供中断在单CPU上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash  </span><br><span class="line">#Author Jiaion MSN:Jiaion@msn.com  </span><br><span class="line">[ $# -ne 1 ] &amp;&amp; echo ‘$1 is Cpu core number’ &amp;&amp; exit 1  </span><br><span class="line"></span><br><span class="line">CCN=$1  </span><br><span class="line">echo “Print eth0 affinity”  </span><br><span class="line">for((i=0; i&lt;$&#123;CCN&#125;; i++))  </span><br><span class="line">do  </span><br><span class="line">echo ==============================  </span><br><span class="line">echo &quot;Cpu Core $i is affinity&quot;  </span><br><span class="line">((affinity=(1&lt;&lt;i)))  </span><br><span class="line">echo &quot;obase=16;$&#123;affinity&#125;&quot; | bc  </span><br><span class="line">echo ==============================  </span><br><span class="line">done  </span><br></pre></td></tr></table></figure><h3 id="1、关于多队列网卡"><a href="#1、关于多队列网卡" class="headerlink" title="1、关于多队列网卡"></a>1、关于多队列网卡</h3><p>通过lspci方式查看网卡信息，如果有MSI-X， Enable+ 并且Count &gt; 1，则该网卡是多队列网卡，多队列网卡内部会有多个 Ring Buffer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@localhost ~]# lspci -vvv | grep -A50 &quot;Ethernet controller&quot; | grep -E &quot;Capabilities|Ethernet controller&quot;</span><br><span class="line">01:00.0 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)</span><br><span class="line">Capabilities: [40] Power Management version 3</span><br><span class="line">Capabilities: [50] MSI: Enable- Count=1/1 Maskable+ 64bit+</span><br><span class="line">Capabilities: [70] MSI-X: Enable+ Count=10 Masked-</span><br><span class="line">Capabilities: [a0] Express (v2) Endpoint, MSI 00</span><br><span class="line">Capabilities: [e0] Vital Product Data</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从以上信息可见，我们的这张网卡是支持多队列的。</p><h3 id="2、网卡支持最大队列数及当前使用队列"><a href="#2、网卡支持最大队列数及当前使用队列" class="headerlink" title="2、网卡支持最大队列数及当前使用队列"></a>2、网卡支持最大队列数及当前使用队列</h3><p>我们可以通过ethtool命令查看网卡支持的最大队列数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ethtool -l eth0</span><br><span class="line">Channel parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:0</span><br><span class="line">TX:0</span><br><span class="line">Other:1</span><br><span class="line">Combined:63</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:0</span><br><span class="line">TX:0</span><br><span class="line">Other:1</span><br><span class="line">Combined:40</span><br></pre></td></tr></table></figure><p>由上可见，该网卡最多支持63个队列，当前使用了40个队列。为什么不开启63个队列呢，因为机器的CPU数没那么多，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/cpuinfo | grep processor | wc -l</span><br><span class="line">40</span><br></pre></td></tr></table></figure><p>我们开启多队列的初衷就是为了利用多核。队列数和CPU相等，正好可以每个CPU处理一个队列，这样效率比较高。</p><h3 id="3、修改网卡队列数"><a href="#3、修改网卡队列数" class="headerlink" title="3、修改网卡队列数"></a>3、修改网卡队列数</h3><p>有时候网卡支持多队列却没有开启，那么就要手动设置网卡队列数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -L eth0 combined 8</span><br></pre></td></tr></table></figure><p>其中combined指的是网卡收发队列共用的情况，有些网卡可单独设置收发队列，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ethtool -L eth0 rx 8</span><br><span class="line">ethtool -L eth0 tx 8</span><br></pre></td></tr></table></figure><p>设置后可以在&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;queues&#x2F;目录下看到对应的队列，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /sys/class/net/eth0/queues/</span><br><span class="line">[root@localhost queues]# ls</span><br><span class="line">rx-0  rx-2  rx-4  rx-6  tx-0  tx-2  tx-4  tx-6</span><br><span class="line">rx-1  rx-3  rx-5  rx-7  tx-1  tx-3  tx-5  tx-7</span><br></pre></td></tr></table></figure><h3 id="4、多队列网卡绑核"><a href="#4、多队列网卡绑核" class="headerlink" title="4、多队列网卡绑核"></a>4、多队列网卡绑核</h3><p>为了保证CPU均衡，也即是网卡中断能分配到各个CPU，我们通常会将网卡中断绑核，具体操作见——网卡中断均衡设置</p><h3 id="5、单队列网卡"><a href="#5、单队列网卡" class="headerlink" title="5、单队列网卡"></a>5、单队列网卡</h3><p>上面说的都是多队列网卡，那单队列的怎么搞呢，不能厚此薄彼吧。这时候就出现RPS和RFS了。简单来说就是在软件层面模拟多队列的情况，从而达到CPU均衡。</p><p>RPS（Receive Packet Steering）把软中断的负载均衡到各个cpu，是在单个CPU将数据从Ring Buffer取出来之后开始工作，网卡驱动通过四元组（SIP，SPORT，DIP，DPORT）生成一个hash值，然后根据这个hash值分配到对应的CPU上处理，从而发挥多核的能力。</p><p>但是还有个问题，由于RPS只是把数据包均衡到不同的cpu，但是收包的应用程序和软中断处理不一定是在同一个CPU，这样对于cpu cache的影响会很大。因此就出现RFS（Receive flow steering），它确保应用程序和软中断处理的cpu是同一个，从而能充分利用cpu的cache，这两个补丁往往都是一起设置，以达到最好的优化效果。</p><h3 id="6、设置RPS"><a href="#6、设置RPS" class="headerlink" title="6、设置RPS"></a>6、设置RPS</h3><p>首先内核要开启CONFIG_RPS编译选项，然后设置需要将中断分配到哪些CPU,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_cpus</span><br></pre></td></tr></table></figure><p>比如，要将eth0上0号收包软中断均匀分配到64个CPU上(假设机器上有这么多CPU)，那么可以如下操作，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ffffffff,ffffffff&quot; &gt; /sys/class/net/eth0/queues/rx-0/rps_cpus</span><br></pre></td></tr></table></figure><p>和多队列中断绑定规则类似，每个CPU用1位表示，因此1,2,4,8分别对应0-3号CPU，分配到这些CPU，相加就是15，即f。</p><p>如果只想分配到前32个CPU，则可以如下操作，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;00000000,ffffffff&quot; &gt; /sys/class/net/eth0/queues/rx-0/rps_cpus</span><br></pre></td></tr></table></figure><h3 id="7、设置RFS"><a href="#7、设置RFS" class="headerlink" title="7、设置RFS"></a>7、设置RFS</h3><p>上面我们说过RPS和RFS一般要配合使用，效果才最优，因此RFS同样需要开启CONFIG_RPS编译选项，同时设置每个队列的数据流表总数才能真正生效。</p><p>这里我们了解一下RFS的细节：</p><p>RFS的实现需要依赖两个表——全局socket流表(rps_sock_flow_table)和设备流表(rps_dev_flow_table)。全局socket流表记录的是每个流由上面RPS计算通过hash分配的CPU号，也就是期望的CPU号；设备流表存在于每个网络设备的每个接收队列，表中记录的是每个未完成流使用的CPU号，也就是当前流使用的CPU号。具体使用哪个CPU简单来说有以下规则，</p><p>如果两个表中记录的对应流使用的是同一个CPU号，就使用这个CPU<br>如果当前流使用的CPU未设置或者CPU处于离线状态，那就使用期望CPU表中的CPU号，也就是RPS计算而得的CPU号<br>如果两个表中对应流记录的CPU核不是同一个：<br>a)如果同一流的前一段数据包未处理完，为了避免乱序，不更换CPU，继续使用当前流使用的CPU号<br>b)如果同一流的前一段数据包已经处理完，那就可以使用期望CPU表中的CPU号<br>因此我们需要设置这两个表中记录的entry，对于全局socket流表(rps_sock_flow_table)，该配置接口是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/net/core/rps_sock_flow_entries</span><br></pre></td></tr></table></figure><p>而设备流表(rps_dev_flow_table)则通过以下接口设置，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_flow_cnt</span><br></pre></td></tr></table></figure><p>两者的关系如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rps_sock_flow_entries = rps_flow_cnt * N</span><br></pre></td></tr></table></figure><p>其中，N就是队列数量。因此，对于单队列网卡，两个值是一样的。</p><h3 id="8、XPS-Transmit-Packet-Steering"><a href="#8、XPS-Transmit-Packet-Steering" class="headerlink" title="8、XPS(Transmit Packet Steering)"></a>8、XPS(Transmit Packet Steering)</h3><p>上面说的都是关于接收队列，那对于发送队列呢，这就需要用到XPS了。</p><p>XPS通过创建CPU到网卡发送队列的对应关系，来保证处理发送软中断请求的CPU和向外发送数据包的CPU是同一个CPU，用来保证发送数据包时候的局部性。</p><p>对于发送队列到CPU的映射有两种选择：</p><p>1、使用CPU映射<br>这种方式是通过指定发送队列在某几个CPU上处理，通过减小分发的CPU范围来减少锁开销以及cache miss。最常见的就是1对1，和上面说到的接收软中断绑核类似，通过以下接口设置，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/net/&lt;dev&gt;/queues/tx-&lt;n&gt;/xps_cpus</span><br></pre></td></tr></table></figure><p>同样是bitmaps方式。</p><p>2、接收队列映射方式<br>这种方式基于接收队列的映射来选择CPU，也就是说让接收队列和发送队列在同一个CPU，或指定范围的几个CPU来处理。这种方式对于多线程一直收发包的系统效果比较明显，收发包队列处理在同一个CPU，不仅减少了对其他CPU的打断，同时提高应用处理效率，收完包后直接在同个CPU继续发包，从而减小CPU消耗，同时减小包的时延。</p><p>这种方式映射，可通过一下接口设置(不是所有网卡都支持)，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/net/&lt;dev&gt;/queues/tx-&lt;n&gt;/xps_rxqs</span><br></pre></td></tr></table></figure><p>另外，XPS对于单发送队列网卡没有效果，这个可想而知。</p><p>参考资料：<br>1、<a href="https://www.kernel.org/doc/Documentation/networking/scaling.txt">https://www.kernel.org/doc/Documentation/networking/scaling.txt</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell字符串截取</title>
      <link href="/2022/10/27/01%20OS/Linux/Shell/stringcut/"/>
      <url>/2022/10/27/01%20OS/Linux/Shell/stringcut/</url>
      
        <content type="html"><![CDATA[<p>Shell 截取字符串通常有两种方式：从指定位置开始截取和从指定字符（子字符串）开始截取。</p><h2 id="从指定位置开始截取"><a href="#从指定位置开始截取" class="headerlink" title="从指定位置开始截取"></a>从指定位置开始截取</h2><p>这种方式需要两个参数：除了指定起始位置，还需要截取长度，才能最终确定要截取的字符串。</p><p>既然需要指定起始位置，那么就涉及到计数方向的问题，到底是从字符串左边开始计数，还是从字符串右边开始计数。答案是 Shell 同时支持两种计数方式。</p><h4 id="1-从字符串左边开始计数"><a href="#1-从字符串左边开始计数" class="headerlink" title="1) 从字符串左边开始计数"></a>1) 从字符串左边开始计数</h4><p>如果想从字符串的左边开始计数，那么截取字符串的具体格式如下：</p><p>${string: start :length}</p><p>其中，string 是要截取的字符串，start 是起始位置（从左边开始，从 0 开始计数），length 是要截取的长度（省略的话表示直到字符串的末尾）。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&quot;c.biancheng.net&quot;echo $&#123;url: 2: 9&#125;</span><br></pre></td></tr></table></figure><p>结果为<code>biancheng</code>。</p><p>再如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&quot;c.biancheng.net&quot;echo $&#123;url: 2&#125;  #省略 length，截取到字符串末尾</span><br></pre></td></tr></table></figure><p>结果为<code>biancheng.net</code>。</p><h4 id="2-从右边开始计数"><a href="#2-从右边开始计数" class="headerlink" title="2) 从右边开始计数"></a>2) 从右边开始计数</h4><p>如果想从字符串的右边开始计数，那么截取字符串的具体格式如下：</p><p>${string: 0-start :length}</p><p>同第 1) 种格式相比，第 2) 种格式仅仅多了<code>0-</code>，这是固定的写法，专门用来表示从字符串右边开始计数。</p><p>这里需要强调两点：</p><ul><li>从左边开始计数时，起始数字是 0（这符合程序员思维）；从右边开始计数时，起始数字是 1（这符合常人思维）。计数方向不同，起始数字也不同。</li><li>不管从哪边开始计数，截取方向都是从左到右。</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&quot;c.biancheng.net&quot;echo $&#123;url: 0-13: 9&#125;</span><br></pre></td></tr></table></figure><p>结果为<code>biancheng</code>。从右边数，<code>b</code>是第 13 个字符。</p><p>再如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&quot;c.biancheng.net&quot;echo $&#123;url: 0-13&#125;  #省略 length，直接截取到字符串末尾</span><br></pre></td></tr></table></figure><p>结果为<code>biancheng.net</code>。</p><h2 id="从指定字符（子字符串）开始截取"><a href="#从指定字符（子字符串）开始截取" class="headerlink" title="从指定字符（子字符串）开始截取"></a>从指定字符（子字符串）开始截取</h2><p>这种截取方式无法指定字符串长度，只能从指定字符（子字符串）截取到字符串末尾。Shell 可以截取指定字符（子字符串）右边的所有字符，也可以截取左边的所有字符。</p><h4 id="1-使用-号截取右边字符"><a href="#1-使用-号截取右边字符" class="headerlink" title="1) 使用 # 号截取右边字符"></a>1) 使用 # 号截取右边字符</h4><p>使用<code>#</code>号可以截取指定字符（或者子字符串）右边的所有字符，具体格式如下：</p><p>${string#*chars}</p><p>其中，string 表示要截取的字符，chars 是指定的字符（或者子字符串），<code>*</code>是通配符的一种，表示任意长度的字符串。<code>*chars</code>连起来使用的意思是：忽略左边的所有字符，直到遇见 chars（chars 不会被截取）。</p><p>请看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&quot;http://c.biancheng.net/index.html&quot;echo $&#123;url#*:&#125;</span><br></pre></td></tr></table></figure><p>结果为<code>//c.biancheng.net/index.html</code>。</p><p>以下写法也可以得到同样的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;url#*p:&#125;echo $&#123;url#*ttp:&#125;</span><br></pre></td></tr></table></figure><p>如果不需要忽略 chars 左边的字符，那么也可以不写<code>*</code>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&quot;http://c.biancheng.net/index.html&quot;echo $&#123;url#http://&#125;</span><br></pre></td></tr></table></figure><p>结果为<code>c.biancheng.net/index.html</code>。</p><p>注意，以上写法遇到第一个匹配的字符（子字符串）就结束了。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&quot;http://c.biancheng.net/index.html&quot;echo $&#123;url#*/&#125;</span><br></pre></td></tr></table></figure><p>结果为<code>/c.biancheng.net/index.html</code>。url 字符串中有三个<code>/</code>，输出结果表明，Shell 遇到第一个<code>/</code>就匹配结束了。</p><p>如果希望直到最后一个指定字符（子字符串）再匹配结束，那么可以使用<code>##</code>，具体格式为：</p><p>${string##*chars}</p><p>请看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bashurl=&quot;http://c.biancheng.net/index.html&quot;echo $&#123;url#*/&#125;    #结果为 /c.biancheng.net/index.htmlecho $&#123;url##*/&#125;   #结果为 index.htmlstr=&quot;---aa+++aa@@@&quot;echo $&#123;str#*aa&#125;   #结果为 +++aa@@@echo $&#123;str##*aa&#125;  #结果为 @@@</span><br></pre></td></tr></table></figure><h4 id="2-使用-截取左边字符"><a href="#2-使用-截取左边字符" class="headerlink" title="2) 使用 % 截取左边字符"></a>2) 使用 % 截取左边字符</h4><p>使用<code>%</code>号可以截取指定字符（或者子字符串）左边的所有字符，具体格式如下：</p><p>${string%chars*}</p><p>请注意<code>*</code>的位置，因为要截取 chars 左边的字符，而忽略 chars 右边的字符，所以<code>*</code>应该位于 chars 的右侧。其他方面<code>%</code>和<code>#</code>的用法相同，这里不再赘述，仅举例说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bashurl=&quot;http://c.biancheng.net/index.html&quot;echo $&#123;url%/*&#125;  #结果为 http://c.biancheng.netecho $&#123;url%%/*&#125;  #结果为 http:str=&quot;---aa+++aa@@@&quot;echo $&#123;str%aa*&#125;  #结果为 ---aa+++echo $&#123;str%%aa*&#125;  #结果为 ---</span><br></pre></td></tr></table></figure><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>最后，我们对以上 8 种格式做一个汇总，请看下表：</p><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>${string: start :length}</td><td>从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。</td></tr><tr><td>${string: start}</td><td>从 string 字符串的左边第 start 个字符开始截取，直到最后。</td></tr><tr><td>${string: 0-start :length}</td><td>从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。</td></tr><tr><td>${string: 0-start}</td><td>从 string 字符串的右边第 start 个字符开始截取，直到最后。</td></tr><tr><td>${string#*chars}</td><td>从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。</td></tr><tr><td>${string##*chars}</td><td>从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。</td></tr><tr><td>${string%*chars}</td><td>从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。</td></tr><tr><td>${string%%*chars}</td><td>从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下编译、链接和装载</title>
      <link href="/2022/10/27/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/compile_Link/"/>
      <url>/2022/10/27/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/compile_Link/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux下编译、链接和装载"><a href="#Linux下编译、链接和装载" class="headerlink" title="Linux下编译、链接和装载"></a>Linux下编译、链接和装载</h2><p>编译过程在Linux下使用GCC将源码编译成可执行文件的过程可以分解为4个步骤，分别是预处理（Prepressing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。一个简单的hello word程序编译过程如下：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_1.jpg" alt="img">1. 预处理首先源代码文件（.c&#x2F;.cpp）和相关头文件（.h&#x2F;.hpp）被预处理器cpp预编译成.i文件（C++为.ii）。预处理命令为：gcc –E hello.c –o hello.i预编译过程主要处理那些源代码中以#开始的预编译指令，主要处理规则如下：u 将所有的#define删除，并且展开所有的宏定义；u 处理所有条件编译指令，如#if，#ifdef等；u 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。该过程递归进行，及被包含的文件可能还包含其他文件。u 删除所有的注释&#x2F;&#x2F;和 &#x2F;**&#x2F;；u 添加行号和文件标识，如#2 “hello.c” 2,以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号信息；u 保留所有的#pragma编译器指令，因为编译器须要使用它们。2. 编译编译过程就是把预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件（.s）。编译的命令为：gcc –S hello.i –o hello.s或者从源文件直接输出汇编代码文件：gcc –S hello.c –o hello.s现在版本的GCC把预编译和编译两个步骤合并成一个步骤，由程序cc1来完成（C++为cc1plus）。3. 汇编汇编就是将汇编代码转变成机器可以执行的命令，生成目标文件（.o），汇编器as根据汇编指令和机器指令的对照表一一翻译即可完成。汇编的命令为：gcc –c hello.s –o hello.o或者从源文件直接输出目标文件：gcc –c hello.c –o hello.o4. 链接链接就是链接器ld将各个目标文件组装在一起，解决符号依赖，库依赖关系，并生成可执行文件。链接的命令为：ld –static crt1.o crti.o crtbeginT.o hello.o –start-group –lgcc –lgcc_eh –lc-end-group crtend.o crtn.o一般我们使用一条命令就可以完成上述4个步骤：gcc hello.c实际上gcc只是一些其它程序的包装，它会根据不同参数去调用预编译编译程序cc1、汇编器as、链接器ld。目标文件Linux下的可执行文件格式为ELF（Executalbe Linkable Format），包括可执行文件、可重定位文件（目标文件.o、静态库.a）、共享目标文件（动态库.so）、核心转储文件（core dump）。ELF目标文件的结构如下：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_2.png" alt="img">其中ELF文件中与段有关的重要结构就是段表（Section Header Table），该表描述了ELF文件包含的所有段的信息，比如每个段的名称、长度、在文件中的偏移、读写权限及段的其他属性。我们可以通过readelf工具来查看ELF文件的段：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_3.png" alt="img">几个比较重要的段如下：段名说明.text存放编译后的机器指令.data存放已初始化的全局静态变量和局部静态变量.rodata存放只读数据，如全局const变量、字符串常量.bss存放未初始化的全局静态变量和局部静态变量.symtab符号表，记录符号信息.rel.xxx重定位表，记录.xxx段中需要重定位定位符号链接过程的本质就是要把多个不同目标文件粘合成一个整体，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。在链接中，我们将函数和变量统称为符号（Symbol），函数名和变量名就是符号名（Symbol Name），我们可以将符号看做是链接中的粘合剂，整个链接过程正是基于符号才能够正确完成。每个目标文件都会有一个符号表（Symbol Table），即上图的.symtab段，这个表里记录了目标文件所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。我们可以通过readelf工具来查看符号表中所有的符号信息：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_4.png" alt="img">静态链接链接器链接的过程，就是将几个输入的目标文件加工后合并成一个输出文件。合并的方法简单来说，就是将相同性质的段合并到一起，比如将输入文件的.text段合并到.text段，接着是.data段、.bss段等，如下图所示：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_5.png" alt="img">链接器一般采用一种叫做两步链接的方法：空间与地址分配。链接器扫描所有的输入目标文件，将它们的段进行合并，计算出输出文件中各个段合并后的长度和位置，建立映射关系；并且将输入目标文件的符号表中的所有符号定义和符号引用收集起来，统一放到一个全局的符号表。 符号解析和重定位。使用上一步收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的位置等，这一步是链接过程的核心。 在链接之前，目标文件中所有段的虚拟地址都是0，因为虚拟空间还没有被分配。链接之后，输出文件的各个段都被分配到了相应的虚拟地址。同样的，链接器将输入文件中段进行合并后，就能计算出符号表中的符号在所在段的新的偏移量，通过符号所在段的虚拟地址和符号在段中的偏移量，就可以计算出符号最终的虚拟的地址。重定位是连接符号引用和符号定义的过程。在目标文件中，有一个叫重定位表（Relocation Table）的结构专门用来保存与重定位相关的信息，对于每个要被重定位的ELF段都有一个对应的重定位表，而一个重定位表往往就是ELF文件中的一个段。比如.text段和.data段都有被重定位的地方，那么就会有相应的重定位表.rel.text段和.rel.data段。每个要被重定位的地方叫做一个重定位入口（Relocation Entry），重定位入口的偏移表示该入口在要被重定位的段中的位置。重定位的过程中，每个重定位入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址，这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号进行重定位。我们看下面的符号表：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_6.png" alt="img">类型为GLOBAL的符号shared和swap都是UND，这种未定义的符号是因为该目标文件中有关于它们的重定位项。所以在链接器扫描完所有的输入目标文件之后，所有这些未定义的符号都应该能在全局符号表中找到，否则链接器就报符号未定义错误。在静态链接中，除了链接源代码生成的目标文件，还需要链接其它静态库，如C语言静态库libc。其实静态库可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。我们可以使用ar工具来查看静态库中包含了那些目标文件：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_7.png" alt="img">链接器在链接静态库的时候是以目标文件为单位的，只有引用了静态库中某个目标文件中定义的符号，才会把改目标文件链进来。装载可执行文件只有被装载到内存以后才能被CPU执行。操作系统创建一个进程，然后装载相应的可执行文件并且执行，这个过程最开始只需要做3件事情：创建一个独立的虚拟地址空间。创建虚拟空间实际上只是分配一个页目录，虚拟空间到物理内存的映射关系等到后面程序发生页错误的时候再进行设置。 读取可执行文件头（Program Header Table），并且建立虚拟空间与可执行文件的映射关系。当操作系统捕获到缺页错误时，通过该映射关系就知道当前所需要的页在可执行文件中的位置。这种映射关系是按照段（Segment）进行映射的，进程虚拟空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。 将CPU的执行寄存器设置成可执行文件的入口地址，启动运行。ELF文件头中保存了入口地址，操作系统通过设置CPU指令寄存器将控制权转交给进程，由此进程开始执行。 进程虚拟空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area），一个VMA按照一个Segment来映射可执行文件，在ELF文件中把权限相同的Section合并成一个Segment，系统正式按照Segment而非Section来映射可执行文件的。从Section的角度来看ELF文件就是连接视图（Linking View），从Segment的角度来看就是执行视图（Executiong View）。当我们在谈到ELF装载时，段专门指Segment；而在其他情况下，段指的是Section。ELF文件的Segment信息保存在可执行文件头（Program Header Table），它描述了ELF文件如何被操作系统映射到进程的虚拟空间，可以通过readelf工具查看Segment： <img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_8.png" alt="img">在上图中，类型为LOAD的两个Segment是需要被映射的，我们还可以看到哪些Section被合并到了这两个Segment中。VMA除了被用来映射可执行文件中的各个Segment，进程在执行时用到的堆、栈等空间也是以VMA的形式存在的。我们可以查看进程虚拟空间的分布：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_9.png" alt="img">操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间，基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA。一个进程基本上可以分为如下几种VMA区域：代码VMA，权限只读、可执行，有映像文件。 数据VMA，权限可读写、可执行，有映像文件。 堆VMA，权限可读写、可执行，无映像文件，匿名，可向上扩展。 栈VMA，权限可读写、不可执行，无映像文件，匿名，可向下扩展。 一个常见进程的虚拟空间如下图所示：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_10.jpg" alt="img">动态链接动态链接的基本思想是把程序按照模块拆分成相对独立的部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有的程序模块都连接成一个单独的可执行文件。ELF动态链接文件被称为动态共享对象（DSO，Dynamic Shared Object），简称共享对象，它们一般都是.so为扩展名的文件。相比静态链接，动态链接有两个优势，一是共享对象在磁盘和内存只有一份，节省了空间；二是升级某个共享模块时，只需要将目标文件替换，而无须将所有的程序重新链接。共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。为了能够使共享对象在任意地址装载，在连接时对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成，即装载时重定位。同时为了实现共享模块的指令部分在多个进程间共享，共享的指令部分就不能因为装载地址的改变而改变，解决方法就是把指令中那些需要被修改的部分分离出来，和数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本，这种方案就是地址无关代码（PIC，Position-independent Code）的技术，我们在GCC中使用-fPIC参数来生成地址无关代码。对于模块内部的符号引用使用的是相对地址，所以这种指令是不需要重定位的；而对于模块外部的符号引用，做法是在数据段建立一个全局偏移表（GOT，Global Offset Table），代码通过GOT中相对应的项进行间接引用，对GOT的引用同样使用相对地址，基本机制如下：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_11.png" alt="img">在动态链接情况下，操作系统在映射完可执行文件之后，会启动一个动态链接器（Dynamic Linker），动态链接器ld.so实际上也是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间中，并将控制权交给动态链接器的入口地址，动态链接器开始执行一系列自身的初始化操作，然后根据当前的环境参数，开始对可执行文件进行动态链接工作，当所有动态链接工作完成以后，动态链接器会将控制权转交到可执行文件的入口地址，程序开始正式执行。动态链接ELF中最重要的结构是.dynamic段，这个段里面保存了动态链接器所需要的基本信息，如依赖于哪些共享对象、动态链接符号的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。使用readelf工具可以查看.dynamic段的内容：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_12.png" alt="img">另外还可以通过ldd工具来查看一个程序或共享库依赖哪些共享库：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_13.png" alt="img">为了表示动态链接模块之间的符号导入导出关系，ELF专门有一个叫做动态符号表（Dynamic Symbol Table）的段来保存这些信息，这个段通常叫做.dynsym，它只保存了与动态链接相关的符号，静态链接符号表.syntab保存了所有的符号，一般动态链接模块同时拥有两个符号表。可以使用readelf工具来查看ELF文件的动态符号表：<img src="https://leahge.github.io/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/Linux%E4%B8%8B%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD_files/96384451_14.png" alt="img">动态链接基本上分为3步：动态链接器自举。当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码开始执行。自举代码获得动态链接器本身的重定位表和符号表，将它们重定位后，才可以使用自己的全局变量和静态变量。 装载共享对象。完成自举以后，动态链接器将可执行文件和链接器本身的符号表都合并到一个全局符号表。然后链接器开始寻找可执行文件所依赖的共享对象，并将这些共享对象的名字放入到一个装载集合中。链接器开始从集合里取一个所需要的共享对象的名字，打开相应的文件并读取ELF文件头和.dynamic段，然后将它对应的代码段和数据段映射到进程空间。如果这个ELF共享对象还依赖于其他的共享对象，那么将所依赖的共享对象放入到装载集合中。如此循环知道所有依赖的共享对象都被装载进来为止。 重定位和初始化。链接器开始重新遍历可执行文件和每个共享对象的重定位表，将他们的GOT中每个需要重定位的位置进行修正。重定位完成之后如果某个共享对象有.init段，那么动态链接器就会执行.init段中的代码，用以实现共享对象特有的初始化过程，比如共享对象中的C++全局&#x2F;静态对象的构造。 动态链接还有一种更加灵活的模块加载方式，叫做显式运行时链接，也就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载，这种共享对象往往被称为动态装载库，可以用来实现诸如插件、驱动等功能。动态库和一般的共享对象没有区别，不同的是共享对象是有动态链接器在程序启动之前负责装载和链接的，这个过程对程序本身是透明的；而动态库的装载则是通过一系列由动态链接器提供的API，具体地讲共有4个函数：打开动态库（dlopen）、查找符号（dlsym）、错误处理（dlerror）和关闭动态库（dlclose），程序可以通过这几个API对动态库进行操作。动态链接和静态链接相比，性能上大约要慢有1%-5%。有两个原因影响了动态链接的性能，一是程序开始执行时，动态链接器都要进行一次链接工作，会减慢程序的启动速度；二是对模块外部的符号引用需要通过GOT进行间接访问。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Brk</title>
      <link href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/brk/"/>
      <url>/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/brk/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Futex</title>
      <link href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/futex/"/>
      <url>/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/futex/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Exec</title>
      <link href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/exec/"/>
      <url>/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/exec/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Getcpu系统调用</title>
      <link href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/getcpu/"/>
      <url>/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/getcpu/</url>
      
        <content type="html"><![CDATA[<h1 id="getcpu系统调用"><a href="#getcpu系统调用" class="headerlink" title="getcpu系统调用"></a>getcpu系统调用</h1><p><strong>名称：</strong><br>getcpu - 确定调用线程正在运行的CPU和NUMA节点</p><p><strong>概要：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/getcpu.h&gt;</span><br><span class="line"></span><br><span class="line">int getcpu(unsigned *cpu, unsigned *node, struct getcpu_cache *tcache);</span><br><span class="line"></span><br><span class="line">注意：这个系统调用没有glibc包装。 见注意事项。</span><br></pre></td></tr></table></figure><p><strong>描述：</strong></p><p>getcpu（）系统调用标识调用线程或进程当前正在运行的处理器和节点，并将它们写入由cpu和node参数指向的整数。处理器是识别CPU的唯一小整数。该节点是标识NUMA节点的唯一小标识符。当cpu或节点为NULL时，没有任何内容写入相应的指针。</p><p>这个系统调用的第三个参数现在是未使用的，应该指定为NULL，除非需要可移植到Linux 2.6.23或更早版本（请参阅NOTES）。</p><p>保存在cpu中的信息仅在调用时保持为当前状态：除非使用sched_setaffinity（2）修复了CPU关联性，否则内核可能随时更改CPU。（通常情况下不会发生这种情况，因为调度器会尽量减少CPU之间的移动来保持缓存热度，但这是可能的。）调用者必须允许在调用返回时，在cpu和node中返回的信息不再是当前的。</p><p><strong>返回值：</strong></p><p>成功时返回0。 出错时，返回-1，并适当地设置errno。</p><p><strong>出错值：</strong></p><p>EFAULT参数指向调用进程的地址空间之外</p><p><strong>版本号：</strong></p><p>getcpu（）被添加到x86_64和i386的内核2.6.19中。</p><p><strong>遵守：</strong></p><p>getcpu（）是Linux特有的。</p><p><strong>注意：</strong></p><p>Linux尽最大努力使这个调用尽可能快。getcpu（）的意图是允许程序根据CPU数据或NUMA优化进行优化。</p><p>Glibc不提供这个系统调用的包装器; 使用syscall（2）调用它; 或者改为使用sched_getcpu（3）。</p><p>自Linux 2.6.24以来，tcache参数未被使用。在较早的内核中，如果这个参数是非空的，那么它指定一个指向线程本地存储器中被调用的缓冲区的指针，该指针用于为getcpu（）提供一个缓存机制。使用缓存可以加速getcpu（）调用，代价是返回的信息过期的可能性很小。在CPU之间迁移线程时，认为缓存机制会导致问题，因此现在忽略该参数。</p><p><strong>查看：</strong></p><p>mbind(2), sched_setaffinity(2), set_mempolicy(2), sched_getcpu(3),</p><p>cpuset(7), vdso(7)</p><p><strong>事例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">define _GNU_SOURCE</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct getcpu_cache</span><br><span class="line">&#123;</span><br><span class="line">        unsigned long blob[128/sizeof(long)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int getcpu(unsigned *cpu,unsigned *node,struct getcpu_cache *tcache)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        return syscall(SYS_getcpu,cpu,node,tcache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">        unsigned cpu;</span><br><span class="line">        unsigned node;</span><br><span class="line"></span><br><span class="line">        if(getcpu(&amp;cpu,&amp;node,NULL)==-1)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;getcpu bad \n&quot;);</span><br><span class="line">                return 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;cpu = %u node = %u\n&quot;,cpu,node);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pi@ubuntu:~/file$ ./a.out</span><br><span class="line">cpu = 0 node = 0</span><br><span class="line">pi@ubuntu:~/file$ ./a.out</span><br><span class="line">cpu = 3 node = 0</span><br><span class="line">pi@ubuntu:~/file$ ./a.out</span><br><span class="line">cpu = 2 node = 0</span><br><span class="line">pi@ubuntu:~/file$ ./a.out</span><br><span class="line">cpu = 2 node = 0</span><br><span class="line">pi@ubuntu:~/file$ ./a.out</span><br><span class="line">cpu = 2 node = 0</span><br><span class="line">pi@ubuntu:~/file$ ./a.out</span><br><span class="line">cpu = 1 node = 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gettimeofday</title>
      <link href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/gettimeofday/"/>
      <url>/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/gettimeofday/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ioctl</title>
      <link href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/ioctl/"/>
      <url>/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/ioctl/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mmap</title>
      <link href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/mmap/"/>
      <url>/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/mmap/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kallsyms</title>
      <link href="/2022/10/16/01%20OS/Linux/Kernel/kallsyms/"/>
      <url>/2022/10/16/01%20OS/Linux/Kernel/kallsyms/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/cddchina/article/details/125501920">https://blog.csdn.net/cddchina/article/details/125501920</a><br><a href="https://blog.csdn.net/weixin_28716217/article/details/111950874">https://blog.csdn.net/weixin_28716217/article/details/111950874</a></p><p>kallsyms实现原理源码分析  <a href="https://blog.csdn.net/shen332401890/article/details/17140967?spm=1001.2101.3001.6650.17&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17-17140967-blog-111950874.t0_edu_mix&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17-17140967-blog-111950874.t0_edu_mix&amp;utm_relevant_index=18">https://blog.csdn.net/shen332401890/article/details/17140967?spm=1001.2101.3001.6650.17&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-17140967-blog-111950874.t0_edu_mix&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-17-17140967-blog-111950874.t0_edu_mix&amp;utm_relevant_index=18</a></p><p>内核查找符号指针函数kallsyms_lookup_name<br><a href="https://blog.csdn.net/yongjong/article/details/126136930?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-126136930-blog-17140967.t0_edu_mix&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-126136930-blog-17140967.t0_edu_mix&amp;utm_relevant_index=3">https://blog.csdn.net/yongjong/article/details/126136930?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-126136930-blog-17140967.t0_edu_mix&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-126136930-blog-17140967.t0_edu_mix&amp;utm_relevant_index=3</a></p><p>linux内核查找符号  <a href="https://blog.csdn.net/faxiang1230/article/details/105501718/">https://blog.csdn.net/faxiang1230/article/details/105501718/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DSO(dynamic Shared Object)动态共享对象的原理</title>
      <link href="/2022/10/16/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/DSO/"/>
      <url>/2022/10/16/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/DSO/</url>
      
        <content type="html"><![CDATA[<p>DSO(dynamic shared object)动态共享对象的原理</p><p>摘要：可执行ELF文件的生成，如果从***c开始算起，需要经过编译、链接、装载几个步骤。在链接和装载这两个步骤中，有两种不同的实现方式，一种是静态链接，这样加载之前，已经形成可执行目标文件；另外一种是动态链接，这种模式下，链接阶段只是链接一部分目标文件，动态链接库（DSO）在装载的时刻才会映射到进程地址空间。本文主要讲解DSO的原理。</p><ol><li>装载过程涉及的问题</li></ol><p>当程序被装载时，系统的动态链接器会将程序所需的所有动态链接库（例如最基本的libc.so）装载到进程的地址空间，且将程序中所有为决议的符号绑定到相应的动态链接库中，并进行重定位工作（术语叫<strong>装载时重定位</strong>-load time relocation，在windows中，又叫<strong>基址重置</strong>-rebasing，区别于静态链接的<strong>链接时重定位</strong>-link time relocation）。也即，动态链接是把可执行elf的形成过程从本来的程序链接前推迟到装载时。共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。        </p><p>装载时重定位的问题：so文件被load并映射至虚拟空间后，指令部分通常是多个进程间共享的，通常的装载时重定位是通过修改指令实现的（主要是根据情况修改指令中涉及到的地址），所以无法做到同一份指令被多个进程共享（因为指令被重定位后对每个进程来讲是不同的）。这样一来，就失去了动态链接节省memory的一大优势。</p><p>为解决此问题，引入了<strong>地址无关代码</strong>（PIC，Position-independent Code，详细概念见wikipedia）的技术，基本思路是把指令中那些需要被修改的部分分离出来，跟数据部分放到一起，这样，剩下的指令就可以保持不变，而数据部分在每个进程中拥有一个副本。ELF针对各种可能的访问类型（模块内部指令调用、模块内部数据访问、模块间指令调用、模块间数据访问），实现了对应地址引用方式，从而实现了PIC。</p><p>对应到实际应用中，我们可以在编译时指定-fPIC参数让gcc产生地址无关码。</p><ol start="2"><li>影响动态链接性能的因素</li></ol><p>a. 与静态链接相比，动态链接对全局和静态的数据访问都要进行GOT（Global Offset Table，实现PIC时引入的具体技术）定位，然后间接寻址；对于模块间的调用也要先定位GOT，然后间接跳转，如此，程序的运行速度就会减慢</p><p>b. 程序装载时，动态链接器要进行一次链接工作，即查找并装载所需的共享对象，然后进行符号查找、地址重定位等工作，这会减慢程序启动速度</p><p>一方面，程序模块往往包含了大量的函数调用，从而导致动态链接器在模块间函数引用的符号查找及重定位方面耗费时间；另一方面很多函数并不会在程序运行初期就用到（尤其是有些异常处理函数），由此，EFL采用延迟绑定（lazy binding）来对动态链接做优化，其基本思想是当函数第一次被调用时才进行绑定（符号查找、重定位等），若没有被调用则不进行绑定。这个思路可以大大加快程序启动速度，对于有大量函数引用的程序启动时，尤为明显。具体到实现，EFL采用PLT（procedure linkage table）来实现，具体过程很是精妙复杂，本文只是抛砖引玉，不再详述，有兴趣的同学可以用PLT英文关键字google相关资料</p><ol start="3"><li>疑问</li></ol><p>1）是否能够用地址映射共享DSO内存</p><p>同一份指令应当是指的共享模块中的指令吧？如果是的话，那么各个进程无论将共享模块装载至进程虚拟地址空间的何处，只要在该进程装载时对共享模块中地址的引用执行重定位，即使装载的地址不一样，重定位之后也是各个进程的中的代码对共享模块引用地址的不同，而共享模块中的代码是不需要变化的？</p><p>分析：简而言之，DSO是不是可以不修改代码，而是通过将不同进程的虚拟地址映射到同一个区域的物理地址来实现，DSO的共享？</p><p>不要忘了，装载进去的都是指令，也就是一行行的“汇编代码”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [0x123456]</span><br></pre></td></tr></table></figure><p>很显然，如果DSO引用了外部模块的地址，那么这个地址的变量值总是随着整个进程空间布局的不同而变化。那么，这个问题就不是能用linux内核的内存管理中虚实地址的映射能够解决的了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Elf文件格式</title>
      <link href="/2022/10/16/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/elf/"/>
      <url>/2022/10/16/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/elf/</url>
      
        <content type="html"><![CDATA[<h1 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>什么是ELF<br>系统里的目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p><p>从贝尔实验室诞生的第一个Unix系统使用的是a.out格式（直到今天，可执行文件仍然称为a.out文件）。Windows使用可移植可执行（PortableExecutable，PE)格式。Mac OS-X使用Mach-O格式。现代x86-64Linux和Unix系统使用可执行可链接格式（Executable and Linkable Format，ELF)。</p><p>ELF格式的文件在Linux系统下有.axf、 .bin、 .elf、 .o、 .prx、 .puff、 .ko、 .mod和.so等等</p><ol><li>分类</li></ol><p>可重定位文件(Relocatable File) .o)包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。</p><p>可执行文件(Executable File) .exe) 包含适合于执行的一个程序，此文件规定了exec() 如何创建一个程序的进程映像。</p><p>共享目标文件(Shared Object File) .so) 包含可在两种上下文中链接的代码和数据。</p><p>首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理， 生成另外一个目标文件。</p><p>其次动态链接器(Dynamic Linker)可能将它与某 个可执行文件以及其它共享目标一起组合，创建进程映像。</p><ol start="2"><li>作用</li></ol><p>ELF文件参与程序的连接(建立一个程序)和程序的执行(运行一个程序)，所以可以从不同的角度来看待elf格式的文件：</p><p>如果用于编译和链接（可重定位文件），则编译器和链接器将把elf文件看作是节头表描述的节的集合,程序头表可选。</p><p>如果用于加载执行（可执行文件），则加载器则将把elf文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头表可选。</p><p>如果是共享文件，则两者都含有。</p><ol start="3"><li>ELF文件总体组成：</li></ol><p>elf文件头描述elf文件的总体信息。包括：</p><p>系统相关，类型相关，加载相关，链接相关。</p><p>系统相关表示：elf文件标识的魔术数，以及硬件和平台等相关信息，增加了elf文件的移植性,使交叉编译成为可能。</p><p>类型相关就是前面说的那个类型。</p><p>加载相关：包括程序头表相关信息。</p><p>链接相关：节头表相关信息。</p><p>下面对其进行了详细的介绍。</p><h2 id="2-ELF文件格式"><a href="#2-ELF文件格式" class="headerlink" title="2 ELF文件格式"></a>2 ELF文件格式</h2><h3 id="典型格式"><a href="#典型格式" class="headerlink" title="典型格式"></a>典型格式</h3><p>典型的ELF可重定位目标文件的格式如下图：<br><img  src="./v2-292d68399317ad971e97443f68dec061_720w.webp" alt=""><br>其中： - .text 节里装载了程序的可执行机器码 - .rodata 节里装载了只读数据 - .data 节里面装载了被初始化的数据，包括全局和静态C变量 - .bss 节里面装载了未被初始化的全局和静态C变量(在目标文件中只是占位符，不占空间) - .symtab 或者 .dynsym 节里面装载了符号信息 - 以 .rel 打头的 节里面装载了重定位条目 - .debug 一个调试符号表，只有使用了-g参数编译时才会有，用于debug - .line 用于记录C源程序的行号和.text节中机器指令之间的映射，也是只有使用了-g参数编译时才会有 - .strtab 或者 .dynstr 节里面装载了字符串信息（以null结尾的字符串信息）</p><h3 id="1-ELF文件的组织"><a href="#1-ELF文件的组织" class="headerlink" title="1. ELF文件的组织"></a>1. ELF文件的组织</h3><p>ELF文件参与程序的连接(建立一个程序)和程序的执行(运行一个程序)，编译器和链接器将其视为节头表(section header table)描述的一些节(section)的集合，而加载器则将其视为程序头表(program header table)描述的段(segment)的集合，通常一个段可以包含多个节。可重定位文件都包含一个节头表，可执行文件都包含一个程序头表。共享文件两者都包含有。为此，ELF文件格式同时提供了两种看待文件内容的方式，反映了不同行为的不同要求。</p><p>从链接的角度看，ELF文件从开始到结束，可以看成是如下组成的：</p><p>a)ELF文件头</p><p>b)程序头表（可选）</p><p>c)第1节,第2节，…，第n节，…</p><p>d)节头表</p><p>从执行的角度看，ELF文件从开始到结束，可以看成是如下组成的：</p><p>a)ELF文件头</p><p>b)程序头表</p><p>c)第1段,第2段，…，</p><p>d)节头表(可选)</p><h3 id="2-文件头-Elf-header"><a href="#2-文件头-Elf-header" class="headerlink" title="2. 文件头(Elf header)"></a>2. 文件头(Elf header)</h3><p>Elf头在程序的开始部位，作为引路表描述整个ELF的文件结构，其信息大致分为四部分：一是系统相关信息，二是目标文件类型，三是加载相关信息，四是链接相关信息。</p><p>其中系统相关信息包括elf文件魔数(标识elf文件)，平台位数，数据编码方式，elf头部版本，硬件平台e_machine，目标文件版本 e_version，处理器特定标志e_ftags：这些信息的引入极大增强了elf文件的可移植性，使交叉编译成为可能。目标文件类型用e_type的值表示，可重定位文件为1，可执行文件为2，共享文件为3;加载相关信息有：程序进入点e_entry．程序头表偏移量e_phoff，elf头部长度 e_ehsize，程序头表中一个条目的长度e_phentsize，程序头表条目数目e_phnum;链接相关信息有：节头表偏移量e_shoff，节头表中一个条目的长度e_shentsize，节头表条目个数e_shnum ，节头表字符索引e shstmdx。可使用命令”readelf -h filename”来察看文件头的内容。</p><p>文件头的数据结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf32_hdr&#123;</span><br><span class="line"></span><br><span class="line">unsigned char e_ident[EI_NIDENT];</span><br><span class="line"></span><br><span class="line">Elf32_Half e_type;//目标文件类型</span><br><span class="line"></span><br><span class="line">Elf32_Half e_machine;//硬件平台</span><br><span class="line"></span><br><span class="line">Elf32_Word e_version;//elf头部版本</span><br><span class="line"></span><br><span class="line">Elf32_Addr e_entry;//程序进入点</span><br><span class="line"></span><br><span class="line">Elf32_Off e_phoff;//程序头表偏移量</span><br><span class="line"></span><br><span class="line">Elf32_Off e_shoff;//节头表偏移量</span><br><span class="line"></span><br><span class="line">Elf32_Word e_flags;/处理器特定标志</span><br><span class="line"></span><br><span class="line">Elf32_Half e_ehsize;//elf头部长度</span><br><span class="line"></span><br><span class="line">Elf32_Half e_phentsize;//程序头表中一个条目的长度</span><br><span class="line"></span><br><span class="line">Elf32_Half e_phnum;//程序头表条目数目</span><br><span class="line"></span><br><span class="line">Elf32_Half e_shentsize;//节头表中一个条目的长度</span><br><span class="line"></span><br><span class="line">Elf32_Half e_shnum;//节头表条目个数</span><br><span class="line"></span><br><span class="line">Elf32_Half e_shstrmdx;//节头表字符索引</span><br><span class="line"></span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure><h3 id="3-程序头表-program-header-table"><a href="#3-程序头表-program-header-table" class="headerlink" title="3. 程序头表(program header table)"></a>3. 程序头表(program header table)</h3><p>程序头表告诉系统如何建立一个进程映像．它是从加载执行的角度来看待elf文件．从它的角度看．elf文件被分成许多段，elf文件中的代码、链接信息和注释都以段的形式存放。每个段都在程序头表中有一个表项描述，包含以下属性：段的类型，段的驻留位置相对于文件开始处的偏移，段在内存中的首字节地址，段的物理地址，段在文件映像中的字节数．段在内存映像中的字节数，段在内存和文件中的对齐标记。可用”readelf -l filename”察看程序头表中的内容。程序头表的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf32_phdr&#123;</span><br><span class="line"></span><br><span class="line">Elf32_Word p_type; //段的类型</span><br><span class="line"></span><br><span class="line">Elf32_Off p_offset; //段的位置相对于文件开始处的偏移</span><br><span class="line"></span><br><span class="line">Elf32_Addr p_vaddr; //段在内存中的首字节地址</span><br><span class="line"></span><br><span class="line">Elf32_Addr p_paddr;//段的物理地址</span><br><span class="line"></span><br><span class="line">Elf32_Word p_filesz;//段在文件映像中的字节数</span><br><span class="line"></span><br><span class="line">Elf32_Word p_memsz;//段在内存映像中的字节数</span><br><span class="line"></span><br><span class="line">Elf32_Word p_flags;//段的标记</span><br><span class="line"></span><br><span class="line">Elf32_Word p_align;，/段在内存中的对齐标记</span><br><span class="line"></span><br><span class="line">)Elf32_Phdr;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-节头表-section-header-table"><a href="#4-节头表-section-header-table" class="headerlink" title="4. 节头表(section header table)"></a>4. 节头表(section header table)</h3><p>节头表描述程序节，为编译器和链接器服务。它把elf文件分成了许多节．每个节保存着用于不同目的的数据．这些数据可能被前面的程序头重复使用，完成一次任务所需的信息往往被分散到不同的节里。由于节中数据的用途不同，节被分成不同的类型，每种类型的节都有自己组织数据的方式。每一个节在节头表中都有一个表项描述该节的属性，节的属性包括小节名在字符表中的索引，类型，属性，运行时的虚拟地址，文件偏移，以字节为单位的大小，小节的对齐等信息，可使用”readelf -S filename”来察看节头表的内容。节头表的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">Elf32_Word sh_name;//小节名在字符表中的索引</span><br><span class="line"></span><br><span class="line">E1t32_Word sh_type;//小节的类型</span><br><span class="line"></span><br><span class="line">Elf32_Word sh_flags;//小节属性</span><br><span class="line"></span><br><span class="line">Elf32_Addr sh_addr; //小节在运行时的虚拟地址</span><br><span class="line"></span><br><span class="line">Elf32_Off sh_offset;//小节的文件偏移</span><br><span class="line"></span><br><span class="line">Elf32_Word sh_size;//小节的大小．以字节为单位</span><br><span class="line"></span><br><span class="line">Elf32_Word sh_link;//链接的另外一小节的索引</span><br><span class="line"></span><br><span class="line">Elf32 Word sh_info;//附加的小节信息</span><br><span class="line"></span><br><span class="line">Elf32 Word sh_addralign;//小节的对齐</span><br><span class="line"></span><br><span class="line">Elf32 Word sh_entsize; //一些sections保存着一张固定大小入口的表。就像符号表</span><br><span class="line"></span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure><h3 id="5-符号表部分解析"><a href="#5-符号表部分解析" class="headerlink" title="5. 符号表部分解析"></a>5. 符号表部分解析</h3><p>符号表每节定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int   name;      /* String table offset */</span><br><span class="line">    char  type:4,    /* Function or data (4 bits) */</span><br><span class="line">      binding:4; /* Local or global (4 bits) */</span><br><span class="line">    char  reserved;  /* Unused */  </span><br><span class="line">    short section;   /* Section header index */</span><br><span class="line">    long  value;     /* Section offset or absolute address */</span><br><span class="line">    long  size;      /* Object size in bytes */</span><br><span class="line">&#125; Elf64_Symbol;</span><br></pre></td></tr></table></figure><p>具体解释如下：<br><img  src="./v2-9889a20d2f4af62998913baf6e890ef5_720w.jpeg" alt=""></p><p>举个例子<br>以上面的sum.c生成的sum.o为例，我们选取readelf的-all参数输出全部内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">$readelf -all sum.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          536 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         11</span><br><span class="line">  Section header string table index: 10</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .data             PROGBITS         0000000000000000  0000005b</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 3] .bss              NOBITS           0000000000000000  0000005b</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  1 int sum(int *a, int n)</span><br><span class="line">  2 &#123;</span><br><span class="line">  [ 4] .comment          PROGBITS         0000000000000000  0000005b</span><br><span class="line">       000000000000002e  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 5] .note.GNU-stack   PROGBITS         0000000000000000  00000089</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 6] .eh_frame         PROGBITS         0000000000000000  00000090</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 7] .rela.eh_frame    RELA             0000000000000000  000001a8</span><br><span class="line">       0000000000000018  0000000000000018   I       8     6     8</span><br><span class="line">  [ 8] .symtab           SYMTAB           0000000000000000  000000c0</span><br><span class="line">       00000000000000d8  0000000000000018           9     8     8</span><br><span class="line">  [ 9] .strtab           STRTAB           0000000000000000  00000198</span><br><span class="line">       000000000000000b  0000000000000000           0     0     1</span><br><span class="line">  [10] .shstrtab         STRTAB           0000000000000000  000001c0</span><br><span class="line">       0000000000000054  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br><span class="line"></span><br><span class="line">There are no section groups in this file.</span><br><span class="line"></span><br><span class="line">There are no program headers in this file.</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.eh_frame&#x27; at offset 0x1a8 contains 1 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br><span class="line"></span><br><span class="line">The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 9 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sum.i</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     8: 0000000000000000    27 FUNC    GLOBAL DEFAULT    1 sum</span><br><span class="line"></span><br><span class="line">No version information found in this file.</span><br></pre></td></tr></table></figure><p>其中第一部分是ELF头（ELF header）中的描述信息。（用-h参数可以单独得到）。</p><p>最后一部分是符号表部分（用-s参数可以单独得到该部分），前面八个条目是链接器内部使用的局部符号，最后一行是全局符号sum定义的条目。可以通过最后一行看出，它是一个位于.text节中偏移量为0处的27字节函数。（Ndx部分表示在哪个节中，1表示.text节，3表示.data节，对应上面输出的Section Headers部分）</p><h3 id="6-节与静态链接"><a href="#6-节与静态链接" class="headerlink" title="6. 节与静态链接"></a>6. 节与静态链接</h3><p>常规的 ELF 文件，ET_REL, ET_DYN 以及 ET_EXEC 类型都含有节，对于 ET_REL 类型 的ELF文件，节是必须存在的，而对于 ET_DYN 和 ET_EXEC 是可以没有节的，但由于Linux系统的版本碎片化比较严重，可执行文件也可能要求含有节，否则无法执行（如安卓后期版本的系统），这依赖于系统动态链接器的实现。</p><p>ET_REL 类型的 ELF，节中包含了一些符号定义、节属性（可读可写可执行）。通过 readelf 工具可以方便查看这些信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$readelf test.o -S</span><br><span class="line">There are 15 section headers, starting at offset 0x2e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .group            GROUP           00000000 000034 000008 04     12  12  4</span><br><span class="line">  [ 2] .text             PROGBITS        00000000 00003c 000032 00  AX  0   0  1</span><br><span class="line">  [ 3] .rel.text         REL             00000000 00022c 000020 08   I 12   2  4</span><br><span class="line">  [ 4] .data             PROGBITS        00000000 00006e 000000 00  WA  0   0  1</span><br><span class="line">  [ 5] .bss              NOBITS          00000000 00006e 000000 00  WA  0   0  1</span><br><span class="line">  [ 6] .rodata           PROGBITS        00000000 00006e 00000b 00   A  0   0  1</span><br><span class="line">  [ 7] .text.__x86.get_p PROGBITS        00000000 000079 000004 00 AXG  0   0  1</span><br><span class="line">  [ 8] .comment          PROGBITS        00000000 00007d 00002c 01  MS  0   0  1</span><br><span class="line">  [ 9] .note.GNU-stack   PROGBITS        00000000 0000a9 000000 00      0   0  1</span><br><span class="line">  [10] .eh_frame         PROGBITS        00000000 0000ac 000050 00   A  0   0  4</span><br><span class="line">  [11] .rel.eh_frame     REL             00000000 00024c 000010 08   I 12  10  4</span><br><span class="line">  [12] .symtab           SYMTAB          00000000 0000fc 0000f0 10     13  11  4</span><br><span class="line">  [13] .strtab           STRTAB          00000000 0001ec 00003e 00      0   0  1</span><br><span class="line">  [14] .shstrtab         STRTAB          00000000 00025c 000082 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure><p>以上readelf 对一个 .o 文件 （ET_REL类型） 的输出，其中 .text 段中存放可执行的代码，.data 中存放数据（如全局变量，静态变量等），.rodata 存放了常量数据（如字符串等），.bss 中存放未初始化或初始化为零的数据，本节将介绍这些细节。</p><h4 id="节表"><a href="#节表" class="headerlink" title="节表"></a><strong>节表</strong></h4><p>节表是节头（Section Header）数组，位置和个数由 Elf_Ehdr 的 e_shoff 和 e_shnum 指定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Elf_Shdr* shdrs = (Elf_Shdr*)(elf_data + ehdr-&gt;e_shoff);</span><br><span class="line">Elf_Half scnt = elf-&gt;e_shnum;</span><br></pre></td></tr></table></figure><p>节头包含了节名称，节属性，文件偏移等内容，定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Section header.  */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf_Wordsh_name;/* Section name (string tbl index) */</span><br><span class="line">  Elf_Wordsh_type;/* Section type */</span><br><span class="line">  Elf_Wordsh_flags;/* Section flags */</span><br><span class="line">  Elf_Addrsh_addr;/* Section virtual addr at execution */</span><br><span class="line">  Elf_Offsh_offset;/* Section file offset */</span><br><span class="line">  Elf_Wordsh_size;/* Section size in bytes */</span><br><span class="line">  Elf_Wordsh_link;/* Link to another section */</span><br><span class="line">  Elf_Wordsh_info;/* Additional section information */</span><br><span class="line">  Elf_Wordsh_addralign;/* Section alignment */</span><br><span class="line">  Elf_Wordsh_entsize;/* Entry size if section holds table */</span><br><span class="line">&#125; Elf_Shdr;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="sh-name"><a href="#sh-name" class="headerlink" title="sh_name"></a><strong>sh_name</strong></h5><p>节名称，这是一个节字符串表的偏移，节字符串的索引在 Elf_Ehdr 的 e_shstrndx 中指定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char* sname = (const char*)(elf_data +</span><br><span class="line">shdr[elf-&gt;e_shstrndx].sh_offset);</span><br></pre></td></tr></table></figure><h5 id="sh-type"><a href="#sh-type" class="headerlink" title="sh_type"></a><strong>sh_type</strong></h5><p>节类型，以下为 ET_REL 常见的节类型定义：</p><table><thead><tr><th>节类型</th><th>节描述</th></tr></thead><tbody><tr><td>SHT_NULL</td><td>索引为 0 的节</td></tr><tr><td>SHT_PROGBITS</td><td>程序数据，如代码、数据等</td></tr><tr><td>SHT_NOBITS</td><td>未初始化或初始化为零的数据，该节不占用ELF文件空间，但有大小</td></tr><tr><td>SHT_SYMTAB</td><td>符号节</td></tr><tr><td>SHT_STRTAB</td><td>字符串节</td></tr><tr><td>SHT_REL</td><td>REL 重定位节（32位）</td></tr><tr><td>SHT_RELA</td><td>RELA 重定位节（64位）</td></tr><tr><td>SHT_GROUP</td><td>组节</td></tr></tbody></table><h5 id="sh-flags"><a href="#sh-flags" class="headerlink" title="sh_flags"></a><strong>sh_flags</strong></h5><p>节的标志位可以组合，描述了节的属性，定义如下：</p><table><thead><tr><th>节标志</th><th>描述</th></tr></thead><tbody><tr><td>SHF_WRITE</td><td>可写</td></tr><tr><td>SHF_ALLOC</td><td>执行时驻留内存（这种节一般包含在段内）</td></tr><tr><td>SHF_EXECINSTR</td><td>可执行</td></tr><tr><td>SHF_MERGE</td><td>可能被合并</td></tr><tr><td>SHF_STRINGS</td><td>包含以 0 结尾的字符串</td></tr><tr><td>SHF_INFO_LINK</td><td>sh_info 关联了另一个节的索引</td></tr><tr><td>SHF_GROUP</td><td>此节是个组节的成员</td></tr><tr><td>SHF_TLS</td><td>节包含了线程局部存储（TLS）数据</td></tr></tbody></table><h5 id="sh-addr"><a href="#sh-addr" class="headerlink" title="sh_addr"></a><strong>sh_addr</strong></h5><p>节的虚拟地址，对于 ET_REL 一般都为0。</p><h5 id="sh-offset"><a href="#sh-offset" class="headerlink" title="sh_offset"></a><strong>sh_offset</strong></h5><p>节的文件偏移。</p><h5 id="sh-size"><a href="#sh-size" class="headerlink" title="sh_size"></a><strong>sh_size</strong></h5><p>节的大小。</p><h5 id="sh-link"><a href="#sh-link" class="headerlink" title="sh_link"></a><strong>sh_link</strong></h5><p>关联到其它节（不同节代表不同的意义，后面会有介绍）。</p><h5 id="sh-info"><a href="#sh-info" class="headerlink" title="sh_info"></a><strong>sh_info</strong></h5><p>附加的节信息（不同节代表不同的意义，后面会有介绍）。</p><h5 id="sh-addralign"><a href="#sh-addralign" class="headerlink" title="sh_addralign"></a><strong>sh_addralign</strong></h5><p>地址对齐。</p><h5 id="sh-entsize"><a href="#sh-entsize" class="headerlink" title="sh_entsize"></a><strong>sh_entsize</strong></h5><p>如果节内容是特定元素的数组，该值代表了元素大小，如对于 SHT_SYMTAB，该址为的大小为sizeof(Elf_Sym)。</p><p>各个节类型的 sh_info 与 sh_link 的意义如下：</p><table><thead><tr><th>节类型</th><th>sh_info</th><th>sh_link</th></tr></thead><tbody><tr><td>SHT_SYMTAB &#x2F; SHT_DYNSYM</td><td>全局符号的起始索引</td><td>（静态&#x2F;动态）字符串节索引</td></tr><tr><td>SHT_REL &#x2F; SHT_RELA</td><td>被重定位的节的索引</td><td>（静态&#x2F;动态）符号节索引</td></tr><tr><td>SHT_DYNAMIC</td><td>无</td><td>动态字符串节索引</td></tr><tr><td>SHT_GNU_versym</td><td>无</td><td>动态符号节索引</td></tr><tr><td>SHT_GNU_verneed</td><td>Verneed 项的数量</td><td>动态字符串节索引</td></tr><tr><td>SHT_GNU_verdef</td><td>Verdef 项的数量</td><td>动态字符串节索引</td></tr><tr><td>SHT_HASH &#x2F; SHT_GNU_HASH</td><td>无</td><td>动态符号节索引</td></tr></tbody></table><h4 id="符号节与字符串节"><a href="#符号节与字符串节" class="headerlink" title="符号节与字符串节"></a><strong>符号节与字符串节</strong></h4><p>符号节分静态符号节（ST_SYMTAB）与动态符号节（SHT_DYNSYM），可以通过枚举节表得到。每种符号节在一个 ELF 文件中只存在一个，动态符号节只在 ET_EXEC 和 ET_DYN 类型的 ELF 中存在，不会在 ET_REL 类型的 ELF 中出现。</p><p>符号节中包含了 Elf_Sym 类型的符号表，Elf_Sym 的定义如下：</p><p>32位定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Wordst_name;/* Symbol name (string tbl index) */</span><br><span class="line">  Elf32_Addrst_value;/* Symbol value */</span><br><span class="line">  Elf32_Wordst_size;/* Symbol size */</span><br><span class="line">  unsigned charst_info;/* Symbol type and binding */</span><br><span class="line">  unsigned charst_other;/* Symbol visibility */</span><br><span class="line">  Elf32_Sectionst_shndx;/* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p>64位定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Wordst_name;/* Symbol name (string tbl index) */</span><br><span class="line">  unsigned charst_info;/* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;/* Symbol visibility */</span><br><span class="line">  Elf64_Sectionst_shndx;/* Section index */</span><br><span class="line">  Elf64_Addrst_value;/* Symbol value */</span><br><span class="line">  Elf64_Xwordst_size;/* Symbol size */</span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p><strong>st_name</strong><br>符号名，该值为符号节所关联的字符串节的字符串索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//  uint8_t* elf_data;</span><br><span class="line">//  Elf_Shdr* sym_sect;</span><br><span class="line">//Elf_Sym* sym;</span><br><span class="line">const char*strtab = (const char*)(elf_data +</span><br><span class="line">shdr[sym_sect-&gt;sh_link].sh_off);</span><br><span class="line">const char* sym_name = strtab + sym-&gt;st_name;</span><br></pre></td></tr></table></figure><p><strong>st_info</strong><br>符号信息，描述了符号类型与符号绑定信息。</p><p>符号类型可以通过 ELF_ST_TYPE(st_info) 获取，符号类型的定义如下：</p><table><thead><tr><th>符号类型</th><th>描述</th></tr></thead><tbody><tr><td>STT_NOTYPE</td><td>未定义符号</td></tr><tr><td>STT_OBJECT</td><td>符号是数据</td></tr><tr><td>STT_FUNC</td><td>符号是函数</td></tr><tr><td>STT_SECTION</td><td>节符号，每个节都会有一个节符号</td></tr><tr><td>STT_FILE</td><td>符号名是源文件的文件名，如 .&#x2F;..&#x2F;..&#x2F;test.c</td></tr><tr><td>STT_COMMON</td><td>符号是公共数据</td></tr><tr><td>STT_TLS</td><td>符号是 TLS 数据</td></tr><tr><td>符号绑定可以通过 ELF_ST_BIND(st_info) 获取，符号绑定的定义如下：</td><td></td></tr></tbody></table><table><thead><tr><th>绑定类型</th><th>描述</th></tr></thead><tbody><tr><td>STB_LOCAL</td><td>局部符号，对其它文件不可见（如被static修饰的函数）</td></tr><tr><td>STB_GLOBAL</td><td>全局符号</td></tr><tr><td>STB_WEAK</td><td>弱符号（允许符号找不到）</td></tr><tr><td><strong>st_other</strong></td><td></td></tr><tr><td>描述了符号的可见性，定义如下：</td><td></td></tr></tbody></table><table><thead><tr><th>可见类型</th><th>描述</th></tr></thead><tbody><tr><td>STV_DEFAULT</td><td>默认的可见性</td></tr><tr><td>STV_INTERNAL</td><td>处理器定义的隐藏类</td></tr><tr><td>STV_HIDDEN</td><td>符号对其它模块隐藏</td></tr><tr><td>STV_PROTECTED</td><td>符号不导出</td></tr><tr><td>STV_INTERNAL 和 STV_PROTECTED 是很少见的（至少笔者没有见过），对于SO库（ET_DYN）来说，符号是否导出，不是通过遍历符号表，而是通过查找哈希表，再检查符号类型，后续章节会介绍哈希表。</td><td></td></tr></tbody></table><p>**st_shndx **<br>符号所在节的节索引，还有一些特殊定义：</p><table><thead><tr><th>节索引</th><th>描述</th></tr></thead><tbody><tr><td>SHN_UNDEF</td><td>未定义符号，可能存在其它文件或模块中</td></tr><tr><td>SHN_LORESERVE</td><td>小于该值且不为SHN_UNDEF，则代表真正的节索引，否则均为特殊索引</td></tr><tr><td>SHN_ABS</td><td>绝对符号，只是描述一些信息，如对于STT_FILE 类型的符号</td></tr><tr><td><strong>st_value</strong></td><td></td></tr><tr><td>符号的地址</td><td></td></tr></tbody></table><p><strong>st_size</strong><br>符号大小</p><h2 id="3-ELF的特性"><a href="#3-ELF的特性" class="headerlink" title="3 ELF的特性"></a>3 ELF的特性</h2><h3 id="3-1平台相关"><a href="#3-1平台相关" class="headerlink" title="3.1平台相关"></a>3.1平台相关</h3><p>在ELF 文件头中包含了足够的平台相关信息，如数据编码方式，平台位数，硬件平台e_machine等，这些平台相关信息可在编译由编译器决定。例如，与平台位数的相关的数据结构的定义在elf.h的头文件中．在编译预处理时确定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#if ELF CLASS==ELFCLASS32</span><br><span class="line"></span><br><span class="line">extern Elf32_Dyn_DYNAMIC[];</span><br><span class="line"></span><br><span class="line">#define elfhdr elf32_hdr;</span><br><span class="line"></span><br><span class="line">#define elf_phdr elf32_phdr;</span><br><span class="line"></span><br><span class="line">#define elf_note elf32_note;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">extern Elf64_Dyn_DYNAMIC[];</span><br><span class="line"></span><br><span class="line">#define elfhdr elf64_hdr;</span><br><span class="line"></span><br><span class="line">#define elf_phdr elf64_phdr;</span><br><span class="line"></span><br><span class="line">#define elf_note elf64_note;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>linux系统加载ELF可执行文件时，必须首先做一些简单的一致性检查．其代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(memcmp(elf_ex.e_ident,ELFMAG,SELFMAG)!=0)</span><br><span class="line"></span><br><span class="line">goto out; //检查文件头开始四个字符是否为ELF魔数&#x27;\0177ELF</span><br><span class="line"></span><br><span class="line">if(elf_ex.e_type!=ET_EXEC&amp;&amp;elf_ex.e_type!=ET_DYN)</span><br><span class="line"></span><br><span class="line">goto out;//检查文件类型是否为可执行文件或共享目标文件</span><br><span class="line"></span><br><span class="line">if(!elf_check_arch(&amp;elf_ex))</span><br><span class="line"></span><br><span class="line">goto out;//检查硬件平台是否一致</span><br></pre></td></tr></table></figure><p>其中的elf_check_arch(x)在不同的硬件平台上有不同的定义，其由系统的硬件平台决定。这样，在硬件平台相同的系统上，ELF可以不作修改的执行。因此，它可以支持不同平台上的交叉编译(cross_compilation)和交叉链接(cross_linking)。</p><h3 id="3-2-PIC"><a href="#3-2-PIC" class="headerlink" title="3.2 PIC"></a>3.2 PIC</h3><p>ELF可以生成一种特殊的代码——与位置无关的代码(position-independent code,PIC)。用户对gcc使用-fPIC指示GNU编译系统生成PIC代码。它是实现共享库或共享可执行代码的基础．这种代码的特殊性在于它可以加载到内存地址空间的任何地址执行．这也是加载器可以很方便的在进程中动态链接共享库。</p><p>PIC的实现运用了一个事实，就是代码段中任何指令和数据段中的任何变量之间的距离都是一个与代码段和数据段的绝对存储器位置无关的常量。因此，编译器在数据段开始的地方创建了一个表．叫做全局偏移量表(global offset table．GOT)。GOT包含每个被这个目标模块引用的全局数据目标的表目。编译器还为GOT中每个表目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个表目，使得它包含正确的绝对地址。PIC代码在代码中实现通过GOT间接的引用每个全局变量，这样，代码中本来简单的数据引用就变得复杂，必须加入得到GOT适当表目内容的指令。对只读数据的引用也根据同样的道理，所以，加上 IC编译成的代码比一般的代码开销大。</p><p>如果一个elf可执行文件需要调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT(procedure linkage table，过程链接表)．这两个节之间的交互可以实现延迟绑定(lazy binging)，这种方法将过程地址的绑定推迟到第一次调用该函数。为了实现延迟绑定，GOT的头三条表目是特殊的：GOT[0]包含.dynamic 段的地址，.dynamic段包含了动态链接器用来绑定过程地址的信息，比如符号的位置和重定位信息;GOT[1]包含动态链接器的标识;GOT[2]包含动态链接器的延迟绑定代码的入口点。GOT的其他表目为本模块要引用的一个全局变量或函数的地址。PLT是一个以16字节(32位平台中)表目的数组形式出现的代码序列。其中PLT[0]是一个特殊的表目，它跳转到动态链接器中执行;每个定义在共享库中并被本模块调用的函数在PLT中都有一个表目，从 PLT[1]开始．模块对函数的调用会转到相应PLT表目中执行，这些表目由三条指令构成。第一条指令是跳转到相应的GOT存储的地址值中．第二条指令把函数相应的ID压入栈中，第三条指令跳转到PLT[O]中调用动态链接器解析函数地址，并把函数真正地址存入相应的GOT表目中。被调用函数GOT相应表目中存储的最初地址为相应PLT表目中第二条指令的地址值，函数第一次被调用后．GOT表目中的值就为函数的真正地址。因此，第一次调用函数时开销比较大．但是其后的每次调用都只会花费一条指令和一个间接的存储器引用。</p><h3 id="3-3-强大的工具支持"><a href="#3-3-强大的工具支持" class="headerlink" title="3.3 强大的工具支持"></a>3.3 强大的工具支持</h3><p>由于gnu有大量的工具支持elf文件格式．随着gnu工具的功能的扩展．程序员对ELF文件的运用也越来越灵活。例如，在C++中全局的构造函数和析构函数必须非常小心的处理碰到的语言规范问题。构造函数必须在main函数之前被调用。析构函数必须在main函数返回之后被调用。ELF文件格式中，定义了两个特殊的节 (section)，.init和.fini，.init保存着可执行指令，它构成了进程的初始化代码。当一个程序开始运行时，在main函数被调用之前 (c语言称为main)，系统安排执行这个section的中的代码。.fini保存着可执行指令，它构成了进程的终止代码。当一个程序正常退出时．系统安排执行这个section的中的代码。C++编译器利用这个特性．构造正确的.init和.fini sections．并结合.ctors(该section保存着程序的全局的构造函数的指针数组)和.dtors(该section保存着程序的全局的析构函数的指针数组)两个section，完成全局的构造函数和析构函数的处理。</p><p>GCC还有许多扩展的特性．有些对ELF 特别的有用。其中一个就是_attribute_ 。使用_attribute_可以使一个函数放到_CTOR_LIST_或者_DTOR_LIST_里。 <em>attribute</em>((constructor))促使函数在进入main之前会被自动调用。<em>attribute</em>((destructor))促使函数在main返回或者exit调用之后被自动调用。这种函数必须是不能带参数的而且必须是static void类型的函数。在ELF下，这个特性在一般的可执行文件和共享库中都能很好的工作。另外一个GCC的特性是 attribute_(section(“sectionname”))，使用这个，能把一个函数或者是数据结构放到任何的section中。</p><p>[举例]</p><p>这里，通过使用一些用于操作ELF文件的工具的例子，来对其有一个直观的了解。</p><p>1 readelf工具</p><p>readelf用来显示ELF格式目标文件的信息.可通过参数选项来控制显示哪些特定信息。</p><p>*读取elf文件头信息：</p><p><code> $ readelf -h fbtest</code></p><p>输入之后，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line"></span><br><span class="line">Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line"></span><br><span class="line">Class:                             ELF32</span><br><span class="line"></span><br><span class="line">Data:                              2&#x27;s complement, little endian</span><br><span class="line"></span><br><span class="line">Version:                           1 (current)</span><br><span class="line"></span><br><span class="line">OS/ABI:                            UNIX - System V</span><br><span class="line"></span><br><span class="line">ABI Version:                       0</span><br><span class="line"></span><br><span class="line">Type:                              EXEC (Executable file)</span><br><span class="line"></span><br><span class="line">Machine:                           Intel 80386</span><br><span class="line"></span><br><span class="line">Version:                           0x1</span><br><span class="line"></span><br><span class="line">Entry point address:               0x80484d0</span><br><span class="line"></span><br><span class="line">Start of program headers:          52 (bytes into file)</span><br><span class="line"></span><br><span class="line">Start of section headers:          5924 (bytes into file)</span><br><span class="line"></span><br><span class="line">Flags:                             0x0</span><br><span class="line"></span><br><span class="line">Size of this header:               52 (bytes)</span><br><span class="line"></span><br><span class="line">Size of program headers:           32 (bytes)</span><br><span class="line"></span><br><span class="line">Number of program headers:         8</span><br><span class="line"></span><br><span class="line">Size of section headers:           40 (bytes)</span><br><span class="line"></span><br><span class="line">Number of section headers:         36</span><br><span class="line"></span><br><span class="line">Section header string table index: 33</span><br></pre></td></tr></table></figure><p>这里，fbtest是在本地使用gcc编译生成的一个简单的可执行程序。</p><p>*查看elf文件程序头表信息：</p><p><code>$readelf -l fbtest</code></p><p>输入之后，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Program Headers:</span><br><span class="line"></span><br><span class="line">Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line"></span><br><span class="line">PHDR           0x000034 0x08048034 0x08048034 0x00100 0x00100 R E 0x4</span><br><span class="line"></span><br><span class="line">INTERP         0x000134 0x08048134 0x08048134 0x00013 0x00013 R   0x1</span><br><span class="line"></span><br><span class="line">[Requesting program interpreter: /lib/ld-linux.so.2]</span><br><span class="line"></span><br><span class="line">LOAD           0x000000 0x08048000 0x08048000 0x00df4 0x00df4 R E 0x1000</span><br><span class="line"></span><br><span class="line">LOAD           0x000f0c 0x08049f0c 0x08049f0c 0x00128 0x00178 RW  0x1000</span><br><span class="line"></span><br><span class="line">DYNAMIC        0x000f20 0x08049f20 0x08049f20 0x000d0 0x000d0 RW  0x4</span><br><span class="line"></span><br><span class="line">NOTE           0x000148 0x08048148 0x08048148 0x00020 0x00020 R   0x4</span><br><span class="line"></span><br><span class="line">GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4</span><br><span class="line"></span><br><span class="line">GNU_RELRO      0x000f0c 0x08049f0c 0x08049f0c 0x000f4 0x000f4 R   0x1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Section to Segment mapping:</span><br><span class="line"></span><br><span class="line">Segment Sections...</span><br><span class="line"></span><br><span class="line">00</span><br><span class="line"></span><br><span class="line">01     .interp</span><br><span class="line"></span><br><span class="line">02     .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame</span><br><span class="line"></span><br><span class="line">03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss</span><br><span class="line"></span><br><span class="line">04     .dynamic</span><br><span class="line"></span><br><span class="line">05     .note.ABI-tag</span><br><span class="line"></span><br><span class="line">06</span><br><span class="line"></span><br><span class="line">07     .ctors .dtors .jcr .dynamic .got</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>*查看elf文件的节信息：</p><p><code> $readelf -S libmy.so</code></p><p>输入之后，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">There are 33 section headers, starting at offset 0xfd0:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line"></span><br><span class="line">[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line"></span><br><span class="line">[ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line"></span><br><span class="line">[ 1] .hash             HASH            000000d4 0000d4 0000a0 04   A  3   0  4</span><br><span class="line"></span><br><span class="line">[ 2] .gnu.hash         GNU_HASH        00000174 000174 000040 04   A  3   0  4</span><br><span class="line"></span><br><span class="line">[ 3] .dynsym           DYNSYM          000001b4 0001b4 000150 10   A  4   1  4</span><br><span class="line"></span><br><span class="line">[ 4] .dynstr           STRTAB          00000304 000304 00018a 00   A  0   0  1</span><br><span class="line"></span><br><span class="line">[ 5] .gnu.version      VERSYM          0000048e 00048e 00002a 02   A  3   0  2</span><br><span class="line"></span><br><span class="line">[ 6] .gnu.version_r    VERNEED         000004b8 0004b8 000020 00   A  4   1  4</span><br><span class="line"></span><br><span class="line">[ 7] .rel.dyn          REL             000004d8 0004d8 0000e8 08   A  3   0  4</span><br><span class="line"></span><br><span class="line">[ 8] .rel.plt          REL             000005c0 0005c0 000010 08   A  3  10  4</span><br><span class="line"></span><br><span class="line">[ 9] .init             PROGBITS        000005d0 0005d0 000030 00  AX  0   0  4</span><br><span class="line"></span><br><span class="line">[10] .plt              PROGBITS        00000600 000600 000030 04  AX  0   0  4</span><br><span class="line"></span><br><span class="line">[11] .text             PROGBITS        00000630 000630 0002a4 00  AX  0   0 16</span><br><span class="line"></span><br><span class="line">[12] .fini             PROGBITS        000008d4 0008d4 00001c 00  AX  0   0  4</span><br><span class="line"></span><br><span class="line">[13] .rodata           PROGBITS        000008f0 0008f0 000006 00   A  0   0  1</span><br><span class="line"></span><br><span class="line">[14] .eh_frame_hdr     PROGBITS        000008f8 0008f8 000034 00   A  0   0  4</span><br><span class="line"></span><br><span class="line">[15] .eh_frame         PROGBITS        0000092c 00092c 0000d8 00   A  0   0  4</span><br><span class="line"></span><br><span class="line">[16] .ctors            PROGBITS        00001a04 000a04 00000c 00  WA  0   0  4</span><br><span class="line"></span><br><span class="line">[17] .dtors            PROGBITS        00001a10 000a10 000008 00  WA  0   0  4</span><br><span class="line"></span><br><span class="line">[18] .jcr              PROGBITS        00001a18 000a18 000004 00  WA  0   0  4</span><br><span class="line"></span><br><span class="line">[19] .dynamic          DYNAMIC         00001a1c 000a1c 0000d0 08  WA  4   0  4</span><br><span class="line"></span><br><span class="line">[20] .got              PROGBITS        00001aec 000aec 00000c 04  WA  0   0  4</span><br><span class="line"></span><br><span class="line">[21] .got.plt          PROGBITS        00001af8 000af8 000014 04  WA  0   0  4</span><br><span class="line"></span><br><span class="line">[22] .data             PROGBITS        00001b0c 000b0c 000008 00  WA  0   0  4</span><br><span class="line"></span><br><span class="line">[23] .bss              NOBITS          00001b14 000b14 000008 00  WA  0   0  4</span><br><span class="line"></span><br><span class="line">[24] .comment          PROGBITS        00000000 000b14 0000d2 00      0   0  1</span><br><span class="line"></span><br><span class="line">[25] .debug_aranges    PROGBITS        00000000 000be8 000050 00      0   0  8</span><br><span class="line"></span><br><span class="line">[26] .debug_info       PROGBITS        00000000 000c38 00011a 00      0   0  1</span><br><span class="line"></span><br><span class="line">[27] .debug_abbrev     PROGBITS        00000000 000d52 000024 00      0   0  1</span><br><span class="line"></span><br><span class="line">[28] .debug_line       PROGBITS        00000000 000d76 000102 00      0   0  1</span><br><span class="line"></span><br><span class="line">[29] .debug_ranges     PROGBITS        00000000 000e78 000040 00      0   0  8</span><br><span class="line"></span><br><span class="line">[30] .shstrtab         STRTAB          00000000 000eb8 000116 00      0   0  1</span><br><span class="line"></span><br><span class="line">[31] .symtab           SYMTAB          00000000 0014f8 0004c0 10     32  56  4</span><br><span class="line"></span><br><span class="line">[32] .strtab           STRTAB          00000000 0019b8 00031c 00      0   0  1</span><br><span class="line"></span><br><span class="line">Key to Flags:</span><br><span class="line"></span><br><span class="line">W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line"></span><br><span class="line">I (info), L (link order), G (group), x (unknown)</span><br><span class="line"></span><br><span class="line">O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><p>这里的libmy.so是自行生成的一个共享库。</p><p>2 objcopy工具</p><p>objcopy可以把一种目标文件中的内容复制到另一种类型的目标文件中.</p><p>通过objcopy的各种选项，可以对目标文件进行各种类型的操作。例如去掉可执行文件的调试信息（效果等同于strip）等等，具体需要做什么操作，要求我们对elf文件中每个部分的内容有所理解。</p><p>这里只给出一个例子：</p><p>*使用objcopy把.comment段和.note段的信息去掉：</p><p><code>$ objcopy -R .comment -R .note hello hello.min</code></p><p>这里，hello是一个可执行文件，通过”readelf -l hello”或者”readelf -S hello”命令可以知道文件中包含一个.note段和.comment段，通过这个命令，将这两个段从文件中删除，不会改变原来的文件，而是将删除了这些信息的文件存放在hello.min中。实际通过这个方法，可以减少可执行文件的大小，且不影响可执行文件的功能。</p><p>项的含义是：</p><p>-R .note -R .comment 表示移掉 .note 与 .comment 段</p><p>-O binary xyb xyb.bin 表示由xyb生成二进制文件xyb.bin</p><p>3 objdump工具</p><p>objdump是用查看目标文件或者可执行的目标文件的构成的GCC工具。</p><p>以下给出几个常用的例子：</p><p>*输出目标文件的所有段概括:</p><p><code> # objdump -h main</code></p><p>输入之后，输出信息大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">main:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line"></span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line"></span><br><span class="line">0 .interp       00000013  08048134  08048134  00000134  2**0</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">1 .note.ABI-tag 00000020  08048148  08048148  00000148  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">2 .gnu.hash     00000030  08048168  08048168  00000168  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">3 .dynsym       000000d0  08048198  08048198  00000198  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">4 .dynstr       00000183  08048268  08048268  00000268  2**0</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">5 .gnu.version  0000001a  080483ec  080483ec  000003ec  2**1</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">6 .gnu.version_r 00000060  08048408  08048408  00000408  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">7 .rel.dyn      00000010  08048468  08048468  00000468  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">8 .rel.plt      00000048  08048478  08048478  00000478  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">9 .init         00000017  080484c0  080484c0  000004c0  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"></span><br><span class="line">10 .plt          000000a0  080484d8  080484d8  000004d8  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"></span><br><span class="line">11 .text         00000238  08048580  08048580  00000580  2**4</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"></span><br><span class="line">12 .fini         0000001c  080487b8  080487b8  000007b8  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"></span><br><span class="line">13 .rodata       00000013  080487d4  080487d4  000007d4  2**2</span><br></pre></td></tr></table></figure><p>……其余内容省略……</p><p>这里,main是一个可执行文件。</p><p>*输出目标文件的符号表:</p><p><code># objdump -t main</code></p><p>输入之后，输出类似如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">main:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line"></span><br><span class="line">08048134 l    d  .interp        00000000              .interp</span><br><span class="line"></span><br><span class="line">08048148 l    d  .note.ABI-tag  00000000              .note.ABI-tag</span><br><span class="line"></span><br><span class="line">08048168 l    d  .gnu.hash      00000000              .gnu.hash</span><br><span class="line"></span><br><span class="line">08048198 l    d  .dynsym        00000000              .dynsym</span><br><span class="line"></span><br><span class="line">08048268 l    d  .dynstr        00000000              .dynstr</span><br><span class="line"></span><br><span class="line">080483ec l    d  .gnu.version   00000000              .gnu.version</span><br><span class="line"></span><br><span class="line">08048408 l    d  .gnu.version_r 00000000              .gnu.version_r</span><br><span class="line"></span><br><span class="line">08048468 l    d  .rel.dyn       00000000              .rel.dyn</span><br><span class="line"></span><br><span class="line">08048478 l    d  .rel.plt       00000000              .rel.plt</span><br><span class="line"></span><br><span class="line">080484c0 l    d  .init  00000000              .init</span><br><span class="line"></span><br><span class="line">080484d8 l    d  .plt   00000000              .plt</span><br><span class="line"></span><br><span class="line">08048580 l    d  .text  00000000              .text</span><br><span class="line"></span><br><span class="line">080487b8 l    d  .fini  00000000              .fini</span><br><span class="line"></span><br><span class="line">080487d4 l    d  .rodata        00000000              .rodata</span><br><span class="line"></span><br><span class="line">080487e8 l    d  .eh_frame_hdr  00000000              .eh_frame_hdr</span><br><span class="line"></span><br><span class="line">08048824 l    d  .eh_frame      00000000              .eh_frame</span><br><span class="line"></span><br><span class="line">08049914 l    d  .ctors 00000000              .ctors</span><br><span class="line"></span><br><span class="line">08049920 l    d  .dtors 00000000              .dtors</span><br><span class="line"></span><br><span class="line">08049928 l    d  .jcr   00000000              .jcr</span><br><span class="line"></span><br><span class="line">0804992c l    d  .dynamic       00000000              .dynamic</span><br><span class="line"></span><br><span class="line">08049a0c l    d  .got   00000000              .got</span><br><span class="line"></span><br><span class="line">08049a10 l    d  .got.plt       00000000              .got.plt</span><br><span class="line"></span><br><span class="line">08049a40 l    d  .data  00000000              .data</span><br><span class="line"></span><br><span class="line">08049a48 l    d  .bss   00000000              .bss</span><br><span class="line"></span><br><span class="line">00000000 l    d  .comment       00000000              .comment</span><br><span class="line"></span><br><span class="line">080485a4 l     F .text  00000000              call_gmon_start</span><br><span class="line"></span><br><span class="line">00000000 l    df *ABS*  00000000              crtstuff.c</span><br><span class="line"></span><br><span class="line">08049914 l     O .ctors 00000000              __CTOR_LIST__</span><br><span class="line"></span><br><span class="line">08049920 l     O .dtors 00000000              __DTOR_LIST__</span><br><span class="line"></span><br><span class="line">08049928 l     O .jcr   00000000              __JCR_LIST__</span><br><span class="line"></span><br><span class="line">08049ad4 l     O .bss   00000004              dtor_idx.5793</span><br><span class="line"></span><br><span class="line">08049ad8 l     O .bss   00000001              completed.5791</span><br><span class="line"></span><br><span class="line">080485d0 l     F .text  00000000              __do_global_dtors_aux</span><br></pre></td></tr></table></figure><p>……其余信息省略……</p><p>*以某种分类信息的形式把目标文件的数据组织（被分为几大块）输出  ：</p><p><code># objdump -x main</code></p><p>输入之后，输出信息类似如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">main:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">main</span><br><span class="line"></span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line"></span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line"></span><br><span class="line">start address 0x08048580</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Program Header:</span><br><span class="line"></span><br><span class="line">PHDR off    0x00000034 vaddr 0x08048034 paddr 0x08048034 align 2**2</span><br><span class="line"></span><br><span class="line">filesz 0x00000100 memsz 0x00000100 flags r-x</span><br><span class="line"></span><br><span class="line">INTERP off    0x00000134 vaddr 0x08048134 paddr 0x08048134 align 2**0</span><br><span class="line"></span><br><span class="line">filesz 0x00000013 memsz 0x00000013 flags r--</span><br><span class="line"></span><br><span class="line">LOAD off    0x00000000 vaddr 0x08048000 paddr 0x08048000 align 2**12</span><br><span class="line"></span><br><span class="line">filesz 0x00000914 memsz 0x00000914 flags r-x</span><br><span class="line"></span><br><span class="line">LOAD off    0x00000914 vaddr 0x08049914 paddr 0x08049914 align 2**12</span><br><span class="line"></span><br><span class="line">filesz 0x00000130 memsz 0x000001cc flags rw-</span><br><span class="line"></span><br><span class="line">DYNAMIC off    0x0000092c vaddr 0x0804992c paddr 0x0804992c align 2**2</span><br><span class="line"></span><br><span class="line">filesz 0x000000e0 memsz 0x000000e0 flags rw-</span><br><span class="line"></span><br><span class="line">NOTE off    0x00000148 vaddr 0x08048148 paddr 0x08048148 align 2**2</span><br><span class="line"></span><br><span class="line">filesz 0x00000020 memsz 0x00000020 flags r--</span><br><span class="line"></span><br><span class="line">EH_FRAME off    0x000007e8 vaddr 0x080487e8 paddr 0x080487e8 align 2**2</span><br><span class="line"></span><br><span class="line">filesz 0x0000003c memsz 0x0000003c flags r--</span><br><span class="line"></span><br><span class="line">STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**2</span><br><span class="line"></span><br><span class="line">...省略...</span><br><span class="line"></span><br><span class="line">Dynamic Section:</span><br><span class="line"></span><br><span class="line">NEEDED      libstdc++.so.6</span><br><span class="line"></span><br><span class="line">NEEDED      libm.so.6</span><br><span class="line"></span><br><span class="line">NEEDED      libgcc_s.so.1</span><br><span class="line"></span><br><span class="line">NEEDED      libc.so.6</span><br><span class="line"></span><br><span class="line">INIT        0x80484c0</span><br><span class="line"></span><br><span class="line">FINI        0x80487b8</span><br><span class="line"></span><br><span class="line">GNU_HASH    0x8048168</span><br><span class="line"></span><br><span class="line">...省略...</span><br><span class="line"></span><br><span class="line">Version References:</span><br><span class="line"></span><br><span class="line">required from libstdc++.so.6:</span><br><span class="line"></span><br><span class="line">0x056bafd3 0x00 05 CXXABI_1.3</span><br><span class="line"></span><br><span class="line">0x08922974 0x00 03 GLIBCXX_3.4</span><br><span class="line"></span><br><span class="line">required from libc.so.6:</span><br><span class="line"></span><br><span class="line">0x0d696910 0x00 04 GLIBC_2.0</span><br><span class="line"></span><br><span class="line">0x09691f73 0x00 02 GLIBC_2.1.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line"></span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line"></span><br><span class="line">0 .interp       00000013  08048134  08048134  00000134  2**0</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">1 .note.ABI-tag 00000020  08048148  08048148  00000148  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">2 .gnu.hash     00000030  08048168  08048168  00000168  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">3 .dynsym       000000d0  08048198  08048198  00000198  2**2</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">4 .dynstr       00000183  08048268  08048268  00000268  2**0</span><br><span class="line"></span><br><span class="line">CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"></span><br><span class="line">5 .gnu.version  0000001a  080483ec  080483ec  000003ec  2**1</span><br><span class="line"></span><br><span class="line">...省略...</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line"></span><br><span class="line">08048134 l    d  .interp        00000000              .interp</span><br><span class="line"></span><br><span class="line">08048148 l    d  .note.ABI-tag  00000000              .note.ABI-tag</span><br><span class="line"></span><br><span class="line">08048168 l    d  .gnu.hash      00000000              .gnu.hash</span><br><span class="line"></span><br><span class="line">08048198 l    d  .dynsym        00000000              .dynsym</span><br><span class="line"></span><br><span class="line">08048268 l    d  .dynstr        00000000              .dynstr</span><br><span class="line"></span><br><span class="line">080483ec l    d  .gnu.version   00000000              .gnu.version</span><br><span class="line"></span><br><span class="line">08048408 l    d  .gnu.version_r 00000000              .gnu.version_r</span><br><span class="line"></span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure><p>这里可知，分别显示出各个段相关的信息。</p><p>*输出指定段的信息:</p><p><code># objdump  -j .text -S  main</code></p><p>输入之后，输出类似如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">main:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">08048580 &lt;_start&gt;:</span><br><span class="line"></span><br><span class="line">8048580:       31 ed                   xor    %ebp,%ebp</span><br><span class="line"></span><br><span class="line">8048582:       5e                      pop    %esi</span><br><span class="line"></span><br><span class="line">8048583:       89 e1                   mov    %esp,%ecx</span><br><span class="line"></span><br><span class="line">8048585:       83 e4 f0                and    $0xfffffff0,%esp</span><br><span class="line"></span><br><span class="line">8048588:       50                      push   %eax</span><br><span class="line"></span><br><span class="line">8048589:       54                      push   %esp</span><br><span class="line"></span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure><p>这里，反汇编会用到类似的命令。</p><p>4 nm工具</p><p>这个命令可以用来查看库中的符号。</p><p>nm列出的符号有很多，常见的有三种，一种是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；一种是库中定义的函数，用T表示，这是最常见的；另外一种是所谓的“弱态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。</p><p>*假设开发者希望知道hello库中是否定义了 printf():</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$nm libhello.so |grep printf</span><br><span class="line"></span><br><span class="line">U printf</span><br></pre></td></tr></table></figure><p>U表示符号printf被引用，但是并没有在函数内定义，由此可以推断，要正常使用hello库，必须有其它库支持。</p><p>5 ldd工具</p><p>ldd命令可以用来查看一个可执行文件或者库依赖哪些其他的文件。</p><p>*使用ldd命令查看hello依赖于哪些库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ldd hello</span><br><span class="line"></span><br><span class="line">libc.so.6=&gt;/lib/libc.so.6(0x400la000)</span><br><span class="line"></span><br><span class="line">/lib/ld-linux.so.2=&gt;/lib/ld-linux.so.2 (0x40000000)</span><br></pre></td></tr></table></figure><p>这里，结合nm，从上面的结果可以继续查看printf最终在哪里被定义.</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="A-readelf使用"><a href="#A-readelf使用" class="headerlink" title="A. readelf使用"></a>A. readelf使用</h3><p>readelf -S 查看节表</p><p>readelf -s 查看符号表</p><p>readelf -h 查看elf文件头</p><p>readelf -l 程序头</p><p>readelf -n 查看调试信息表</p><p>readelf -w 查看debug相关的表 如wi是debug_info,wl是debug_line</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>参考资料</title>
      <link href="/2022/10/14/01%20OS/Linux/Perf/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"/>
      <url>/2022/10/14/01%20OS/Linux/Perf/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="簡介 perf_events 與 Call Graph.html">簡介 perf_events 與 Call Graph.html</a></li><li><a href="Urs_Fassler_report.pdf">perf file format</a><br><a href="https://blog.csdn.net/Rong_Toa/article/details/117040529">https://blog.csdn.net/Rong_Toa/article/details/117040529</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译、链接和装载</title>
      <link href="/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/"/>
      <url>/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/</url>
      
        <content type="html"><![CDATA[<p><a href="Linux下编译、链接和装载.html">Linux下编译、链接和装载</a><br>各种火焰图 <a href="https://zhuanlan.zhihu.com/p/54276509?from=singlemessage&amp;utm_id=0">https://zhuanlan.zhihu.com/p/54276509?from=singlemessage&amp;utm_id=0</a></p><p>这些tracepint的对应的sysfs节点在&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events目录下<br>–symfs&#x3D;<directory>  指定系统符号表路径</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剥离与导回符号表及调试信息</title>
      <link href="/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/elfremovesymbol/"/>
      <url>/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/elfremovesymbol/</url>
      
        <content type="html"><![CDATA[<h1 id="使用strip-eu-strip-objcopy等剥离与导回符号表及调试信息-易学教程"><a href="#使用strip-eu-strip-objcopy等剥离与导回符号表及调试信息-易学教程" class="headerlink" title="使用strip, eu-strip, objcopy等剥离与导回符号表及调试信息 | 易学教程"></a><a href="https://97id.com/2021/09/%E4%BD%BF%E7%94%A8strip-eu-strip-objcopy%E7%AD%89%E5%89%A5%E7%A6%BB%E4%B8%8E%E5%AF%BC%E5%9B%9E%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%8F%8A%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF-%E6%98%93%E5%AD%A6%E6%95%99/">使用strip, eu-strip, objcopy等剥离与导回符号表及调试信息 | 易学教程</a></h1><h1 id="1-符号表信息和调试信息"><a href="#1-符号表信息和调试信息" class="headerlink" title="1.符号表信息和调试信息"></a>1.符号表信息和调试信息</h1><p>符号表信息（symbols）和调试信息（debug info）是由不同段区分的。<br>使用 readelf -S binfile 可以查看ELF文件的所有段。</p><p>调试信息相关的段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;# readelf -S a.out | grep debug</span><br><span class="line"></span><br><span class="line">  [27] .debug_aranges    PROGBITS         0000000000000000  000016d0</span><br><span class="line"></span><br><span class="line">  [28] .debug_info       PROGBITS         0000000000000000  00001700</span><br><span class="line"></span><br><span class="line">  [29] .debug_abbrev     PROGBITS         0000000000000000  00001a0f</span><br><span class="line"></span><br><span class="line">  [30] .debug_line       PROGBITS         0000000000000000  00001adb</span><br><span class="line"></span><br><span class="line">  [31] .debug_str        PROGBITS         0000000000000000  00001bd2</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><p>符号表相关的段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;# readelf -S a.out | grep tab</span><br><span class="line"></span><br><span class="line">  [32] .symtab           SYMTAB           0000000000000000  00001e18</span><br><span class="line"></span><br><span class="line">  [33] .strtab           STRTAB           0000000000000000  00002670</span><br><span class="line"></span><br><span class="line">  [34] .shstrtab         STRTAB           0000000000000000  00002a8f</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><p>注： 下文中提及的符号表相关段将不包括 .shstrtab 段，因其不会被strip或eu-strip移除。</p><p>RedHat的system libraries仍保留symbols；这使得它的库文件稍大，但调试方便；<br>Debian的system libraries不保留symbols，而是将symbols和调试信息都保存在.debug文件中; 这样, 系统库更小，但调试时需要拥有这些.debug文件。</p><h1 id="2-strip命令"><a href="#2-strip命令" class="headerlink" title="2. strip命令"></a>2. strip命令</h1><p>strip &lt;option[s]&gt; &lt;in-file[s]&gt;</p><p>常用选项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;-s --strip-all</span><br><span class="line"></span><br><span class="line">    Remove all symbol and relocation information</span><br><span class="line"></span><br><span class="line">    注： 删除其他符号表段和调试信息段，但不删除 .shstrtab 段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-g -S -d --strip-debug</span><br><span class="line"></span><br><span class="line">    Remove all debugging symbols &amp; sections</span><br><span class="line"></span><br><span class="line">    这几个选项的功能是一样，即移除上述5个&quot;.debug_&quot;开头的调试信息段，仍会保留符号表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--only-keep-debug</span><br><span class="line"></span><br><span class="line">    Strip everything but the debug information</span><br><span class="line"></span><br><span class="line">    注：段的总数量没有减少，但文件大小减少了；对比了&quot;readelf -S&quot;输出中的&quot;offset&quot;段，发现其中前面若干段的offset都没有变化，即size为0了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-R --remove-section=&lt;name&gt;</span><br><span class="line"></span><br><span class="line">    Also remove section &lt;name&gt; from the output</span><br><span class="line"></span><br><span class="line">    移除指定段，比如</span><br><span class="line"></span><br><span class="line">    strip --remove-section=.symtab a.out</span><br><span class="line"></span><br><span class="line">    strip --remove-section=.strtab a.out</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><p>不输入任何选项的默认行为是”-s”,即”–strip-all”.</p><h1 id="3-eu-strip-命令"><a href="#3-eu-strip-命令" class="headerlink" title="3. eu-strip 命令"></a>3. eu-strip 命令</h1><p>功能： 可将符号表和调试信息都导入指定文件中，以减小原二进制文件的大小。<br>至于如何将导出的文件告知gdb，请参见下面的第5节”objcopy命令”</p><p>使用举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;eu-strip a.out -f a.debug</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><p>以上命令将a.out中的符号表段和调试信息段都移出到 a.debug 文件中。这样，a.out的size会减小很多。<br>而此时，a.out 中会多一个 <strong>.gnu_debuglink</strong> 段，它是用来保存符号表位置的。<br>之后，再用gdb去打开并运行 a.out 时，gdb还可以找到 a.debug 这样的符号表及调试信息文件。</p><p>另注： CentOS安装eu-strip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;yum install elfutils</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><h1 id="4-gdb-寻找符号表和调试信息文件"><a href="#4-gdb-寻找符号表和调试信息文件" class="headerlink" title="4. gdb 寻找符号表和调试信息文件"></a>4. gdb 寻找符号表和调试信息文件</h1><p>用 gdb 查看 coredump 的时候，或者用 gdb 去运行上述被剥离了符号表和调试信息的二进制文件时，gdb会去自动搜索符号表。<br>gdb 会去查找当前目录、gdb默认的搜索路径 &#x2F;usr&#x2F;lib&#x2F;debug 、 以及 &#x2F;usr&#x2F;lib&#x2F;debug 下的子路径。具体顺序和具体子路径，请参阅参考文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;(gdb) show debug-file-directory</span><br><span class="line"></span><br><span class="line">The directory where separate debug symbols are searched for is &quot;/usr/lib/debug&quot;.</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><p>如果符号表文件既不在当前目录，也不在 &#x2F;usr&#x2F;lib&#x2F;debug, 那么可以使用 命令告诉gdb去哪里找到符号表，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;(gdb) symbol-file /root/test.sym</span><br><span class="line"></span><br><span class="line">(gdb) bt</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><h1 id="5-objcopy-命令移除和添加符号表及调试信息"><a href="#5-objcopy-命令移除和添加符号表及调试信息" class="headerlink" title="5. objcopy 命令移除和添加符号表及调试信息"></a>5. objcopy 命令移除和添加符号表及调试信息</h1><ol><li>删除指定的section</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;    objcopy -R .comment -R .note.ABI-tag</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><ol><li>移除和添加符号表及调试信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;    gcc -g -o test test.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # test.debug 将包含调试信息和符号表； 而test将只包含调试信息</span><br><span class="line"></span><br><span class="line">    objcopy --only-keep-debug test test.debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 从test文件里剥离debug段</span><br><span class="line"></span><br><span class="line">    objcopy --strip-debug test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 更彻底地，上面这句可以换成下面这句以移除所有的debug信息和符号表</span><br><span class="line"></span><br><span class="line">    strip -s test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 在二进制文件 test 中添加 .gnu_debuglink 段以指向符号表和调试信息文件</span><br><span class="line"></span><br><span class="line">    objcopy --add-gnu-debuglink=test.debug test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # objdump 命令可以查看指定的section</span><br><span class="line"></span><br><span class="line">    objdump -s -j .gnu_debuglink test</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><h1 id="6-使用链接器ld去除符号表"><a href="#6-使用链接器ld去除符号表" class="headerlink" title="6. 使用链接器ld去除符号表"></a>6. 使用链接器ld去除符号表</h1><p>动态链接库是ELF(Executable and Linkable Format)文件的一种,其中包含了2个符号表：</p><ul><li><p>.symtab 包含大量的信息（包括全局符号global symbols）</p></li><li><p>.dynsym 只保留.symtab中的全局符号</p><p>.dynsym 是 .symtab 的子集；strip命令会去掉ELF文件中.symtab,但不会去掉.dynsym</p></li></ul><p>使用ld 的 -s 和 -S 选项可以在链接的时候去除符号表。-s去除所有符号表信息；-S去除调试符号信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;-s</span><br><span class="line"></span><br><span class="line">--strip-all</span><br><span class="line"></span><br><span class="line">    Omit all symbol information from the output file.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-S</span><br><span class="line"></span><br><span class="line">--strip-debug</span><br><span class="line"></span><br><span class="line">    Omit debugger symbol information (but not all symbols) from the output file.</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><h1 id="7-gcc-静态编译"><a href="#7-gcc-静态编译" class="headerlink" title="7. gcc 静态编译"></a>7. gcc 静态编译</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;# 让可执行文件没有.dynsym动态链接表；在支持动态链接的系统上，阻止连接共享库。该选项在其它系统上无效。</span><br><span class="line"></span><br><span class="line">gcc -static</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 让可执行文件没有.dynstr动态链接字符表；不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器。</span><br><span class="line"></span><br><span class="line">gcc -nostdlib</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sed</title>
      <link href="/2022/10/14/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sed/"/>
      <url>/2022/10/14/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sed/</url>
      
        <content type="html"><![CDATA[<h1 id="sed-字符串替换"><a href="#sed-字符串替换" class="headerlink" title="sed 字符串替换"></a>sed 字符串替换</h1><ol><li><p>sed替换的基本语法为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/原字符串/替换字符串/&#x27;</span><br></pre></td></tr></table></figure><p>单引号里面,s表示替换,三根斜线中间是替换的样式,特殊字符需要使用反斜线”\”进行转义。</p></li><li><p>单引号” ‘ ’”是没有办法用反斜线”\”转义的,这时候只要把命令中的单引号改为双引号就行了,格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 要处理的字符包含单引号</span><br><span class="line">sed &quot;s/原字符串包含&#x27;/替换字符串包含&#x27;/&quot;</span><br></pre></td></tr></table></figure></li><li><p>命令中的三根斜线分隔符可以换成别的符号,有时候替换目录字符串的时候有较多斜线，这个时候换成其它的分割符是较为方便,只需要紧跟s定义即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将分隔符换成问号”?”:</span><br><span class="line">sed &#x27;s?原字符串?替换字符串?&#x27;</span><br></pre></td></tr></table></figure></li><li><p>可以在末尾加g替换每一个匹配的关键字,否则只替换每行的第一个,例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 替换所有匹配关键字</span><br><span class="line">sed &#x27;s/原字符串/替换字符串/g&#x27;</span><br></pre></td></tr></table></figure></li><li><p>一些特殊字符的使用</p></li></ol><p>　　”^”表示行首</p><p>　　”$”符号如果在引号中表示行尾，但是在引号外却表示末行(最后一行)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 注意这里的 &quot; &amp; &quot; 符号，如果没有 “&amp;”，就会直接将匹配到的字符串替换掉</span><br><span class="line">sed &#x27;s/^/添加的头部&amp;/g&#x27; 　　　　 #在所有行首添加</span><br><span class="line">sed &#x27;s/$/&amp;添加的尾部/g&#x27; 　　　　 #在所有行末添加</span><br><span class="line">sed &#x27;2s/原字符串/替换字符串/g&#x27;　 #替换第2行</span><br><span class="line">sed &#x27;$s/原字符串/替换字符串/g&#x27;   #替换最后一行</span><br><span class="line">sed &#x27;2,5s/原字符串/替换字符串/g&#x27; #替换2到5行</span><br><span class="line">sed &#x27;2,$s/原字符串/替换字符串/g&#x27; #替换2到最后一行</span><br></pre></td></tr></table></figure><ol start="6"><li>批量替换字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/查找字段/替换字段/g&quot; `grep 查找字段 -rl 路径`</span><br><span class="line">sed -i &quot;s/oldstring/newstring/g&quot; `grep oldstring -rl yourdir</span><br></pre></td></tr></table></figure></li><li>sed处理过的输出是直接输出到屏幕上的,使用参数”i”直接在文件中替换。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 替换文件中的所有匹配项</span><br><span class="line">sed -i &#x27;s/原字符串/替换字符串/g&#x27; filename</span><br></pre></td></tr></table></figure><ol start="8"><li>多个替换可以在同一条命令中执行,用分号”;”分隔，其格式为:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 同时执行两个替换规则</span><br><span class="line">sed &#x27;s/^/添加的头部&amp;/g；s/$/&amp;添加的尾部/g&#x27;</span><br></pre></td></tr></table></figure></li></ol><h1 id="运用-sed-命令高效地删除文件的特定行"><a href="#运用-sed-命令高效地删除文件的特定行" class="headerlink" title="运用 sed 命令高效地删除文件的特定行"></a>运用 sed 命令高效地删除文件的特定行</h1><p>正常来说，我们想要删除文件中的某些行内容，一般都是先打开这个文件，然后找到要删除的内容，再然后选中这些行并按删除键进行删除，这在数据量很少时是没有问题的。但是，一旦文件中的行数据非常多，而且数据冗杂的情况下，你还要用上面的方法去做的话就很恐怖了。为此，今天这篇文章将带大家一起学习运用 sed 命令行工具，即使在数据多而杂的情况下也能高效而优雅地删除文件中的特定行内容。</p><p>sed 是 Stream Editor 的简写，它用于在 Linux 中进行基本的文本转换，是文件操作的一个重要命令，所以，我们也可以用它来实现文本的删除操作。</p><p>下面是一些 sed 命令的使用示例，覆盖了大多数的使用场景，由浅入深地帮助你学习 sed 命令，让你轻松地实现高效删除文件的特定行内容。</p><p>首先我们准备一个演示文件 sed-demo.txt 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># cat sed-demo.txt</span><br><span class="line"></span><br><span class="line">1 Linux Operating System</span><br><span class="line">2 Unix Operating System</span><br><span class="line">3 RHEL</span><br><span class="line">4 Red Hat</span><br><span class="line">5 Fedora</span><br><span class="line">6 Arch Linux</span><br><span class="line">7 CentOS</span><br><span class="line">8 Debian</span><br><span class="line">9 Ubuntu</span><br><span class="line">10 openSUSE</span><br></pre></td></tr></table></figure><p>然后我们就可以运用 sed 命令进行实验了。</p><p>注意：-i 表示直接进行文件操作，而不在终端上显示结果。因为是演示所以这里不带 -i 选项，我们在实际中请带上 -i 选项。</p><ol><li>删除某一行<br>首先，我们先从删除某一行开始，比如删除第一行、最后一行，实际也就是第 N 行嘛。</li></ol><p>删除第 N 行的命令格式：</p><p>sed ‘Nd’ file<br>我们来删除第一行试试：</p><h1 id="sed-‘1d’-sed-demo-txt"><a href="#sed-‘1d’-sed-demo-txt" class="headerlink" title="sed ‘1d’ sed-demo.txt"></a>sed ‘1d’ sed-demo.txt</h1><p>After deletion:<br>2 Unix Operating System<br>3 RHEL<br>4 Red Hat<br>5 Fedora<br>6 Arch Linux<br>7 CentOS<br>8 Debian<br>9 Ubuntu<br>10 openSUSE<br>很简单是吧？这里就不多作解释了，你想要删除第几行的内容只需要把命令中的 1 替换一下就 ok 了。</p><p>那问题来了，最后一行用什么数字表示呢？这里给大家一个小提示，可以用美元符号 $ 表示最后，所以删除最后一行的命令可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed &#x27;$d&#x27; sed-demo.txt</span><br></pre></td></tr></table></figure><p>After deletion:<br>1 Linux Operating System<br>2 Unix Operating System<br>3 RHEL<br>4 Red Hat<br>5 Fedora<br>6 Arch Linux<br>7 CentOS<br>8 Debian<br>9 Ubuntu<br>2. 删除某些行<br>sed 命令可以删除连续又或者不连续的行内容。</p><p>删除连续的行，例如删除从 5 到 7 行 的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed &#x27;5,7d&#x27; sed-demo.txt</span><br></pre></td></tr></table></figure><p>After deletion:<br>1 Linux Operating System<br>2 Unix Operating System<br>3 RHEL<br>4 Red Hat<br>8 Debian<br>9 Ubuntu<br>10 openSUSE<br>删除不连续的行，例如删除第 1 、第 5 、第 9 和最后一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed &#x27;1d;5d;9d;$d&#x27; sed-demo.txt</span><br></pre></td></tr></table></figure><p>After deletion:</p><p>2 Unix Operating System<br>3 RHEL<br>4 Red Hat<br>6 Arch Linux<br>7 CentOS<br>8 Debian<br>另外，它还可以配合逻辑非 ! 使用，比如删除第 3到 6 行以外的其他行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed &#x27;3,6!d&#x27; sed-demo.txt</span><br></pre></td></tr></table></figure><p>After deletion:</p><p>3 RHEL<br>4 Red Hat<br>5 Fedora<br>6 Arch Linux<br>3. 删除空白行</p><p>sed 还支持删除文件的空白行，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed &#x27;/^$/d&#x27; sed-demo.txt</span><br></pre></td></tr></table></figure><p>After deletion:</p><p>1 Linux Operating System<br>2 Unix Operating System<br>3 RHEL<br>4 Red Hat<br>5 Fedora<br>6 Arch Linux<br>7 CentOS<br>8 Debian<br>9 Ubuntu<br>10 openSUSE<br>提示：这里两个斜杠 &#x2F; &#x2F; 内的表达式起到了文本匹配的作用，大家可以参考正则表达式的使用方法。下面将列举一些常用的方法来加深大家的学习。</p><ol start="4"><li>删除包含特定字符的行<br>假设我们想要删除示例文件中的包含 System 这个单词的行内容，我们可以用 &#x2F;System&#x2F;，它表示有出现 System 这个字符串就进行匹配，具体的命令如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed &#x27;/System/d&#x27; sed-demo.txt</span><br></pre></td></tr></table></figure>After deletion:</li></ol><p>3 RHEL<br>4 Red Hat<br>5 Fedora<br>6 Arch Linux<br>7 CentOS<br>8 Debian<br>9 Ubuntu<br>10 openSUSE<br>不仅如此，我们还可以加上一下逻辑条件，比方说下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed &#x27;/System\|Linux/d&#x27; sed-demo.txt</span><br></pre></td></tr></table></figure><p>After deletion:</p><p>3 RHEL<br>4 Red Hat<br>5 Fedora<br>7 CentOS<br>8 Debian<br>9 Ubuntu<br>10 openSUSE<br>反斜杠 \ 代表逻辑或，上述命令的意思是文本中有 System 或 Linux 的行都要进行删除。</p><ol start="5"><li>删除特定字符开头的行</li></ol><p>首先，我们创建另一个示例文件 sed-demo-1.txt 进行更好地演示，其内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat sed-demo-1.txt</span><br></pre></td></tr></table></figure><p>After deletion:<br>Linux Operating System<br>Unix Operating System<br>RHEL<br>Red Hat<br>Fedora<br>debian<br>ubuntu<br>Arch Linux - 1<br>2 - Manjaro<br>3 4 5 6<br>上面也已经提到过，$ 号可以理解为结尾，那么有没有字符可以代表开头呢？答案是有的，这里我们可以用 ^ 号代表开头。</p><p>那么，我们想要删除以某一个字符开头的行时，比如说删除以 R 开头的行，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed &#x27;/^R/d&#x27; sed-demo-1.txt</span><br></pre></td></tr></table></figure><p>After deletion:<br>Linux Operating System<br>Unix Operating System<br>Fedora<br>debian<br>ubuntu<br>Arch Linux - 1<br>2 - Manjaro<br>3 4 5 6<br>那么问题来了，比如我想删除以 R 或者 F 开头的行，那我是不是要执行两次命令呢？如果是有更多岂不是要执行多次命令？这里它有一个简单的写法，你只要把这些字符写在一对中括号 [] 里就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed &#x27;/^[RF]/d&#x27; sed-demo-1.txt</span><br></pre></td></tr></table></figure><p>After deletion:<br>Linux Operating System<br>Unix Operating System<br>debian<br>ubuntu<br>Arch Linux - 1<br>2 - Manjaro<br>3 4 5 6<br>上面命令的作用是 删除以 R 或者 F 开头的行。</p><ol start="6"><li>删除特定字符结尾的行</li></ol><p>同上面一个道理，删除以某一个字符结尾的行，比方说删除以 m 结尾的行，我们可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed &#x27;/m$/d&#x27; sed-demo.txt</span><br></pre></td></tr></table></figure><p>After deletion:<br>3 RHEL<br>4 Red Hat<br>5 Fedora<br>6 Arch Linux<br>7 CentOS<br>8 Debian<br>9 Ubuntu<br>10 openSUSE<br>删除以 x 或 m 结尾的行可以这样写：</p><h1 id="sed-‘-x2F-xm-x2F-d’-sed-demo-txt"><a href="#sed-‘-x2F-xm-x2F-d’-sed-demo-txt" class="headerlink" title="sed ‘&#x2F;[xm]$&#x2F;d’ sed-demo.txt"></a>sed ‘&#x2F;[xm]$&#x2F;d’ sed-demo.txt</h1><p>After deletion:</p><p>3 RHEL<br>4 Red Hat<br>5 Fedora<br>7 CentOS<br>8 Debian<br>9 Ubuntu<br>10 openSUSE<br>7. 删除以大写字母开头的行</p><p>这里问题又来了，我想要删除所有以大写字母开头的行呢？按照上面的做法是不是要将 A 到 Z 这 26 个字母都写进 [ ] 里呢？ 其实我们大可不必这样做，在 A 和 Z 中间加个 - 就可以了：</p><h1 id="sed-‘-x2F-A-Z-x2F-d’-sed-demo-1-txt"><a href="#sed-‘-x2F-A-Z-x2F-d’-sed-demo-1-txt" class="headerlink" title="sed ‘&#x2F;^[A-Z]&#x2F;d’ sed-demo-1.txt"></a>sed ‘&#x2F;^[A-Z]&#x2F;d’ sed-demo-1.txt</h1><p>After deletion:<br>debian<br>ubuntu<br>2 - Manjaro<br>3 4 5 6<br>机智的你看到这里肯定会想到其他类似的用法的了，不妨看看下面是否有你想到的命令吧。</p><ol start="8"><li>删除包含字母字符的行</li></ol><h1 id="sed-‘-x2F-A-Za-z-x2F-d’-sed-demo-1-txt"><a href="#sed-‘-x2F-A-Za-z-x2F-d’-sed-demo-1-txt" class="headerlink" title="sed ‘&#x2F;[A-Za-z]&#x2F;d’ sed-demo-1.txt"></a>sed ‘&#x2F;[A-Za-z]&#x2F;d’ sed-demo-1.txt</h1><p>After deletion:<br>3 4 5 6<br>9. 删除包含数字的行</p><h1 id="sed-‘-x2F-0-9-x2F-d’-sed-demo-1-txt"><a href="#sed-‘-x2F-0-9-x2F-d’-sed-demo-1-txt" class="headerlink" title="sed ‘&#x2F;[0-9]&#x2F;d’ sed-demo-1.txt"></a>sed ‘&#x2F;[0-9]&#x2F;d’ sed-demo-1.txt</h1><p>After deletion:</p><p>Linux Operating System<br>Unix Operating System<br>RHEL<br>Red Hat<br>Fedora<br>debian<br>ubuntu<br>另外，通过这个例子，我们可以加上 ^ 和 $ 更好地看到他们三个之间的区别：</p><h1 id="sed-‘-x2F-0-9-x2F-d’-sed-demo-1-txt-1"><a href="#sed-‘-x2F-0-9-x2F-d’-sed-demo-1-txt-1" class="headerlink" title="sed ‘&#x2F;^[0-9]&#x2F;d’ sed-demo-1.txt"></a>sed ‘&#x2F;^[0-9]&#x2F;d’ sed-demo-1.txt</h1><p>After deletion:</p><p>Linux Operating System<br>Unix Operating System<br>RHEL<br>Red Hat<br>Fedora<br>debian<br>ubuntu<br>Arch Linux - 1</p><h1 id="sed-‘-x2F-0-9-x2F-d’-sed-demo-1-txt-2"><a href="#sed-‘-x2F-0-9-x2F-d’-sed-demo-1-txt-2" class="headerlink" title="sed ‘&#x2F;[0-9]$&#x2F;d’ sed-demo-1.txt"></a>sed ‘&#x2F;[0-9]$&#x2F;d’ sed-demo-1.txt</h1><p>After deletion:</p><p>Linux Operating System<br>Unix Operating System<br>RHEL<br>Red Hat<br>Fedora<br>debian<br>ubuntu<br>2 - Manjaro<br>10. 其他更多</p><p>实际上，我们要删除的文件内容是更为具体的，简单的条件是满足不了我们的需求的，所以，sed 也支持更复杂的条件组合。比方说我要指定删除在 1 到 6 行内有 Linux 这个词的内容，那么：</p><h1 id="sed-‘1-6-x2F-Linux-x2F-d-’-sed-demo-txt"><a href="#sed-‘1-6-x2F-Linux-x2F-d-’-sed-demo-txt" class="headerlink" title="sed ‘1,6{&#x2F;Linux&#x2F;d;}’ sed-demo.txt"></a>sed ‘1,6{&#x2F;Linux&#x2F;d;}’ sed-demo.txt</h1><p>After deletion:<br>2 Unix Operating System<br>3 RHEL<br>4 Red Hat<br>5 Fedora<br>7 CentOS<br>8 Debian<br>9 Ubuntu<br>10 openSUSE<br>删除包含 System 以及其下一行的内容：</p><h1 id="sed-‘-x2F-System-x2F-N-d-’-sed-demo-txt"><a href="#sed-‘-x2F-System-x2F-N-d-’-sed-demo-txt" class="headerlink" title="sed ‘&#x2F;System&#x2F;{N;d;}’ sed-demo.txt"></a>sed ‘&#x2F;System&#x2F;{N;d;}’ sed-demo.txt</h1><p>After deletion:<br>3 RHEL<br>4 Red Hat<br>5 Fedora<br>6 Arch Linux<br>7 CentOS<br>8 Debian<br>9 Ubuntu<br>10 openSUSE</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Npm</title>
      <link href="/2022/10/14/50%20soft/Nodejs/npm/"/>
      <url>/2022/10/14/50%20soft/Nodejs/npm/</url>
      
        <content type="html"><![CDATA[<h1 id="npm设置和取消代理的方法"><a href="#npm设置和取消代理的方法" class="headerlink" title="npm设置和取消代理的方法"></a>npm设置和取消代理的方法</h1><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set proxy=http://127.0.0.1:8087</span><br><span class="line">npm config set registry=http://registry.npmjs.org</span><br></pre></td></tr></table></figure><h2 id="关于https"><a href="#关于https" class="headerlink" title="关于https"></a>关于https</h2><p>经过上面设置使用了http开头的源，因此不需要设https_proxy了，否则还要增加一句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set https-proxy http://server:port</span><br></pre></td></tr></table></figure><h2 id="代理用户名和密码"><a href="#代理用户名和密码" class="headerlink" title="代理用户名和密码"></a>代理用户名和密码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set proxy http://username:password@server:port</span><br><span class="line">npm confit set https-proxy http://username:password@server:port</span><br></pre></td></tr></table></figure><h2 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure><h2 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h2><h3 id="by-config-command"><a href="#by-config-command" class="headerlink" title="by config command"></a>by config command</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.cnpmjs.org</span><br><span class="line">npm info underscore （如果上面配置正确这个命令会有字符串response）</span><br></pre></td></tr></table></figure><h3 id="命令行指定"><a href="#命令行指定" class="headerlink" title="命令行指定"></a>命令行指定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry http://registry.cnpmjs.org info underscore</span><br></pre></td></tr></table></figure><h3 id="编辑-x2F-npmrc-加入下面内容"><a href="#编辑-x2F-npmrc-加入下面内容" class="headerlink" title="编辑 ~&#x2F;.npmrc 加入下面内容"></a>编辑 ~&#x2F;.npmrc 加入下面内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = http://registry.cnpmjs.org</span><br></pre></td></tr></table></figure><h2 id="使用nrm快速切换npm源"><a href="#使用nrm快速切换npm源" class="headerlink" title="使用nrm快速切换npm源"></a>使用nrm快速切换npm源</h2><p>nrm 是一个 NPM 源管理器，允许你快速地在如下 NPM 源间切换：</p><p>列表项目</p><ul><li>npm</li><li>cnpm</li><li>strongloop</li><li>enropean</li><li>australia</li><li>nodejitsu</li><li>taobao</li></ul><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>sudo npm install -g nrm</p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>列出可用的源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~  nrm ls</span><br><span class="line">npm ---- https://registry.npmjs.org/</span><br><span class="line">cnpm --- http://r.cnpmjs.org/</span><br><span class="line">taobao - http://registry.npm.taobao.org/</span><br><span class="line">eu ----- http://registry.npmjs.eu/</span><br><span class="line">au ----- http://registry.npmjs.org.au/</span><br><span class="line">sl ----- http://npm.strongloop.com/</span><br><span class="line">nj ----- https://registry.nodejitsu.com/</span><br><span class="line">pt ----- http://registry.npmjs.pt/</span><br></pre></td></tr></table></figure><p>切换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~  nrm use taobao</span><br><span class="line">   Registry has been set to: http://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><p>增加源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm add &lt;registry&gt; &lt;url&gt; [home]</span><br></pre></td></tr></table></figure><p>删除源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm del &lt;registry&gt;</span><br></pre></td></tr></table></figure><p>测试速度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm test</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gunicorn的使用手册</title>
      <link href="/2022/10/14/12%20Python/Gunicorn_manual/"/>
      <url>/2022/10/14/12%20Python/Gunicorn_manual/</url>
      
        <content type="html"><![CDATA[<h1 id="Gunicorn的使用手册"><a href="#Gunicorn的使用手册" class="headerlink" title="Gunicorn的使用手册"></a>Gunicorn的使用手册</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>目录Gunicorn是什么Gunicorn的安装安装查看Gunicorn的版本运行GunicornGunicorn的配置参数说明[OPTIONS]1.1 配置文件config1.2 Debugging1.3 Logging1.4 指定进程名称1.5 客户端地址（server socket）1.6 工作进程数（Worker Processes）1.7 工作模式（worker_class）1.8线程数(threads)1.9 工作线程连接数（worker_connections）1.10 最大请求数（max_requests）1.11 超时设置（timeout）1.12 连接的存活时间（keepalive）工作模式的补充说明使用gevent模式会出现一些兼容性问题。性能实践总结粉丝专属福利参考</p><h2 id="Gunicorn是什么"><a href="#Gunicorn是什么" class="headerlink" title="Gunicorn是什么"></a>Gunicorn是什么</h2><p>Gunicorn 是一个 Python 的 WSGI HTTP 服务器。它所在的位置通常是在反向代理（如 Nginx）或者 负载均衡（如 AWS ELB）和一个 web 应用（比如 Django 或者 Flask）之间。它是一个移植自Ruby的Unicorn项目的pre-fork worker模型，即支持eventlet也支持greenlet。<br>如果对Flask框架还有不清楚的地方，可以查看本文<a href="https://feige.blog.csdn.net/article/details/112263189">一分钟学会Flask框架的安装与快速使用</a><br>Gunicorn启动项目之后一定会有一个主进程Master和一个或者多个工作进程。工作进程的数量可以指定。工作进程是实际处理请求的进程。主进程是维护服务器的运行。<br><img src="./b96c26026d4c42dfbe680034012ee5fe.png"></p><h2 id="Gunicorn的安装"><a href="#Gunicorn的安装" class="headerlink" title="Gunicorn的安装"></a>Gunicorn的安装</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装最新版本的gunicorn</span></span><br><span class="line">pip install gunicorn</span><br><span class="line"><span class="comment">#安装指定版本的gunicorn</span></span><br><span class="line">pip install gunicorn==19.9.0</span><br><span class="line"><span class="comment">#异步模式</span></span><br><span class="line">pip install gevent==1.4.0</span><br></pre></td></tr></table></figure><h3 id="查看Gunicorn的版本"><a href="#查看Gunicorn的版本" class="headerlink" title="查看Gunicorn的版本"></a>查看Gunicorn的版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show gunicorn</span><br></pre></td></tr></table></figure><h2 id="运行Gunicorn"><a href="#运行Gunicorn" class="headerlink" title="运行Gunicorn"></a>运行Gunicorn</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn [OPTIONS] $(MODULE_NAME):$(VARIABLE_NAME)</span><br></pre></td></tr></table></figure><p><code>$(MODULE_NAME):$(VARIABLE_NAME)</code> 表示要启动的WSGI_app。<br>其中<strong>MODULE_NAME</strong>对应的是python文件名，<strong>VARIABLE_NAME</strong>对应web应用实例。<br>举个🌰吧！！！这里定义一个名为manage.py 文件，在其内部创建Flask应用。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#manage.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>():</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">app = create_app()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5001</span>)</span><br></pre></td></tr></table></figure><p>那么，用gunicorn启动该Flask应用的命令就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --workers=2 manage:app</span><br></pre></td></tr></table></figure><p>其中workers用于指定工作进程数。<br>当然也可以通过直接调用create_app方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#manage.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>():</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure><p>那么，用gunicorn命令直接调用create_app方法就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --workers=2 manage:create_app()</span><br></pre></td></tr></table></figure><h2 id="Gunicorn的配置参数说明-OPTIONS"><a href="#Gunicorn的配置参数说明-OPTIONS" class="headerlink" title="Gunicorn的配置参数说明[OPTIONS]"></a>Gunicorn的配置参数说明[OPTIONS]</h2><p>在实际开发中一般情况下都会用一个单独的python配置文件来配置gunicorn的启动参数。gunicorn的参数有很多，这里就重点介绍一下在实际开发中经常需要用到的一些配置。</p><h3 id="1-1-配置文件config"><a href="#1-1-配置文件config" class="headerlink" title="1.1 配置文件config"></a>1.1 配置文件config</h3><p><strong>命令是：<code>-c CONFIG</code> 或<code>--config=CONFIG</code></strong><br>这个命令是指定Gunicorn的配置文件，配置文件的作用就是将我们需要的配置写到该配置文件中。<br>默认的配置文件的名称是 <code>./gunicorn.conf.py</code>，一般是将该配置文件放在项目的根目录下。就像下面这样<br><img src="./2c9b0ed1c9194ff19e6206bda4a99271.png"><br>这里设置gunicorn绑定的IP地址和端口号，worker数量以及线程数。<br>启动该项目的命令是: <code>gunicorn -c gunicorn.conf.py manage:app</code>。<br><img src="./7ec43c85af384826928b268175b1f2bc.png"></p><h3 id="1-2-Debugging"><a href="#1-2-Debugging" class="headerlink" title="1.2 Debugging"></a>1.2 Debugging</h3><p><strong>命令 <code>--reload=True</code></strong>,或者在gunicorn.conf.py 文件中加上<code>reload=True</code> 配置。<br>这样的话，当代码变动时gunicorn就可以重启了。</p><h3 id="1-3-Logging"><a href="#1-3-Logging" class="headerlink" title="1.3 Logging"></a>1.3 Logging</h3><p>Logging的日志有两种，一种时业务日志info，一种是错误日志error。后面再补充。</p><h3 id="1-4-指定进程名称"><a href="#1-4-指定进程名称" class="headerlink" title="1.4 指定进程名称"></a>1.4 指定进程名称</h3><p><strong>命令 <code>-n proc_name</code> 或者<code>--name=APP_NAME</code> 用于指定gunicorn进程的名称</strong><br>默认情况下通过 gunicorn 启动项目之后，进程的名称是<code>gunicorn</code>。需要注意的是这个进程的名称不同于应用的名称。<br>如下:<code>gunicorn -c gunicorn.conf.py --name=test_app manage:app</code> 指定进程的名称是 test_app。<br><img src="./d1a0c3a07a5f439691fe48496c8b5a83.png"></p><h3 id="1-5-客户端地址（server-socket）"><a href="#1-5-客户端地址（server-socket）" class="headerlink" title="1.5 客户端地址（server socket）"></a>1.5 客户端地址（server socket）</h3><p><strong>命令行 <code>-b ADDRESS</code> 或者<code>--bind ADDRESS</code></strong><br>默认的IP和端口号是 127.0.0.1:8000<br>bind 配置主要用于指定应用绑定的IP和端口号。<br>格式是<code>HOST</code>,<code>HOST:PORT</code>,<code>unix:PATH</code>或者<code>fd://FD</code>, 需要注意的是IP地址必须是一个合法的IP地址<br>例如：<code>gunicorn -b 0.0.0.0:8111 manage:app</code>。指定端口号为8111。<br><img src="./21447c1a8bb74fd7945363743aa16fc9.png"></p><h3 id="1-6-工作进程数（Worker-Processes）"><a href="#1-6-工作进程数（Worker-Processes）" class="headerlink" title="1.6 工作进程数（Worker Processes）"></a>1.6 工作进程数（Worker Processes）</h3><p>**命令行<code>-w INT</code> 或者<code>--workers INT</code>**。<br>默认的进程数是1。<br>这个配置用于指定处理请求的工作进程的数量，单核机器上这个数量一般在2-4个之间。你需要找到最适合该服务器的进程数。<br>例如：<code>gunicorn -w 5 manage:app</code>, 表示启动5个工作进程。每个工作进程都可以多线程执行任务。<br><img src="./8f4c2ea706354c95acd8f6cc0acb1ec1.png"></p><h3 id="1-7-工作模式（worker-class）"><a href="#1-7-工作模式（worker-class）" class="headerlink" title="1.7 工作模式（worker_class）"></a>1.7 工作模式（worker_class）</h3><p><strong>命令行<code>-k STRING</code>或者<code>--worker-class STRING</code></strong><br>默认的工作模式是<code>sync</code>，即同步的工作模式。<br>一共有五种工作模式，分别是 <strong>sync, eventlet, gevent, tornado, gthread</strong> 。<br>下面就分别介绍下这些工作模式。</p><ol><li><strong>sync 模式(同步工作模式)</strong><br>这是最基本的工作模式，也是默认的工作模式，线程为native类型。即请求先来后到，排队模式。<img src="./8b0c24d1ae4f43bc969f1b542ffb8604.png"></li><li><strong>eventlet 模式（协程异步）</strong><br>eventlet 工作模式是基于eventlet库，利用python协程实现的。<br>要使用该工作模式的话必须先安装eventlet库，并且版本要大于等于0.24.1<br>安装命令是：<code>pip install eventlet</code></li><li><strong>gevent模式（协程异步）</strong><br>gevent是基于Greentlet库，利用python协程实现的。<br>安装命令是:<code>pip install gevent</code><br>Gunicorn允许通过设置对应的worker类来使用这些异步Python库。这里的设置适用于我们想要在单核机器上运行的gevent：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --worker-<span class="keyword">class</span>=gevent -w <span class="number">2</span>  manage:app</span><br></pre></td></tr></table></figure><img src="./b2c804a5b6d14f9d9ff1bbb264e6b3b9.png">\5. **tornado模式**tornado利用python Tornado框架来实现。安装命令是：`pip install tornado` 安装的tornado库的版本要大于等于0.2。\6. **gthread模式**gthread采用的是线程工作模式，利用线程池管理连接，需要安装gthread库。安装命令是：`pip install gthread`。Gunicorn允许每个worker拥有多个线程。在这种场景下，Python应用程序每个worker都会加载一次，同一个worker生成的每个线程共享相同的内存空间。为了在 Gunicorn 中使用多线程。我们使用了 gthreads 模式，指定threads参数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --workers=5 --threads=2 main:app</span><br></pre></td></tr></table></figure><p>该命令等同于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --workers=5 --threads=2 --worker-class=gthread main:app</span><br></pre></td></tr></table></figure><p>该例中里面的最大并发请求数是 <code>worker*线程</code>，也就是10。指定threads参数的话则工作模式自动变成gthread模式。</p><h3 id="1-8线程数-threads"><a href="#1-8线程数-threads" class="headerlink" title="1.8线程数(threads)"></a>1.8线程数(threads)</h3><p><strong>命令行<code>--threads INT</code></strong><br>默认每个worker一个线程执行。<br>表示每个工作进程处理请求的线程数。指定threads参数的话则工作模式自动变成gthread模式。</p><h3 id="1-9-工作线程连接数（worker-connections）"><a href="#1-9-工作线程连接数（worker-connections）" class="headerlink" title="1.9 工作线程连接数（worker_connections）"></a>1.9 工作线程连接数（worker_connections）</h3><p><strong>命令行：<code>--worker-connections INT</code></strong><br>默认值是： 1000<br>该参数的含义是：每个工作线程同时存在的连接数，该参数仅在Eventlet和Gevent 两种工作模式下有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --worker-class=gevent --worker-connections=1000 --workers=3 main:app</span><br></pre></td></tr></table></figure><p>worker-connections 是对于 gevent worker 类的特殊设置。(2<em>CPU)+1 仍然是建议的workers 数量。因为我们仅有一核，我们将会使用 3 个worker。在这种情况下，最大的并发请求数量是3000。（3个worker</em>1000个连接&#x2F;worker）</p><h3 id="1-10-最大请求数（max-requests）"><a href="#1-10-最大请求数（max-requests）" class="headerlink" title="1.10 最大请求数（max_requests）"></a>1.10 最大请求数（max_requests）</h3><p><strong>命令行<code>--max-requests INT</code></strong><br>默认值是0<br>该参数的含义是：在重启之前工作进程（worker）能处理的最大请求数，任何一个大于0的值都会限制工作进程（worker）在重启之前处理的请求数量，这是一种帮助限制内存泄漏的简单方法。<br>如果该值设置为0（默认值）那么工作进程的自动重启是被禁用</p><h3 id="1-11-超时设置（timeout）"><a href="#1-11-超时设置（timeout）" class="headerlink" title="1.11 超时设置（timeout）"></a>1.11 超时设置（timeout）</h3><p><strong>命令行<code>-t INT</code> 或者<code>--timeout INT</code></strong><br>默认值是30秒。<br>工作进程在超过设置的超时时间内没有响应将会被杀死并重启。<br>当值为0就表示禁用超时设置。<br>通常，默认的30秒就够了，只有当确定对同步工作进程有影响时才会修改该值。对于非同步工作进程，这意味着工作进程仍在运行，不受处理单个请求所需的时间的限制。</p><h3 id="1-12-连接的存活时间（keepalive）"><a href="#1-12-连接的存活时间（keepalive）" class="headerlink" title="1.12 连接的存活时间（keepalive）"></a>1.12 连接的存活时间（keepalive）</h3><p><strong>命令行<code>--keep-alive INT</code></strong><br>默认值是2<br>连接超时时间，通常设置在1-5秒范围内。</p><h3 id="工作模式的补充说明"><a href="#工作模式的补充说明" class="headerlink" title="工作模式的补充说明"></a>工作模式的补充说明</h3><p>当worker指定为gevent或者evenlet类型时，线程变成基于Greentlet的task(伪线程)，这时候线程数量threads参数是无效的。</p><h4 id="使用gevent模式会出现一些兼容性问题。"><a href="#使用gevent模式会出现一些兼容性问题。" class="headerlink" title="使用gevent模式会出现一些兼容性问题。"></a>使用gevent模式会出现一些兼容性问题。</h4><p>使用gevent时，系统会使用monkey patch。系统的部分函数会被修改，<br>有些库会兼容gevent的类型，<br>例如，任务调度的库apscheduler，web socket需要socketio的库等，需要专门选择gevent的函数。<br>而有些库则直接无法使用，例如多进程multiprocess。<br>例如，在一个api请求中，如果需要使用多核cpu资源，采用multiprocess进行多进程计算。则会出现卡死的问题。gevent中，不能使用multiprocess库。</p><h2 id="性能实践"><a href="#性能实践" class="headerlink" title="性能实践"></a>性能实践</h2><ol><li>如果这个应用是<strong>I&#x2F;O受限</strong>，通常可以通过使用<strong>“伪线程”（gevent或asyncio）的工作模式</strong>来得到最佳性能。正如我们了解到的，Gunicorn通过设置合适的worker类并将workers数量调整到<code>（2*CPU）+1</code>来支持这种编程范式。</li><li>如果这个应用是<strong>CPU受限</strong>，那么应用程序处理多少并发请求就并不重要，唯一重要的是并行请求的数量。因为Python’s GIL，线程和’伪线程’并不能以并行模式执行，可以将worker的数量改成CPU的核数，理解到最大的并行请求数量其实就是核心数。<strong>这时候适合的工作模式是sync工作模式。</strong></li><li>如果不确定应用程序的内存占用，使用多线程以及相应的gthread worker类会产生更好的性能，因为应用程序会在每个worker上都加载一次，并且在同一个worker上运行的每个线程都会共享一些内存，但这需要一些额外的CPU消耗。</li><li>如果你不知道你自己应该选择什么就从最简单的配置开始，就只是 workers 数量设置为 (2*CPU)+1 并且不用考虑 多线程。从这个点开始，就是所有测试和错误的基准环境。如果瓶颈在内存上，就开始引入多线程。如果瓶颈在 I&#x2F;O 上，就考虑使用不同的 Python 编程范式。如果瓶颈在 CPU 上，就考虑添加更多内核并且调整 workers 数量。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了Gunicorn的安装使用以及各个配置参数的含义。希望对读者朋友们有所帮助。针对这些的学习还是看官方文档最好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Socket/Node/Die/Core/Processor/Package</title>
      <link href="/2022/10/14/02%20CPU/SocketNodeDieCoreProcessor/"/>
      <url>/2022/10/14/02%20CPU/SocketNodeDieCoreProcessor/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket-x2F-Node-x2F-Die-x2F-Core-x2F-Processor-x2F-针对CPU封装的精细区分"><a href="#Socket-x2F-Node-x2F-Die-x2F-Core-x2F-Processor-x2F-针对CPU封装的精细区分" class="headerlink" title="Socket&#x2F;Node&#x2F;Die&#x2F;Core&#x2F;Processor&#x2F; 针对CPU封装的精细区分"></a>Socket&#x2F;Node&#x2F;Die&#x2F;Core&#x2F;Processor&#x2F; 针对CPU封装的精细区分</h1><p>CPU封装多种术语解释</p><p>socket：在服务器上，一块主板可以拥有多个socket，即CPU的物理插槽。一般插槽上CPU的封装方式会分为BGA和LGA两种方式。BGA为CPU集成在主板上，不可拆卸式的。而LGA是可拆卸方式。<br>node：node是逻辑概念，对应于socket。NUMA结构中core或cpu分组，每个node内部有自己的CPU总线和内存。Node是可跨socket的。（node是针对NUMA的硬件体系结构而言的）<br>die：die是晶片颗粒，一颗裸晶片。如部分CPU中会有两个die，分为die0和die1。<br>core：core是物理概念，一个独立的硬件执行单元，对应于物理CPU（但是是多个core集成在一个真正的物理CPU中），也是处理器芯片上的独立计算核心。<br>cpu&#x2F;processor：这两个术语指packge、core、逻辑内核(logical processor)等多种意思。当我们讨论计算机硬件时，CPU和Porocessor一般指physical processor即一个packge。在操作系统或应用程序中，CPU和porocessor通常指logical processor。<br>thread：逻辑概念，现在处理器超线程技术允许一个core处理多个theard。一个core虚拟为多个逻辑内核，每个逻辑内核执行一个theard。<br>###CPU and Core<br>CPU ≠ core。CPU是指整个的中央处理单元，指令在这里处理，信号从这里发出。<br><img src="./20200403115046924 .png"></p><p>CPU包含的范围比较大，里面包含了core，内存控制器，PCIe控制器，片外总线这些东西，真正干活的是core，用来执行一条控制流（线程）。一个CPU中可能有多个core，平常我们说的物理核心都是指core，每个物理核心（core）都有自己的电路，看下面这幅图。<br><img src="./20200403122636938.png"><br>如上图，多个CPU和多核是不等价的两个概念</p><p>core (Physical)<br>物理核心（core）是一个独立的执行单元，它可以与其他核心（core）并行运行一个程序线程。现代CPU具有多个core，这些core几乎都是独立的处理单元。供应商可以将core作为独立的裸片(die)制造在同一封装（package）上，也可以在同一裸片(core)上蚀刻。</p><p>下图中两个黑色方块代表core，灰色的是die。<br><img src="./20200403122023369.png"></p><p>每个物理核心可以有2个逻辑核心。然而，逻辑核心与在同一物理核心上运行的其他逻辑核心共享资源，因此，拥有更多的逻辑核心并不一定会获得与拥有更多物理核心相同的性能提升。</p><p>在intel超线程(HT)的情况下，每个物理内核有两个逻辑内核，所以一个四核(物理)i7处理器将有八个逻辑内核。然而，一个物理核心中的两个逻辑核心不能真正地相互并行操作。这是因为HT的工作原理是，当一个逻辑核心在等待，而另一个逻辑核心却无事可做(例如，当它在等待缓存或内存取出时)时，让一个逻辑核心进行操作。<br>die<br>知乎有两篇文章对die介绍的很清楚，看完就懂</p><ul><li><a href="https://zhuanlan.zhihu.com/p/51354994">什么是CPU Die</a></li><li><a href="https://zhuanlan.zhihu.com/p/85819786">多核 CPU 和多个 CPU 有何区别</a></li></ul><p>Die是处理器在生产过程中引入的概念。总的来说，Die或者CPU Die指的是处理器在生产过程中，从晶圆（Silicon Wafer）上切割下来的一个个小方块（这也是为啥消费者看到的CPU芯片为什么都是方的的原因），在切割下来之前，每个小方块（Die）都需要经过各种加工，将电路逻辑刻到该Die上面。<br><img src="./20200403110446848.png"></p><p>die是一块半导体材料(通常是硅)。一个die可以包含任意数量的core。最多有15种可用于英特尔产品线。die是构成CPU的晶体管的实际所在。</p><p>对于主流的CPU厂商Intel和AMD而言，他们会将1个或者多个CPU Die封装起来形成一个CPU Package，有时候也叫作CPU Socket（CPU插槽），如下图所示：<br><img src="./20200403110640546.png"></p><p>而对于AMD的EYPC CPU而言，它的每个CPU Socket由4个CPU Die组成，每个CPU Die中包含有4个CPU内核，如下图所示，黑色的长方形就是die，每一个中有4个core（物理核心），不过看不见。<br><img src="./20200403110729643.png"></p><p>CPU Die之间通过片外总线（Infinity Fabric）互联，并且不同CPU Die上的CPU内核不能共享CPU缓存，而单个Die的Xeon处理器内和所有CPU内核其实是可以共享CPU的第三级缓存(L3 Cache)的。</p><p>总结：die就是一个硅片，在它上面可以安装core，一个core或者多个core都可以。core是一个完整且独立的执行单元。HT技术可以让一个core并发的执行两个控制流（线程），通常就说这个物理core可以模拟出两个逻辑核，4核8线程就是说有四个核心（core），这4个是物理存在的执行单元，8线程指模拟出来的8个逻辑核，实际并不存在8个，只是在逻辑层面来可以说有8个。<br><img src="./20200403121455597.png"><br>package<br>package是当你购买单个处理器时所得到的。这里的CPU“package”是指包含一个或多个die的塑料&#x2F;陶瓷外壳和镀金的触点，以配合你的主板。主板上的每个CPU插槽（socket），只能接受一个package。package是插在插座上的单元。如下图，左侧全是金属触点的是CPU package的背面，右侧有一个明亮外壳的是CPU package的正面。</p><p>你至少会有一个核心（Core）、一个die和一个Package。为了使CPU可以正常工作，它必须有一个可以执行命令的单元，一块物理上包含实现处理器晶体管的硅，以及将硅连接到主板和IO上的接口的封装。</p><p>Dual-core<br>双核处理器是一个包含两个物理核心（core）的package。可以是一个die，也可以是两个die。第一代多核处理器通常在一个package上使用多个die，而现代设计将它们放在同一个die上，这带来了一些优势，比如能够共享on-die缓存。下图是一个双核心（core）的CPU，使用了两片die，每片上有一个物理核心（core）。<br><img src="./20200403010841343.png"></p><p>“CPU”并不是很明确的一个词。当人们购买“CPU”时，他们购买的是CPU package。当他们检查“CPU扩展”时，他们讨论的是逻辑核心。这样做的原因是，在大多数实际应用中，双核处理器（Dual-core ）的行为类似于两个处理器系统（两个CPU），即有两个CPU插槽或两个CPU单核package的系统，因此在讨论可伸缩性时，最合理的做法是统计可用的核心（core）;它们是如何安装到die、package和主板上的就不那么重要了。</p><h4 id="die，package和CPU的关系"><a href="#die，package和CPU的关系" class="headerlink" title="die，package和CPU的关系"></a>die，package和CPU的关系</h4><p>来自Intel 工艺流程图<br><img src="./20200403152404561.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>技术发展</title>
      <link href="/2022/10/14/02%20CPU/%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95/"/>
      <url>/2022/10/14/02%20CPU/%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p><a href="Chiplet.html">揭秘Chiplet技术，摩尔定律拯救者，两大阵营、六个核心玩家</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Systemd</title>
      <link href="/2022/10/14/01%20OS/Linux/systemd/"/>
      <url>/2022/10/14/01%20OS/Linux/systemd/</url>
      
        <content type="html"><![CDATA[<h1 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h1><p>关于 Linux 中的 1 号初始进程，RHEL 5 默认的是 SysV init，到了 RHEL 6 则是昙花一现的 upstart。而大包大揽、管天管地的 systemd，曾经因为不符合 Unix 小而美的设计风格而饱受争议。但可能确实好用吧（至少笔者是这么觉得的），到了 RHEL 7 时代，systemd 逐渐成为了主角。</p><h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a><strong>初探</strong></h2><p>历史上，<a href="https://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html">Linux 的启动</a>一直采用<a href="https://en.wikipedia.org/wiki/Init"><code>init</code></a>进程。</p><p>下面的命令用来启动服务。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/apache2 start</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ service apache2 start</span><br></pre></td></tr></table></figure></blockquote><p>这种方法有两个缺点。</p><p>一是启动时间长。<code>init</code>进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</p><p>二是启动脚本复杂。<code>init</code>进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。</p><p>根据 Linux 惯例，字母<code>d</code>是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p><img src="./bg2016030702.jpg"><p>（上图为 Systemd 作者 <a href="https://en.wikipedia.org/wiki/Lennart_Poettering">Lennart Poettering</a>）</p><p>使用了 Systemd，就不需要再用<code>init</code>了。Systemd 取代了<code>initd</code>，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl --version</span><br></pre></td></tr></table></figure></blockquote><p>上面的命令查看 Systemd 的版本。</p><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的<a href="https://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html">Unix 哲学</a>。</p><img src="./bg2016030703.png"><p>（上图为 Systemd 架构图）</p><p>一个 service 在传统的 Linux 系统中通常被实现为 daemon，在 systemd 中则被抽象成了<strong>unit</strong>，SysV 中的 init script 在 systemd 中被替换成了 <strong>unit file</strong>，以大家常用的 sshd 为例，它大概长这样（省略号的部分将在后文展开讲述）：</p><img src="./v2-5637f0fd8daf358cbc0358899fd775ee_720w.webp"><p>如果想修改这个文件的内容，需要拿个小本本才能记住 “&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system” 这串长长的路径？其实不必，直接用 “systemctl edit” 命令试一下（自 systemd 的 218 版本后支持此项功能）：</p><img src="./v2-42432df45e5626aa99509a0aceb67756_720w.png"><p>怎么打开的是一个空文件？因为这里默认的是 override 方式，即你在这个文件里写入的，会覆盖掉原来 unit file 中对应的部分，当该 unit 被加载时，systemd 会自动进行文件内容的 merge 操作。</p><p>这种将原生文件和修改相分离的做法还是蛮好的，不用在改动配置文件之前因为担心出错，先手动将原文件备份一下（比如命名为 “*.bak”），需要撤销改动又再手动恢复。如果还是比较习惯直接编辑原文件的方式，那就用 “edit –full”。</p><p>虽然在实现上勇于革新，但 systemd 还是提供了对 SysV init 的前向兼容性，init script 在 systemd 中依然可以运行。如果想将这些既有的 init script 转换为 systemd 的 unit files，请参考<a href="https://link.zhihu.com/?target=https://access.redhat.com/solutions/912263">这篇文章</a>。</p><p>关于 Linux 中的 1 号初始进程，RHEL 5 默认的是 SysV init，到了 RHEL 6 则是昙花一现的 upstart。而大包大揽、管天管地的 systemd，曾经因为不符合 Unix 小而美的设计风格而饱受争议。但可能确实好用吧（至少笔者是这么觉得的），到了 RHEL 7 时代，systemd 逐渐成为了主角。</p><h2 id="初探-1"><a href="#初探-1" class="headerlink" title="初探"></a><strong>初探</strong></h2><p>一个 service 在传统的 Linux 系统中通常被实现为 daemon，在 systemd 中则被抽象成了<strong>unit</strong>，SysV 中的 init script 在 systemd 中被替换成了 <strong>unit file</strong>，以大家常用的 sshd 为例，它大概长这样（省略号的部分将在后文展开讲述）：</p><img src="./v2-5637f0fd8daf358cbc0358899fd775ee_720w.webp"><p>如果想修改这个文件的内容，需要拿个小本本才能记住 “&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system” 这串长长的路径？其实不必，直接用 “systemctl edit” 命令试一下（自 systemd 的 218 版本后支持此项功能）：</p><img src="./v2-42432df45e5626aa99509a0aceb67756_720w.png"><p>怎么打开的是一个空文件？因为这里默认的是 override 方式，即你在这个文件里写入的，会覆盖掉原来 unit file 中对应的部分，当该 unit 被加载时，systemd 会自动进行文件内容的 merge 操作。</p><p>这种将原生文件和修改相分离的做法还是蛮好的，不用在改动配置文件之前因为担心出错，先手动将原文件备份一下（比如命名为 “*.bak”），需要撤销改动又再手动恢复。如果还是比较习惯直接编辑原文件的方式，那就用 “edit –full”。</p><p>虽然在实现上勇于革新，但 systemd 还是提供了对 SysV init 的前向兼容性，init script 在 systemd 中依然可以运行。如果想将这些既有的 init script 转换为 systemd 的 unit files，请参考<a href="https://link.zhihu.com/?target=https://access.redhat.com/solutions/912263">这篇文章</a>。</p><h2 id="细究"><a href="#细究" class="headerlink" title="细究"></a>细究</h2><p>接下来好好看看一个 unit file 中的三部分内容分别表示什么（还是以 sshd.service 为例）：</p><img src="./v2-e0ac43b1e105d5c2efffae411ae324b7_720w.png"><p>“<strong>After</strong>“ 限制了启动的顺序，因为 ssh 是网络服务的一种，所以它需要等到 “network” 起来之后才可以启动。至于 “<strong>Wants</strong>“，则体现了 systemd 的一个特性：可以自动解决启动时的依赖问题。</p><p>如果试图手动启动服务 A，而服务 A 依赖于服务 B（比如 sshd.service 依赖于 sshd-keygen.service），那么 systemd 就会自动帮你服务 B 先启动起来。这种依赖关系除了可以通过服务 A 的unit-file看出来，也可以通过 “systemctl list-dependencies” 得知。</p><img src="./v2-e8bb0a52071211f473fe099c08178f32_720w.png"><p>然后来到 “<strong>Type</strong>“ 这一行，如果它的值是 “simple” 或者 “notify”，表明由 “ExecStart” 创建的就是该 service 的主进程。</p><img src="./v2-32a6954f9525b476bd8ce9c094b0cd69_720w.png"><p>还有一种传统的 type 是 “forking”，意思是由 “ExecStart” 创建父进程，父进程再 fork 一个子进程作为该 service 的主进程，所以此时通常需配合 “PIDFile” 来标识主进程对应的 <a href="https://link.zhihu.com/?target=https://lwn.net/Articles/801319/">pid 文件</a>。</p><img src="./v2-d95411d07db0914d2ee07c5278c30ef0_720w.png"><p>说到最后的这个 “<strong>WantedBy</strong>“，先来回忆下 SysV init 中经典的 “runlevel” 的概念，它代表了 OS 不同的运行模式（用数字 0~6 表示）。</p><img src="./v2-8f5cc91080e86d49c2b745af0e93491a_720w.png"><p>而在 systemd 中，”runlevel” 被精简成了对应命令行终端（CLI）的 “multi-user target”，和对应图形界面的 “graphical target”。什么是 “<strong>target</strong>“？可以简单地理解为构成执行环境的一组 unit 的集合（这里 sshd 就是构成 “multi-user target” 的一员）。</p><img src="./v2-fde35e1ff49f9521f7acb0866aadd36c_720w.webp"><p>那基于 target，怎样在命令行和 GUI 之间切换呢？熟悉 “runlevel” 概念的你，可能还是习惯性地会去 “&#x2F;etc&#x2F;inittab” 中寻找答案。虽然这个文件在 systemd 里其实已经没用了，但它还是被留在那里，等待你打开的时候，贴心地告诉你：新的 systemd 中的这两个 “target” 和 “runlevel” 大致是怎样的一种对应关系，以及如何实现设置的切换。</p><img src="./v2-c29437405018270685f1774532597b13_720w.webp"><p>当然，也可以使用基于 web 的 <a href="https://link.zhihu.com/?target=https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwiQpoKIsv7xAhWFAd4KHUNpAm0QFjAAegQICxAD&url=https://zhuanlan.zhihu.com/p/145282748&usg=AOvVaw1LUQUy9n6if5fV8Bp7F7Bd">cockpit</a> 来进行切换：</p><img src="./v2-cae0c158f6f71c80e194a8b0ff013117_720w.webp"><h2 id="按需激活"><a href="#按需激活" class="headerlink" title="按需激活"></a><strong>按需激活</strong></h2><p>除了上面介绍的 service，systemd要管的东西还多着呢，本着「分而治之」的原则，还有很多其他类型的unit，它们大都和 systemd 的按需启动和并行启动有关。这里以 socket unit 为例来进行说明。</p><p>作为一个像 sshd 这样的service，它需要监听特定的端口，以便处理来自 client 的连接请求，所以传统的做法是：你得先启动起来，即便之后一直没有 client 发出连接请求，你也得一直保持在线状态，守护进程嘛，这就是你的职责。</p><p>而 systemd 采用的做法是：你们这些 service 都先不用启动，需要的 listen socket 都由我来创建和监听，当有真正的连接到来时（比如 ssh client 的请求），那我再把对应的 sshd service 拉起来，然后把这个 socket 交给 sshd。这里，systemd 其实充当了一个 socket 代理的角色。</p><img src="./v2-9fc884cc3f99254e90c2c67f4666065e_720w.webp"><p>那在 sshd 得到 systemd 移交的这个 socket 之前，通过这个 socket 监听的消息岂不是收不到？不用担心，systemd 会把代管 socket 期间收到的消息也一并传给 sshd，不会让消息遗漏。</p><p>这种激活 service 的方式被称为 <em>“<strong>socket-based activation</strong>“。</em>除此之外，还有当设备真正挂载才激活的 <em>“device-based activation”，</em>当目录或文件真正改变才激活的 <em>“path-based activation”</em> 等等，反正都是 on-demand，有需求再说，这也再次体现了 “lazy” 的设计思想。</p><p>也正是由于这种设计，systemd 才敢进行激进的并行启动，只要 listen socket 都准备好了，就不怕。</p><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p><h3 id="3-1-systemctl"><a href="#3-1-systemctl" class="headerlink" title="3.1 systemctl"></a>3.1 systemctl</h3><p><code>systemctl</code>是 Systemd 的主命令，用于管理系统。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭系统，切断电源</span></span><br><span class="line">$ sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU停止工作</span></span><br><span class="line">$ sudo systemctl halt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停系统</span></span><br><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入冬眠状态</span></span><br><span class="line">$ sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入交互式休眠状态</span></span><br><span class="line">$ sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进入救援状态（单用户状态）</span></span><br><span class="line">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-2-systemd-analyze"><a href="#3-2-systemd-analyze" class="headerlink" title="3.2 systemd-analyze"></a>3.2 systemd-analyze</h3><p><code>systemd-analyze</code>命令用于查看启动耗时。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                                       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示瀑布状的启动过程流</span></span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定服务的启动流</span></span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-3-hostnamectl"><a href="#3-3-hostnamectl" class="headerlink" title="3.3 hostnamectl"></a>3.3 hostnamectl</h3><p><code>hostnamectl</code>命令用于查看当前主机的信息。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ sudo hostnamectl set-hostname rhel7</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-4-localectl"><a href="#3-4-localectl" class="headerlink" title="3.4 localectl"></a>3.4 localectl</h3><p><code>localectl</code>命令用于查看本地化设置。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地化设置</span></span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地化参数。</span></span><br><span class="line">$ sudo localectl set-locale LANG=en_GB.utf8</span><br><span class="line">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-5-timedatectl"><a href="#3-5-timedatectl" class="headerlink" title="3.5 timedatectl"></a>3.5 timedatectl</h3><p><code>timedatectl</code>命令用于查看当前时区设置。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前时区设置</span></span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前时区</span></span><br><span class="line">$ sudo timedatectl set-timezone America/New_York</span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-6-loginctl"><a href="#3-6-loginctl" class="headerlink" title="3.6 loginctl"></a>3.6 loginctl</h3><p><code>loginctl</code>命令用于查看当前登录的用户。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前session</span></span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录用户</span></span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出显示指定用户的信息</span></span><br><span class="line">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure></blockquote><h2 id="四、Unit"><a href="#四、Unit" class="headerlink" title="四、Unit"></a>四、Unit</h2><h3 id="4-1-含义"><a href="#4-1-含义" class="headerlink" title="4.1 含义"></a>4.1 含义</h3><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p><p>Unit 一共分成12种。</p><blockquote><ul><li>Service unit：系统服务</li><li>Target unit：多个 Unit 构成的一个组</li><li>Device Unit：硬件设备</li><li>Mount Unit：文件系统的挂载点</li><li>Automount Unit：自动挂载点</li><li>Path Unit：文件或路径</li><li>Scope Unit：不是由 Systemd 启动的外部进程</li><li>Slice Unit：进程组</li><li>Snapshot Unit：Systemd 快照，可以切回某个快照</li><li>Socket Unit：进程间通信的 socket</li><li>Swap Unit：swap 文件</li><li>Timer Unit：定时器</li></ul></blockquote><p><code>systemctl list-units</code>命令可以查看当前系统的所有 Unit 。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出正在运行的 Unit</span></span><br><span class="line">$ systemctl list-units</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></span><br><span class="line">$ systemctl list-units --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有没有运行的 Unit</span></span><br><span class="line">$ systemctl list-units --all --state=inactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有加载失败的 Unit</span></span><br><span class="line">$ systemctl list-units --failed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有正在运行的、类型为 service 的 Unit</span></span><br><span class="line">$ systemctl list-units --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-2-Unit-的状态"><a href="#4-2-Unit-的状态" class="headerlink" title="4.2 Unit 的状态"></a>4.2 Unit 的状态</h3><p><code>systemctl status</code>命令用于查看系统状态和单个 Unit 的状态。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示系统状态</span></span><br><span class="line">$ systemctl status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示单个 Unit 的状态</span></span><br><span class="line">$ sysystemctl status bluetooth.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示远程主机的某个 Unit 的状态</span></span><br><span class="line">$ systemctl -H root@rhel7.example.com status httpd.service</span><br></pre></td></tr></table></figure></blockquote><p>除了<code>status</code>命令，<code>systemctl</code>还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示某个 Unit 是否正在运行</span></span><br><span class="line">$ systemctl is-active application.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 Unit 是否处于启动失败状态</span></span><br><span class="line">$ systemctl is-failed application.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 Unit 服务是否建立了启动链接</span></span><br><span class="line">$ systemctl is-enabled application.service</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-3-Unit-管理"><a href="#4-3-Unit-管理" class="headerlink" title="4.3 Unit 管理"></a>4.3 Unit 管理</h3><p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 立即启动一个服务</span></span><br><span class="line">$ sudo systemctl start apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立即停止一个服务</span></span><br><span class="line">$ sudo systemctl stop apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启一个服务</span></span><br><span class="line">$ sudo systemctl restart apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死一个服务的所有子进程</span></span><br><span class="line">$ sudo systemctl <span class="built_in">kill</span> apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载一个服务的配置文件</span></span><br><span class="line">$ sudo systemctl reload apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载所有修改过的配置文件</span></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 Unit 的所有底层参数</span></span><br><span class="line">$ systemctl show httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 Unit 的指定属性的值</span></span><br><span class="line">$ systemctl show -p CPUShares httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置某个 Unit 的指定属性</span></span><br><span class="line">$ sudo systemctl set-property httpd.service CPUShares=500</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-4-依赖关系"><a href="#4-4-依赖关系" class="headerlink" title="4.4 依赖关系"></a>4.4 依赖关系</h3><p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p><p><code>systemctl list-dependencies</code>命令列出一个 Unit 的所有依赖。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl list-dependencies nginx.service</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用<code>--all</code>参数。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、Unit-的配置文件"><a href="#五、Unit-的配置文件" class="headerlink" title="五、Unit 的配置文件"></a>五、Unit 的配置文件</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p><p>Systemd 默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在那个目录。</p><p><code>systemctl enable</code>命令用于在上面两个目录之间，建立符号链接关系。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> clamd@scan.service</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ sudo <span class="built_in">ln</span> -s <span class="string">&#x27;/usr/lib/systemd/system/clamd@scan.service&#x27;</span> <span class="string">&#x27;/etc/systemd/system/multi-user.target.wants/clamd@scan.service&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。</p><p>与之对应的，<code>systemctl disable</code>命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">disable</span> clamd@scan.service</span><br></pre></td></tr></table></figure></blockquote><p>配置文件的后缀名，就是该 Unit 的种类，比如<code>sshd.socket</code>。如果省略，Systemd 默认后缀名为<code>.service</code>，所以<code>sshd</code>会被理解成<code>sshd.service</code>。</p><h3 id="5-2-配置文件的状态"><a href="#5-2-配置文件的状态" class="headerlink" title="5.2 配置文件的状态"></a>5.2 配置文件的状态</h3><p><code>systemctl list-unit-files</code>命令用于列出所有配置文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有配置文件</span></span><br><span class="line">$ systemctl list-unit-files</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定类型的配置文件</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure></blockquote><p>这个命令会输出一个列表。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl list-unit-files</span><br><span class="line"></span><br><span class="line">UNIT FILE              STATE</span><br><span class="line">chronyd.service        enabled</span><br><span class="line">clamd@.service         static</span><br><span class="line">clamd@scan.service     disabled</span><br></pre></td></tr></table></figure></blockquote><p>这个列表显示每个配置文件的状态，一共有四种。</p><blockquote><ul><li>enabled：已建立启动链接</li><li>disabled：没建立启动链接</li><li>static：该配置文件没有<code>[Install]</code>部分（无法执行），只能作为其他配置文件的依赖</li><li>masked：该配置文件被禁止建立启动链接</li></ul></blockquote><p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的<code>systemctl status</code>命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status bluetooth.service</span><br></pre></td></tr></table></figure></blockquote><p>一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart httpd.service</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-3-配置文件的格式"><a href="#5-3-配置文件的格式" class="headerlink" title="5.3 配置文件的格式"></a>5.3 配置文件的格式</h3><p>配置文件就是普通的文本文件，可以用文本编辑器打开。</p><p><code>systemctl cat</code>命令可以查看配置文件的内容。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">cat</span> atd.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=ATD daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/bin/atd</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></blockquote><p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如<code>[Unit]</code>。注意，配置文件的区块名和字段名，都是大小写敏感的。</p><p>每个区块内部是一些等号连接的键值对。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Section]</span><br><span class="line">Directive1=value</span><br><span class="line">Directive2=value</span><br><span class="line"></span><br><span class="line">. . .</span><br></pre></td></tr></table></figure></blockquote><p>注意，键值对的等号两侧不能有空格。</p><h3 id="5-4-配置文件的区块"><a href="#5-4-配置文件的区块" class="headerlink" title="5.4 配置文件的区块"></a>5.4 配置文件的区块</h3><p><code>[Unit]</code>区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p><blockquote><ul><li><code>Description</code>：简短描述</li><li><code>Documentation</code>：文档地址</li><li><code>Requires</code>：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li><li><code>Wants</code>：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li><li><code>BindsTo</code>：与<code>Requires</code>类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li><li><code>Before</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li><li><code>After</code>：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li><li><code>Conflicts</code>：这里指定的 Unit 不能与当前 Unit 同时运行</li><li><code>Condition...</code>：当前 Unit 运行必须满足的条件，否则不会运行</li><li><code>Assert...</code>：当前 Unit 运行必须满足的条件，否则会报启动失败</li></ul></blockquote><p><code>[Install]</code>通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p><blockquote><ul><li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.wants</code>后缀构成的子目录中</li><li><code>RequiredBy</code>：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.required</code>后缀构成的子目录中</li><li><code>Alias</code>：当前 Unit 可用于启动的别名</li><li><code>Also</code>：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li></ul></blockquote><p><code>[Service]</code>区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p><blockquote><ul><li><code>Type</code>：定义启动时的进程行为。它有以下几种值。</li><li><code>Type=simple</code>：默认值，执行<code>ExecStart</code>指定的命令，启动主进程</li><li><code>Type=forking</code>：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li><li><code>Type=oneshot</code>：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li><li><code>Type=dbus</code>：当前服务通过D-Bus启动</li><li><code>Type=notify</code>：当前服务启动完毕，会通知<code>Systemd</code>，再继续往下执行</li><li><code>Type=idle</code>：若有其他任务执行完毕，当前服务才会运行</li><li><code>ExecStart</code>：启动当前服务的命令</li><li><code>ExecStartPre</code>：启动当前服务之前执行的命令</li><li><code>ExecStartPost</code>：启动当前服务之后执行的命令</li><li><code>ExecReload</code>：重启当前服务时执行的命令</li><li><code>ExecStop</code>：停止当前服务时执行的命令</li><li><code>ExecStopPost</code>：停止当其服务之后执行的命令</li><li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li><li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，可能的值包括<code>always</code>（总是重启）、<code>on-success</code>、<code>on-failure</code>、<code>on-abnormal</code>、<code>on-abort</code>、<code>on-watchdog</code></li><li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li><li><code>Environment</code>：指定环境变量</li></ul></blockquote><p>Unit 配置文件的完整字段清单，请参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">官方文档</a>。</p><h2 id="六、Target"><a href="#六、Target" class="headerlink" title="六、Target"></a>六、Target</h2><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p><p>传统的<code>init</code>启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前系统的所有 Target</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span>=target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一个 Target 包含的所有 Unit</span></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动时的默认 Target</span></span><br><span class="line">$ systemctl get-default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动时的默认 Target</span></span><br><span class="line">$ sudo systemctl set-default multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span></span><br><span class="line"><span class="comment"># systemctl isolate 命令改变这种行为，</span></span><br><span class="line"><span class="comment"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span></span><br><span class="line">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure></blockquote><p>Target 与 传统 RunLevel 的对应关系如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Traditional runlevel      New target name     Symbolically linked to...</span><br><span class="line"></span><br><span class="line">Runlevel 0           |    runlevel0.target -&gt; poweroff.target</span><br><span class="line">Runlevel 1           |    runlevel1.target -&gt; rescue.target</span><br><span class="line">Runlevel 2           |    runlevel2.target -&gt; multi-user.target</span><br><span class="line">Runlevel 3           |    runlevel3.target -&gt; multi-user.target</span><br><span class="line">Runlevel 4           |    runlevel4.target -&gt; multi-user.target</span><br><span class="line">Runlevel 5           |    runlevel5.target -&gt; graphical.target</span><br><span class="line">Runlevel 6           |    runlevel6.target -&gt; reboot.target</span><br></pre></td></tr></table></figure></blockquote><p>它与<code>init</code>进程的主要差别如下。</p><blockquote><p><strong>（1）默认的 RunLevel</strong>（在<code>/etc/inittab</code>文件设置）现在被默认的 Target 取代，位置是<code>/etc/systemd/system/default.target</code>，通常符号链接到<code>graphical.target</code>（图形界面）或者<code>multi-user.target</code>（多用户命令行）。</p><p><strong>（2）启动脚本的位置</strong>，以前是<code>/etc/init.d</code>目录，符号链接到不同的 RunLevel 目录 （比如<code>/etc/rc3.d</code>、<code>/etc/rc5.d</code>等），现在则存放在<code>/lib/systemd/system</code>和<code>/etc/systemd/system</code>目录。</p><p><strong>（3）配置文件的位置</strong>，以前<code>init</code>进程的配置文件是<code>/etc/inittab</code>，各种服务的配置文件存放在<code>/etc/sysconfig</code>目录。现在的配置文件主要存放在<code>/lib/systemd</code>目录，在<code>/etc/systemd</code>目录里面的修改可以覆盖原始设置。</p></blockquote><h2 id="七、日志管理"><a href="#七、日志管理" class="headerlink" title="七、日志管理"></a>七、日志管理</h2><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code>。</p><p><code>journalctl</code>功能强大，用法非常多。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志（需更改设置）</span></span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ sudo journalctl --since=<span class="string">&quot;2012-10-30 18:17:16&quot;</span></span><br><span class="line">$ sudo journalctl --since <span class="string">&quot;20 min ago&quot;</span></span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since <span class="string">&quot;2015-01-10&quot;</span> --until <span class="string">&quot;2015-01-11 03:00&quot;</span></span><br><span class="line">$ sudo journalctl --since 09:00 --until <span class="string">&quot;1 hour ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部的最新10行日志</span></span><br><span class="line">$ sudo journalctl -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志</span></span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ sudo journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ sudo journalctl _UID=33 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示某个 Unit 的最新日志</span></span><br><span class="line">$ sudo journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></span><br><span class="line"><span class="comment"># 0: emerg</span></span><br><span class="line"><span class="comment"># 1: alert</span></span><br><span class="line"><span class="comment"># 2: crit</span></span><br><span class="line"><span class="comment"># 3: err</span></span><br><span class="line"><span class="comment"># 4: warning</span></span><br><span class="line"><span class="comment"># 5: notice</span></span><br><span class="line"><span class="comment"># 6: info</span></span><br><span class="line"><span class="comment"># 7: debug</span></span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></span><br><span class="line">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class="line"> -o json-pretty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件占据的最大空间</span></span><br><span class="line">$ sudo journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure></blockquote><h2 id="一、开机启动"><a href="#一、开机启动" class="headerlink" title="一、开机启动"></a>一、开机启动</h2><p>对于那些支持 Systemd 的软件，安装的时候，会自动在<code>/usr/lib/systemd/system</code>目录添加一个配置文件。</p><p>如果你想让该软件开机启动，就执行下面的命令（以<code>httpd.service</code>为例）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> httpd</span><br></pre></td></tr></table></figure></blockquote><p>上面的命令相当于在<code>/etc/systemd/system</code>目录添加一个符号链接，指向<code>/usr/lib/systemd/system</code>里面的<code>httpd.service</code>文件。</p><p>这是因为开机时，<code>Systemd</code>只执行<code>/etc/systemd/system</code>目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。</p><h2 id="二、启动服务"><a href="#二、启动服务" class="headerlink" title="二、启动服务"></a>二、启动服务</h2><p>设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行<code>systemctl start</code>命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start httpd</span><br></pre></td></tr></table></figure></blockquote><p>执行上面的命令以后，有可能启动失败，因此要用<code>systemctl status</code>命令查看一下该服务的状态。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status httpd</span><br><span class="line"></span><br><span class="line">httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)</span><br><span class="line">   Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago</span><br><span class="line"> Main PID: 4349 (httpd)</span><br><span class="line">   Status: <span class="string">&quot;Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec&quot;</span></span><br><span class="line">   CGroup: /system.slice/httpd.service</span><br><span class="line">           ├─4349 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4350 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4351 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4352 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4353 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           └─4354 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line">12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server.</span><br><span class="line">12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server.</span><br></pre></td></tr></table></figure></blockquote><p>上面的输出结果含义如下。</p><blockquote><ul><li><code>Loaded</code>行：配置文件的位置，是否设为开机启动</li><li><code>Active</code>行：表示正在运行</li><li><code>Main PID</code>行：主进程ID</li><li><code>Status</code>行：由应用本身（这里是 httpd ）提供的软件当前状态</li><li><code>CGroup</code>块：应用的所有子进程</li><li>日志块：应用的日志</li></ul></blockquote><h2 id="三、停止服务"><a href="#三、停止服务" class="headerlink" title="三、停止服务"></a>三、停止服务</h2><p>终止正在运行的服务，需要执行<code>systemctl stop</code>命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop httpd.service</span><br></pre></td></tr></table></figure></blockquote><p>有时候，该命令可能没有响应，服务停不下来。这时候就不得不”杀进程”了，向正在运行的进程发出<code>kill</code>信号。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">kill</span> httpd.service</span><br></pre></td></tr></table></figure></blockquote><p>此外，重启服务要执行<code>systemctl restart</code>命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart httpd.service</span><br></pre></td></tr></table></figure></blockquote><h2 id="四、读懂配置文件"><a href="#四、读懂配置文件" class="headerlink" title="四、读懂配置文件"></a>四、读懂配置文件</h2><p>一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。</p><p>前面说过，配置文件主要放在<code>/usr/lib/systemd/system</code>目录，也可能在<code>/etc/systemd/system</code>目录。找到配置文件以后，使用文本编辑器打开即可。</p><p><code>systemctl cat</code>命令可以用来查看配置文件，下面以<code>sshd.service</code>文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">cat</span> sshd.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=OpenSSH server daemon</span><br><span class="line">Documentation=man:sshd(8) man:sshd_config(5)</span><br><span class="line">After=network.target sshd-keygen.service</span><br><span class="line">Wants=sshd-keygen.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/sysconfig/sshd</span><br><span class="line">ExecStart=/usr/sbin/sshd -D <span class="variable">$OPTIONS</span></span><br><span class="line">ExecReload=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line">Type=simple</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></blockquote><p>可以看到，配置文件分成几个区块，每个区块包含若干条键值对。</p><p>下面依次解释每个区块的内容。</p><h2 id="五、-Unit-区块：启动顺序与依赖关系。"><a href="#五、-Unit-区块：启动顺序与依赖关系。" class="headerlink" title="五、 [Unit] 区块：启动顺序与依赖关系。"></a>五、 [Unit] 区块：启动顺序与依赖关系。</h2><p><code>Unit</code>区块的<code>Description</code>字段给出当前服务的简单描述，<code>Documentation</code>字段给出文档位置。</p><p>接下来的设置是启动顺序和依赖关系，这个比较重要。</p><blockquote><p><code>After</code>字段：表示如果<code>network.target</code>或<code>sshd-keygen.service</code>需要启动，那么<code>sshd.service</code>应该在它们之后启动。</p></blockquote><p>相应地，还有一个<code>Before</code>字段，定义<code>sshd.service</code>应该在哪些服务之前启动。</p><p>注意，<code>After</code>和<code>Before</code>字段只涉及启动顺序，不涉及依赖关系。</p><p>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。</p><p>设置依赖关系，需要使用<code>Wants</code>字段和<code>Requires</code>字段。</p><blockquote><p><code>Wants</code>字段：表示<code>sshd.service</code>与<code>sshd-keygen.service</code>之间存在”弱依赖”关系，即如果”sshd-keygen.service”启动失败或停止运行，不影响<code>sshd.service</code>继续执行。</p></blockquote><p><code>Requires</code>字段则表示”强依赖”关系，即如果该服务启动失败或异常退出，那么<code>sshd.service</code>也必须退出。</p><p>注意，<code>Wants</code>字段与<code>Requires</code>字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</p><h2 id="六、-Service-区块：启动行为"><a href="#六、-Service-区块：启动行为" class="headerlink" title="六、[Service] 区块：启动行为"></a>六、[Service] 区块：启动行为</h2><p><code>Service</code>区块定义如何启动当前服务。</p><h3 id="6-1-启动命令"><a href="#6-1-启动命令" class="headerlink" title="6.1 启动命令"></a>6.1 启动命令</h3><p>许多软件都有自己的环境参数文件，该文件可以用<code>EnvironmentFile</code>字段读取。</p><blockquote><p><code>EnvironmentFile</code>字段：指定当前服务的环境参数文件。该文件内部的<code>key=value</code>键值对，可以用<code>$key</code>的形式，在当前配置文件中获取。</p></blockquote><p>上面的例子中，sshd 的环境参数文件是<code>/etc/sysconfig/sshd</code>。</p><p>配置文件里面最重要的字段是<code>ExecStart</code>。</p><blockquote><p><code>ExecStart</code>字段：定义启动进程时执行的命令。</p></blockquote><p>上面的例子中，启动<code>sshd</code>，执行的命令是<code>/usr/sbin/sshd -D $OPTIONS</code>，其中的变量<code>$OPTIONS</code>就来自<code>EnvironmentFile</code>字段指定的环境参数文件。</p><p>与之作用相似的，还有如下这些字段。</p><blockquote><ul><li><code>ExecReload</code>字段：重启服务时执行的命令</li><li><code>ExecStop</code>字段：停止服务时执行的命令</li><li><code>ExecStartPre</code>字段：启动服务之前执行的命令</li><li><code>ExecStartPost</code>字段：启动服务之后执行的命令</li><li><code>ExecStopPost</code>字段：停止服务之后执行的命令</li></ul></blockquote><p>请看下面的例子。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=/bin/echo execstart1</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/bin/echo execstart2</span><br><span class="line">ExecStartPost=/bin/echo post1</span><br><span class="line">ExecStartPost=/bin/echo post2</span><br></pre></td></tr></table></figure></blockquote><p>上面这个配置文件，第二行<code>ExecStart</code>设为空值，等于取消了第一行的设置，运行结果如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execstart2</span><br><span class="line">post1</span><br><span class="line">post2</span><br></pre></td></tr></table></figure></blockquote><p>所有的启动设置之前，都可以加上一个连词号（<code>-</code>），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。比如，<code>EnvironmentFile=-/etc/sysconfig/sshd</code>（注意等号后面的那个连词号），就表示即使<code>/etc/sysconfig/sshd</code>文件不存在，也不会抛出错误。</p><h3 id="6-2-启动类型"><a href="#6-2-启动类型" class="headerlink" title="6.2 启动类型"></a>6.2 启动类型</h3><p><code>Type</code>字段定义启动类型。它可以设置的值如下。</p><blockquote><ul><li>simple（默认值）：<code>ExecStart</code>字段启动的进程为主进程</li><li>forking：<code>ExecStart</code>字段将以<code>fork()</code>方式启动，此时父进程将会退出，子进程将成为主进程</li><li>oneshot：类似于<code>simple</code>，但只执行一次，Systemd 会等它执行完，才启动其他服务</li><li>dbus：类似于<code>simple</code>，但会等待 D-Bus 信号后启动</li><li>notify：类似于<code>simple</code>，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li><li>idle：类似于<code>simple</code>，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li></ul></blockquote><p>下面是一个<code>oneshot</code>的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></blockquote><p>上面的配置文件，启动类型设为<code>oneshot</code>，就表明这个服务只要运行一次就够了，不需要长期运行。</p><p>如果关闭以后，将来某个时候还想打开，配置文件修改如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off start</span><br><span class="line">ExecStop=/usr/bin/touchpad-off stop</span><br><span class="line">RemainAfterExit=<span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></blockquote><p>上面配置文件中，<code>RemainAfterExit</code>字段设为<code>yes</code>，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用<code>systemctl stop</code>命令停止服务，<code>ExecStop</code>指定的命令就会执行，从而重新开启触摸板。</p><h3 id="6-3-重启行为"><a href="#6-3-重启行为" class="headerlink" title="6.3 重启行为"></a>6.3 重启行为</h3><p><code>Service</code>区块有一些字段，定义了重启行为。</p><blockquote><p><code>KillMode</code>字段：定义 Systemd 如何停止 sshd 服务。</p></blockquote><p>上面这个例子中，将<code>KillMode</code>设为<code>process</code>，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。</p><p><code>KillMode</code>字段可以设置的值如下。</p><blockquote><ul><li>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉</li><li>process：只杀主进程</li><li>mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li><li>none：没有进程会被杀掉，只是执行服务的 stop 命令。</li></ul></blockquote><p>接下来是<code>Restart</code>字段。</p><blockquote><p><code>Restart</code>字段：定义了 sshd 退出后，Systemd 的重启方式。</p></blockquote><p>上面的例子中，<code>Restart</code>设为<code>on-failure</code>，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行<code>systemctl stop</code>命令），它就不会重启。</p><p><code>Restart</code>字段可以设置的值如下。</p><blockquote><ul><li>no（默认值）：退出后不会重启</li><li>on-success：只有正常退出时（退出状态码为0），才会重启</li><li>on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</li><li>on-abnormal：只有被信号终止和超时，才会重启</li><li>on-abort：只有在收到没有捕捉到的信号终止时，才会重启</li><li>on-watchdog：超时退出，才会重启</li><li>always：不管是什么退出原因，总是重启</li></ul></blockquote><p>对于守护进程，推荐设为<code>on-failure</code>。对于那些允许发生错误退出的服务，可以设为<code>on-abnormal</code>。</p><p>最后是<code>RestartSec</code>字段。</p><blockquote><p><code>RestartSec</code>字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。</p></blockquote><h2 id="七、-Install-区块"><a href="#七、-Install-区块" class="headerlink" title="七、[Install] 区块"></a>七、[Install] 区块</h2><p><code>Install</code>区块，定义如何安装这个配置文件，即怎样做到开机启动。</p><blockquote><p><code>WantedBy</code>字段：表示该服务所在的 Target。</p></blockquote><p><code>Target</code>的含义是服务组，表示一组服务。<code>WantedBy=multi-user.target</code>指的是，sshd 所在的 Target 是<code>multi-user.target</code>。</p><p>这个设置非常重要，因为执行<code>systemctl enable sshd.service</code>命令时，<code>sshd.service</code>的一个符号链接，就会放在<code>/etc/systemd/system</code>目录下面的<code>multi-user.target.wants</code>子目录之中。</p><p>Systemd 有默认的启动 Target。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl get-default</span><br><span class="line">multi-user.target</span><br></pre></td></tr></table></figure></blockquote><p>上面的结果表示，默认的启动 Target 是<code>multi-user.target</code>。在这个组里的所有服务，都将开机启动。这就是为什么<code>systemctl enable</code>命令能设置开机启动的原因。</p><p>使用 Target 的时候，<code>systemctl list-dependencies</code>命令和<code>systemctl isolate</code>命令也很有用。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 multi-user.target 包含的所有服务</span></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到另一个 target</span></span><br><span class="line"><span class="comment"># shutdown.target 就是关机状态</span></span><br><span class="line">$ sudo systemctl isolate shutdown.target</span><br></pre></td></tr></table></figure></blockquote><p>一般来说，常用的 Target 有两个：一个是<code>multi-user.target</code>，表示多用户命令行状态；另一个是<code>graphical.target</code>，表示图形用户状态，它依赖于<code>multi-user.target</code>。官方文档有一张非常清晰的 [Target 依赖关系图](<a href="https://www.freedesktop.org/software/systemd/man/bootup.html#System">https://www.freedesktop.org/software/systemd/man/bootup.html#System</a> Manager Bootup)。</p><h2 id="八、Target-的配置文件"><a href="#八、Target-的配置文件" class="headerlink" title="八、Target 的配置文件"></a>八、Target 的配置文件</h2><p>Target 也有自己的配置文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">cat</span> multi-user.target</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Multi-User System</span><br><span class="line">Documentation=man:systemd.special(7)</span><br><span class="line">Requires=basic.target</span><br><span class="line">Conflicts=rescue.service rescue.target</span><br><span class="line">After=basic.target rescue.service rescue.target</span><br><span class="line">AllowIsolate=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure></blockquote><p>注意，Target 配置文件里面没有启动命令。</p><p>上面输出结果中，主要字段含义如下。</p><blockquote><p><code>Requires</code>字段：要求<code>basic.target</code>一起运行。</p><p><code>Conflicts</code>字段：冲突字段。如果<code>rescue.service</code>或<code>rescue.target</code>正在运行，<code>multi-user.target</code>就不能运行，反之亦然。</p><p><code>After</code>：表示<code>multi-user.target</code>在<code>basic.target</code> 、 <code>rescue.service</code>、 <code>rescue.target</code>之后启动，如果它们有启动的话。</p><p><code>AllowIsolate</code>：允许使用<code>systemctl isolate</code>命令切换到<code>multi-user.target</code>。</p></blockquote><h2 id="九、修改配置文件后重启"><a href="#九、修改配置文件后重启" class="headerlink" title="九、修改配置文件后重启"></a>九、修改配置文件后重启</h2><p>修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新加载配置文件</span></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启相关服务</span></span><br><span class="line">$ sudo systemctl restart foobar</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>99 Ebook</title>
      <link href="/2022/10/13/ebook/"/>
      <url>/2022/10/13/ebook/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="深入理解计算机系统英文版第三版.pdf">深入理解计算机系统英文版第三版.pdf</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图灵机与图灵完备</title>
      <link href="/2022/10/13/99%20Other/%E5%9B%BE%E7%81%B5%E6%9C%BA%E4%B8%8E%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/"/>
      <url>/2022/10/13/99%20Other/%E5%9B%BE%E7%81%B5%E6%9C%BA%E4%B8%8E%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="图灵机与图灵完备"><a href="#图灵机与图灵完备" class="headerlink" title="图灵机与图灵完备"></a>图灵机与图灵完备</h1><p>图灵机Turing Machine</p><p>图灵机来自图灵1936年的文章”On Computable Numbers, with an Application to the Entscheidungsproblem”（论可计算数及其在判定性问题上的应用）中提出的思想，论文指出，只要图灵机可以被实现，就可以用于解决任何可计算问题。</p><p>图灵机的结构为：</p><ul><li>一条无限长的纸带 TAPE。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号 表示空白。纸带上的格子从左到右依此被编号为 0，1，2，… ，纸带的右端可以无限伸展。；</li><li>一个读写头 HEAD。该读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。；</li><li>一套控制规则 TABLE。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态。；</li><li>一个状态寄存器。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态，称为停机状态。参见停机问题。</li></ul><p>在计算开始前，纸带可以是完全空白的，也可以预先写入字符。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：</p><ul><li><p>当前所处位置；</p></li><li><p>当前格子内容；</p></li></ul><p>一步步对照着指令集去进行操作，直到状态变成停止，运算结束。而纸带留下的字符序列作为输出，由人为解码为自然语言。</p><h2 id="可计算问题"><a href="#可计算问题" class="headerlink" title="可计算问题"></a>可计算问题</h2><p>图灵在图灵机思想中证明了，假设上述所说的功能都能以某种物理形式实现，那么任何可计算问题都可以被解决。</p><p>在计算机领域，我们研究的一切问题都是计算问题，计算问题泛指一切与计算相关的问题。比如：</p><ul><li>给定一个正整数 n，判断它是否是质数；</li><li>给定一个0-1序列，把它们按位取反；</li><li>给定一个字符串，判断某个字符是否存在，以及查找存在的位置；</li><li>给定一个蕴含逻辑的命题，求它的逆否命题；</li></ul><p>相反，非计算问题为：</p><ul><li>今晚看什么书；</li><li>你为什么叫白景屹；</li></ul><p>计算问题有的可解决，有的不可解决。从而引出计算问题的可计算性（computability），它可以被理解为”是否存在一个算法，能解决在任何输入下的此计算问题”。比如上面的问题”给定一个正整数，判断它是否是质数”。我们确实可以找到一个算法判断一个数是不是质数，比如从2遍历到n−1，看n是否可以整除它，因此，这个问题是可计算的。</p><p>对于不可计算的计算问题，比如停机问题（Halting Problem）：给定一段程序的描述和该程序的一个有效输入，运行这个程序，程序最终是会终止还是陷入无限循环。</p><p>很明显，这个计算问题不可计算，我们不能找到一个算法在任何情况下都判断它。</p><p>回到可计算问题，换言之，对于一个问题，对于任意输入，只要人类可以保证算出结果（不管花费多久），则图灵机也可以保证算出结果（不管花费多久）。</p><h2 id="图灵完备Turing-Completeness"><a href="#图灵完备Turing-Completeness" class="headerlink" title="图灵完备Turing Completeness"></a>图灵完备Turing Completeness</h2><p>图灵完备性是针对一套数据操作规则而言的概念。数据操作规则可以是一个编程语言，也可以是计算机里具体的一个指令集。当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性。</p><p>也就是当一套数据操作具有图灵完备性时，该数据操作可以解决任何可计算问题。</p><p>RNN已被证明是图灵完备的，因此，RNN可以解决任何可计算问题</p><p>基于Brainfuck感受图灵完备</p><p>当下的主流编程语言（C++，Java，Python）都是图灵完备的语言。回到语言的底层，一切编程语言实现的功能完全一样，本质上就是一个图灵机。</p><p>Brainfuck（BF），是一种极小化的程序语言，它是由Urban Müller在1993年创造的。它一共只包含8个有效字符，每个有效字符就是一条指令。语言非常接近机器指令，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.</span><br></pre></td></tr></table></figure><p>编译后，控制台打印”Hello World!”。BF的工作机制与图灵机高度一致。首先存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为0。此外，还有一个数据指针，每一时刻都指向数组的某一任意元素。指针可以向左或向右移动，也可以读取或修改当前值。</p><p>BF中的8个有效字符为：</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>&gt;</td><td>指针向右移动1格</td></tr><tr><td>&lt;</td><td>指针向左移动1格</td></tr><tr><td>+</td><td>使指针当前格中的数值加1</td></tr><tr><td>-</td><td>使指针当前格中的数值减1</td></tr><tr><td>.</td><td>把当前格中的数值按ASCII表输出到终端</td></tr><tr><td>,</td><td>从终端接受1byte数据，存储其ASCII对应的数值到当前格</td></tr><tr><td>[</td><td>当指针当前值为0时，程序跳转至与之对应的 ] 之后；否则程序正常执行</td></tr><tr><td>]</td><td>程序跳转回与之对应的 [ 处</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ltrace(1) — Linux Manual Page</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ltrace/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ltrace/</url>
      
        <content type="html"><![CDATA[<h1 id="ltrace-1-—-Linux-manual-page"><a href="#ltrace-1-—-Linux-manual-page" class="headerlink" title="ltrace(1) — Linux manual page"></a>ltrace(1) — Linux manual page</h1><table><thead><tr><th><a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#NAME">NAME</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#SYNOPSIS">SYNOPSIS</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#DESCRIPTION">DESCRIPTION</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#OPTIONS">OPTIONS</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#FILTER_SPECIFICATIONS">FILTER SPECIFICATIONS</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#FILTER_EXPRESSIONS">FILTER EXPRESSIONS</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#PROTOTYPE_LIBRARY_DISCOVERY">PROTOTYPE LIBRARY DISCOVERY</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#BUGS">BUGS</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#FILES">FILES</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#AUTHOR">AUTHOR</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#SEE_ALSO">SEE ALSO</a> | <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#COLOPHON">COLOPHON</a></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRACE(1)                     User Commands                    LTRACE(1)</span><br></pre></td></tr></table></figure><h2 id="NAME-top"><a href="#NAME-top" class="headerlink" title="NAME     top"></a>NAME     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ltrace - A library call tracer</span><br></pre></td></tr></table></figure><h2 id="SYNOPSIS-top"><a href="#SYNOPSIS-top" class="headerlink" title="SYNOPSIS     top"></a>SYNOPSIS     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ltrace [-e filter|-L] [-l|--library=library_pattern] [-x filter]</span><br><span class="line">[-S] [-b|--no-signals] [-i] [-w|--where=nr] [-r|-t|-tt|-ttt] [-T]</span><br><span class="line">[[-F|--config] pathlist] [-A maxelts] [-s strsize]</span><br><span class="line">[-C|--demangle] [-a|--align column] [-n|--indent nr] [-o|--output</span><br><span class="line">filename] [-D|--debug mask] [-u username] [-f] [-p pid] [[--]</span><br><span class="line">command [arg ...]]</span><br><span class="line"></span><br><span class="line">ltrace -c [-e filter|-L] [-l|--library=library_pattern] [-x</span><br><span class="line">filter] [-S] [-o|--output filename] [-f] [-p pid] [[--] command</span><br><span class="line">[arg ...]]</span><br><span class="line"></span><br><span class="line">ltrace -V|--version</span><br><span class="line"></span><br><span class="line">ltrace -h|--help</span><br></pre></td></tr></table></figure><h2 id="DESCRIPTION-top"><a href="#DESCRIPTION-top" class="headerlink" title="DESCRIPTION     top"></a>DESCRIPTION     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ltrace is a program that simply runs the specified command until</span><br><span class="line">it exits.  It intercepts and records the dynamic library calls</span><br><span class="line">which are called by the executed process and the signals which</span><br><span class="line">are received by that process.  It can also intercept and print</span><br><span class="line">the system calls executed by the program.</span><br><span class="line"></span><br><span class="line">Its use is very similar to strace(1).</span><br><span class="line"></span><br><span class="line">ltrace shows parameters of invoked functions and system calls.</span><br><span class="line">To determine what arguments each function has, it needs external</span><br><span class="line">declaration of function prototypes.  Those are stored in files</span><br><span class="line">called prototype libraries--see ltrace.conf(5) for details on the</span><br><span class="line">syntax of these files.  See the section PROTOTYPE LIBRARY</span><br><span class="line">DISCOVERY to learn how ltrace finds prototype libraries.</span><br></pre></td></tr></table></figure><h2 id="OPTIONS-top"><a href="#OPTIONS-top" class="headerlink" title="OPTIONS     top"></a>OPTIONS     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">-a, --align column</span><br><span class="line">       Align return values in a specific column (default column</span><br><span class="line">       is 5/8 of screen width).</span><br><span class="line"></span><br><span class="line">-A maxelts</span><br><span class="line">       Maximum number of array elements to print before</span><br><span class="line">       suppressing the rest with an ellipsis (&quot;...&quot;).  This also</span><br><span class="line">       limits number of recursive structure expansions.</span><br><span class="line"></span><br><span class="line">-b, --no-signals</span><br><span class="line">       Disable printing of signals received by the traced</span><br><span class="line">       process.</span><br><span class="line"></span><br><span class="line">-c     Count time and calls for each library call and report a</span><br><span class="line">       summary on program exit.</span><br><span class="line"></span><br><span class="line">-C, --demangle</span><br><span class="line">       Decode (demangle) low-level symbol names into user-level</span><br><span class="line">       names.  Besides removing any initial underscore prefix</span><br><span class="line">       used by the system, this makes C++ function names</span><br><span class="line">       readable.</span><br><span class="line"></span><br><span class="line">-D, --debug mask</span><br><span class="line">       Show debugging output of ltrace itself.  mask is a number</span><br><span class="line">       describing which debug messages should be displayed.  Use</span><br><span class="line">       the option -Dh to see what can be used, but note that</span><br><span class="line">       currently the only reliable debugmask is 77, which shows</span><br><span class="line">       all debug messages.</span><br><span class="line"></span><br><span class="line">-e filter</span><br><span class="line">       A qualifying expression which modifies which library calls</span><br><span class="line">       (i.e. calls done through PLT slots, which are typically</span><br><span class="line">       calls from the main binary to a library, or inter-library</span><br><span class="line">       calls) to trace. Usage examples and the syntax description</span><br><span class="line">       appear below in sections FILTER SPECIFICATIONS and FILTER</span><br><span class="line">       EXPRESSIONS. If more than one -e option appears on the</span><br><span class="line">       command line, the library calls that match any of them are</span><br><span class="line">       traced. If no -e is given, @MAIN is assumed as a default.</span><br><span class="line"></span><br><span class="line">-f     Trace child processes as they are created by currently</span><br><span class="line">       traced processes as a result of the fork(2) or clone(2)</span><br><span class="line">       system calls.  The new process is attached immediately.</span><br><span class="line"></span><br><span class="line">-F, --config pathlist</span><br><span class="line">       Contains a colon-separated list of paths.  If a path</span><br><span class="line">       refers to a directory, that directory is considered when</span><br><span class="line">       prototype libraries are searched (see the section</span><br><span class="line">       PROTOTYPE LIBRARY DISCOVERY).  If it refers to a file,</span><br><span class="line">       that file is imported implicitly to all loaded prototype</span><br><span class="line">       libraries.</span><br><span class="line"></span><br><span class="line">-h, --help</span><br><span class="line">       Show a summary of the options to ltrace and exit.</span><br><span class="line"></span><br><span class="line">-i     Print the instruction pointer at the time of the library</span><br><span class="line">       call.</span><br><span class="line"></span><br><span class="line">-l, --library library_pattern</span><br><span class="line">       Display only calls to functions implemented by libraries</span><br><span class="line">       that match library_pattern.  This is as if you specified</span><br><span class="line">       one -e for every symbol implemented in a library specified</span><br><span class="line">       by library_pattern.  Multiple library patters can be</span><br><span class="line">       specified with several instances of this option.  Usage</span><br><span class="line">       examples and the syntax description of library_pattern</span><br><span class="line">       appear below in sections FILTER SPECIFICATIONS and FILTER</span><br><span class="line">       EXPRESSIONS.</span><br><span class="line"></span><br><span class="line">       Note that while this option selects calls that might be</span><br><span class="line">       directed to the selected libraries, there&#x27;s no actual</span><br><span class="line">       guarantee that the call won&#x27;t be directed elsewhere due to</span><br><span class="line">       e.g. LD_PRELOAD or simply dependency ordering.  If you</span><br><span class="line">       want to make sure that symbols in given library are</span><br><span class="line">       actually called, use -x @library_pattern instead.</span><br><span class="line"></span><br><span class="line">-L     When no -e option is given, don&#x27;t assume the default</span><br><span class="line">       action of @MAIN.  In practice this means that library</span><br><span class="line">       calls will not be traced.</span><br><span class="line"></span><br><span class="line">-n, --indent nr</span><br><span class="line">       Indent trace output by nr spaces for each level of call</span><br><span class="line">       nesting. Using this option makes the program flow</span><br><span class="line">       visualization easy to follow.  This indents uselessly also</span><br><span class="line">       functions that never return, such as service functions for</span><br><span class="line">       throwing exceptions in the C++ runtime.</span><br><span class="line"></span><br><span class="line">-o, --output filename</span><br><span class="line">       Write the trace output to the file filename rather than to</span><br><span class="line">       stderr.</span><br><span class="line"></span><br><span class="line">-p pid Attach to the process with the process ID pid and begin</span><br><span class="line">       tracing.  This option can be used together with passing a</span><br><span class="line">       command to execute.  It is possible to attach to several</span><br><span class="line">       processes by passing more than one option -p.</span><br><span class="line"></span><br><span class="line">-r     Print a relative timestamp with each line of the trace.</span><br><span class="line">       This records the time difference between the beginning of</span><br><span class="line">       successive lines.</span><br><span class="line"></span><br><span class="line">-s strsize</span><br><span class="line">       Specify the maximum string size to print (the default is</span><br><span class="line">       32).</span><br><span class="line"></span><br><span class="line">-S     Display system calls as well as library calls</span><br><span class="line"></span><br><span class="line">-t     Prefix each line of the trace with the time of day.</span><br><span class="line"></span><br><span class="line">-tt    If given twice, the time printed will include the</span><br><span class="line">       microseconds.</span><br><span class="line"></span><br><span class="line">-ttt   If given thrice, the time printed will include the</span><br><span class="line">       microseconds and the leading portion will be printed as</span><br><span class="line">       the number of seconds since the epoch.</span><br><span class="line"></span><br><span class="line">-T     Show  the  time  spent inside each call. This records the</span><br><span class="line">       time difference between the beginning and the end of each</span><br><span class="line">       call.</span><br><span class="line"></span><br><span class="line">-u username</span><br><span class="line">       Run command with the userid, groupid and supplementary</span><br><span class="line">       groups of username.  This option is only useful when</span><br><span class="line">       running as root and enables the correct execution of</span><br><span class="line">       setuid and/or setgid binaries.</span><br><span class="line"></span><br><span class="line">-w, --where nr</span><br><span class="line">       Show backtrace of nr stack frames for each traced</span><br><span class="line">       function. This option enabled only if elfutils or</span><br><span class="line">       libunwind support was enabled at compile time.</span><br><span class="line"></span><br><span class="line">-x filter</span><br><span class="line">       A qualifying expression which modifies which symbol table</span><br><span class="line">       entry points to trace (those are typically calls inside a</span><br><span class="line">       library or main binary, though PLT calls, traced by -e,</span><br><span class="line">       land on entry points as well). Usage examples and the</span><br><span class="line">       syntax description appear below in sections FILTER</span><br><span class="line">       SPECIFICATIONS and FILTER EXPRESSIONS. If more than one -x</span><br><span class="line">       option appears on the command line, the symbols that match</span><br><span class="line">       any of them are traced. No entry points are traced if no</span><br><span class="line">       -x is given.</span><br><span class="line"></span><br><span class="line">-V, --version</span><br><span class="line">       Show the version number of ltrace and exit.</span><br></pre></td></tr></table></figure><h2 id="FILTER-SPECIFICATIONS-top"><a href="#FILTER-SPECIFICATIONS-top" class="headerlink" title="FILTER SPECIFICATIONS     top"></a>FILTER SPECIFICATIONS     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Filters are specified with the -l, -e and -x options. In short</span><br><span class="line">they mean:</span><br><span class="line"></span><br><span class="line">-x is ´show me what calls these symbols (including local calls)´</span><br><span class="line"></span><br><span class="line">-e is ´show me what calls these symbols (inter-library calls</span><br><span class="line">only)´</span><br><span class="line"></span><br><span class="line">-l is ´show me what calls into this library´</span><br><span class="line"></span><br><span class="line">Suppose I have a library defined with this header tstlib.h:</span><br><span class="line"></span><br><span class="line"> void func_f_lib(void);</span><br><span class="line"> void func_g_lib(void);</span><br><span class="line"></span><br><span class="line">and this implementation tstlib.c:</span><br><span class="line"></span><br><span class="line"> #include &quot;tstlib.h&quot;</span><br><span class="line"> void func_f_lib(void)</span><br><span class="line"> &#123;</span><br><span class="line">     func_g_lib();</span><br><span class="line"> &#125;</span><br><span class="line"> void func_g_lib(void)</span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">Suppose I have an executable that uses this library defined like</span><br><span class="line">this tst.c:</span><br><span class="line"></span><br><span class="line"> #include &quot;tstlib.h&quot;</span><br><span class="line"> void func_f_main(void)</span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> void main(void)</span><br><span class="line"> &#123;</span><br><span class="line">     func_f_main();</span><br><span class="line">     func_f_lib();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">If linking without -Bsymbolic, the internal func_g_lib() call</span><br><span class="line">uses the PLT like external calls, and thus ltrace says:</span><br><span class="line"></span><br><span class="line"> $ ltrace -x &#x27;func*&#x27; -L ./tst</span><br><span class="line"> func_f_main()                             = &lt;void&gt;</span><br><span class="line"> func_f_lib@tstlib.so( &lt;unfinished ...&gt;</span><br><span class="line"> func_g_lib@tstlib.so()                    = &lt;void&gt;</span><br><span class="line"> &lt;... func_f_lib resumed&gt; )                = &lt;void&gt;</span><br><span class="line"> +++ exited (status 163) +++</span><br><span class="line"></span><br><span class="line"> $ ltrace -e &#x27;func*&#x27; ./tst</span><br><span class="line"> tst-&gt;func_f_lib( &lt;unfinished ...&gt;</span><br><span class="line"> tstlib.so-&gt;func_g_lib()                   = &lt;void&gt;</span><br><span class="line"> &lt;... func_f_lib resumed&gt; )                = &lt;void&gt;</span><br><span class="line"> +++ exited (status 163) +++</span><br><span class="line"></span><br><span class="line"> $ ltrace -l tstlib.so ./tst</span><br><span class="line"> tst-&gt;func_f_lib( &lt;unfinished ...&gt;</span><br><span class="line"> tstlib.so-&gt;func_g_lib()                   = &lt;void&gt;</span><br><span class="line"> &lt;... func_f_lib resumed&gt; )                = &lt;void&gt;</span><br><span class="line"> +++ exited (status 163) +++</span><br><span class="line"></span><br><span class="line">By contrast, if linking with -Bsymbolic, then the internal</span><br><span class="line">func_g_lib() call bypasses the PLT, and ltrace says:</span><br><span class="line"></span><br><span class="line"> $ ltrace -x &#x27;func*&#x27; -L ./tst</span><br><span class="line"> func_f_main() = &lt;void&gt;</span><br><span class="line"> func_f_lib@tstlib.so( &lt;unfinished ...&gt;</span><br><span class="line"> func_g_lib@tstlib.so()                    = &lt;void&gt;</span><br><span class="line"> &lt;... func_f_lib resumed&gt; )                = &lt;void&gt;</span><br><span class="line"> +++ exited (status 163) +++</span><br><span class="line"></span><br><span class="line"> $ ltrace -e &#x27;func*&#x27; ./tst</span><br><span class="line"> tst-&gt;func_f_lib()                         = &lt;void&gt;</span><br><span class="line"> +++ exited (status 163) +++</span><br><span class="line"></span><br><span class="line"> $ ltrace -l tstlib.so ./tst</span><br><span class="line"> tst-&gt;func_f_lib()                         = &lt;void&gt;</span><br><span class="line"> +++ exited (status 163) +++</span><br></pre></td></tr></table></figure><h2 id="FILTER-EXPRESSIONS-top"><a href="#FILTER-EXPRESSIONS-top" class="headerlink" title="FILTER EXPRESSIONS     top"></a>FILTER EXPRESSIONS     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Filter expression is a chain of glob- or regexp-based rules that</span><br><span class="line">are used to pick symbols for tracing from libraries that the</span><br><span class="line">process uses.  Most of it is intuitive, so as an example, the</span><br><span class="line">following would trace calls to malloc and free, except those done</span><br><span class="line">by libc:</span><br><span class="line"></span><br><span class="line">-e malloc+free-@libc.so*</span><br><span class="line"></span><br><span class="line">This reads: trace malloc and free, but don&#x27;t trace anything that</span><br><span class="line">comes from libc.  Semi-formally, the syntax of the above example</span><br><span class="line">looks approximately like this:</span><br><span class="line"></span><br><span class="line">&#123;[+-][symbol_pattern][@library_pattern]&#125;</span><br><span class="line"></span><br><span class="line">Symbol_pattern is used to match symbol names, library_pattern to</span><br><span class="line">match library SONAMEs.  Both are implicitly globs, but can be</span><br><span class="line">regular expressions as well (see below).  The glob syntax</span><br><span class="line">supports meta-characters * and ? and character classes, similarly</span><br><span class="line">to what basic bash globs support.  ^ and $ are recognized to</span><br><span class="line">mean, respectively, start and end of given name.</span><br><span class="line"></span><br><span class="line">Both symbol_pattern and library_pattern have to match the whole</span><br><span class="line">name.  If you want to match only part of the name, surround it</span><br><span class="line">with one or two *&#x27;s as appropriate.  The exception is if the</span><br><span class="line">pattern is not mentioned at all, in which case it&#x27;s as if the</span><br><span class="line">corresponding pattern were *.  (So malloc is really malloc@* and</span><br><span class="line">@libc.* is really *@libc.*.)</span><br><span class="line"></span><br><span class="line">In libraries that don&#x27;t have an explicit SONAME, basename is</span><br><span class="line">taken for SONAME.  That holds for main binary as well: /bin/echo</span><br><span class="line">has an implicit SONAME of echo.  In addition to that, special</span><br><span class="line">library pattern MAIN always matches symbols in the main binary</span><br><span class="line">and never a library with actual SONAME MAIN (use e.g. ^MAIN or</span><br><span class="line">[M]AIN for that).</span><br><span class="line"></span><br><span class="line">If the symbol or library pattern is surrounded in slashes (/like</span><br><span class="line">this/), then it is considered a regular expression instead.  As a</span><br><span class="line">shorthand, instead of writing /x/@/y/, you can write /x@y/.</span><br><span class="line"></span><br><span class="line">If the library pattern starts with a slash, it is not a SONAME</span><br><span class="line">expression, but a path expression, and is matched against the</span><br><span class="line">library path name.</span><br><span class="line"></span><br><span class="line">The first rule may lack a sign, in which case + is assumed.  If,</span><br><span class="line">on the other hand, the first rule has a - sign, it is as if there</span><br><span class="line">was another rule @ in front of it, which has the effect of</span><br><span class="line">tracing complement of given rule.</span><br><span class="line"></span><br><span class="line">The above rules are used to construct the set of traced symbols.</span><br><span class="line">Each candidate symbol is passed through the chain of above rules.</span><br><span class="line">Initially, the symbol is unmarked.  If it matches a + rule, it</span><br><span class="line">becomes marked, if it matches a - rule, it becomes unmarked</span><br><span class="line">again.  If, after applying all rules, the symbol is marked, it</span><br><span class="line">will be traced.</span><br></pre></td></tr></table></figure><h2 id="PROTOTYPE-LIBRARY-DISCOVERY-top"><a href="#PROTOTYPE-LIBRARY-DISCOVERY-top" class="headerlink" title="PROTOTYPE LIBRARY DISCOVERY     top"></a>PROTOTYPE LIBRARY DISCOVERY     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">When a library is mapped into the address space of a traced</span><br><span class="line">process, ltrace needs to know what the prototypes are of</span><br><span class="line">functions that this library implements.  For purposes of ltrace,</span><br><span class="line">prototype really is a bit more than just type signature: it&#x27;s</span><br><span class="line">also formatting of individual parameters and of return value.</span><br><span class="line">These prototypes are stored in files called prototype libraries.</span><br><span class="line"></span><br><span class="line">After a library is mapped, ltrace finds out what its SONAME is.</span><br><span class="line">It then looks for a file named SONAME.conf--e.g. protolib for</span><br><span class="line">libc.so.6 would be in a file called libc.so.6.conf.  When such</span><br><span class="line">file is found (more about where ltrace looks for these files is</span><br><span class="line">below), ltrace reads all prototypes stored therein.  When a</span><br><span class="line">symbol table entry point (such as those traced by -x) is hit, the</span><br><span class="line">prototype is looked up in a prototype library corresponding to</span><br><span class="line">the library where the hit occurred.  When a library call (such as</span><br><span class="line">those traced by -e and -l) is hit, the prototype is looked up in</span><br><span class="line">all prototype libraries loaded for given process.  That is</span><br><span class="line">necessary, because a library call is traced in a PLT table of a</span><br><span class="line">caller library, but the prototype is described at callee library.</span><br><span class="line"></span><br><span class="line">If a library has no SONAME, basename of library file is</span><br><span class="line">considered instead.  For the main program binary, basename is</span><br><span class="line">considered as well (e.g. protolib for /bin/echo would be called</span><br><span class="line">echo.conf).  If a name corresponding to soname (e.g.</span><br><span class="line">libc.so.6.conf) is not found, and the module under consideration</span><br><span class="line">is a shared library, ltrace also tries partial matches.  Ltrace</span><br><span class="line">snips one period after another, retrying the search, until either</span><br><span class="line">a protolib is found, or X.so is all that&#x27;s left.  Thus</span><br><span class="line">libc.so.conf would be considered, but libc.conf not.</span><br><span class="line"></span><br><span class="line">When looking for a prototype library, ltrace potentially looks</span><br><span class="line">into several directories.  On Linux, those are</span><br><span class="line">$XDG_CONFIG_HOME/ltrace, $HOME/.ltrace, X/ltrace for each X in</span><br><span class="line">$XDG_CONFIG_DIRS and /usr/share/ltrace.  If the environment</span><br><span class="line">variable XDG_CONFIG_HOME is not defined, ltrace looks into</span><br><span class="line">$HOME/.config/ltrace instead.</span><br><span class="line"></span><br><span class="line">There&#x27;s also a mechanism for loading legacy config files.  If</span><br><span class="line">$HOME/.ltrace.conf exists it is imported to every loaded</span><br><span class="line">prototype library.  Similarly for /etc/ltrace.conf.  If both</span><br><span class="line">exist, both are imported, and $HOME/.ltrace.conf is consulted</span><br><span class="line">before /etc/ltrace.conf.</span><br><span class="line"></span><br><span class="line">If -F contains any directories, those are searched in precedence</span><br><span class="line">to the above system directories, in the same order in which they</span><br><span class="line">are mentioned in -F.  Any files passed in -F are imported</span><br><span class="line">similarly to above legacy config files, before them.</span><br><span class="line"></span><br><span class="line">See ltrace.conf(5) for details on the syntax of ltrace prototype</span><br><span class="line">library files.</span><br></pre></td></tr></table></figure><h2 id="BUGS-top"><a href="#BUGS-top" class="headerlink" title="BUGS     top"></a>BUGS     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">It has most of the bugs stated in strace(1).</span><br><span class="line"></span><br><span class="line">It only works on Linux and in some architectures.</span><br><span class="line"></span><br><span class="line">If you would like to report a bug, send a message to the mailing</span><br><span class="line">list (ltrace-devel@lists.alioth.debian.org), or use the</span><br><span class="line">reportbug(1) program if you are under the Debian GNU/Linux</span><br><span class="line">distribution.</span><br></pre></td></tr></table></figure><h2 id="FILES-top"><a href="#FILES-top" class="headerlink" title="FILES     top"></a>FILES     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/ltrace.conf</span><br><span class="line">       System configuration file</span><br><span class="line"></span><br><span class="line">~/.ltrace.conf</span><br><span class="line">       Personal config file, overrides /etc/ltrace.conf</span><br></pre></td></tr></table></figure><h2 id="AUTHOR-top"><a href="#AUTHOR-top" class="headerlink" title="AUTHOR     top"></a>AUTHOR     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Juan Cespedes &lt;cespedes@debian.org&gt;</span><br><span class="line">Petr Machata &lt;pmachata@redhat.com&gt;</span><br></pre></td></tr></table></figure><h2 id="SEE-ALSO-top"><a href="#SEE-ALSO-top" class="headerlink" title="SEE ALSO     top"></a>SEE ALSO     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ltrace.conf(5), strace(1), ptrace(2)</span><br></pre></td></tr></table></figure><h2 id="COLOPHON-top"><a href="#COLOPHON-top" class="headerlink" title="COLOPHON     top"></a>COLOPHON     <a href="https://www.man7.org/linux/man-pages/man1/ltrace.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">This page is part of the ltrace (library call tracer) project.</span><br><span class="line">Information about the project can be found at</span><br><span class="line">⟨http://ltrace.org/⟩.  If you have a bug report for this manual</span><br><span class="line">page, see ⟨http://ltrace.org/⟩.  This page was obtained from the</span><br><span class="line">project&#x27;s upstream Git repository</span><br><span class="line">⟨https://github.com/dkogan/ltrace⟩ on 2021-08-27.  (At that time,</span><br><span class="line">the date of the most recent commit that was found in the</span><br><span class="line">repository was 2016-09-01.)  If you discover any rendering</span><br><span class="line">problems in this HTML version of the page, or you believe there</span><br><span class="line">is a better or more up-to-date source for the page, or you have</span><br><span class="line">corrections or improvements to the information in this COLOPHON</span><br><span class="line">(which is not part of the original manual page), send a mail to</span><br><span class="line">man-pages@man7.org</span><br><span class="line"></span><br><span class="line">                       January 2013                     LTRACE(1)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Perf IPC以及CPU利用率</title>
      <link href="/2022/10/13/01%20OS/Linux/Perf/perf_ipc/"/>
      <url>/2022/10/13/01%20OS/Linux/Perf/perf_ipc/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU-流水线工作原理"><a href="#CPU-流水线工作原理" class="headerlink" title="CPU 流水线工作原理"></a>CPU 流水线工作原理</h1><p><a href="https://plantegg.github.io/2020/05/31/Perf%20IPC%E4%BB%A5%E5%8F%8ACPU%E5%88%A9%E7%94%A8%E7%8E%87/">https://plantegg.github.io/2020/05/31/Perf%20IPC%E4%BB%A5%E5%8F%8ACPU%E5%88%A9%E7%94%A8%E7%8E%87/</a><br>cycles：CPU时钟周期。CPU从它的指令集(instruction set)中选择指令执行。一个指令包含以下的步骤，每个步骤由CPU的一个叫做功能单元(functional unit)的组件来进行处理，每个步骤的执行都至少需要花费一个时钟周期。</p><p>指令读取(instruction fetch， IF)</p><p>指令解码(instruction decode， ID)</p><p>执行(execute， EXE)</p><p>内存访问(memory access，MEM)</p><p>寄存器回写(register write-back， WB)</p><p>五个步骤只能串行，但是可以做成pipeline提升效率，也就是第一个指令做第二步的时候，指令读取单元可以去读取下一个指令了，如果有一个指令慢就会造成stall，也就是pipeline有地方卡壳了。<br>另外cpu可以同时有多条pipeline，这也就是理论上最大的IPC.<br>stalled-cycles，则是指令管道未能按理想状态发挥并行作用，发生停滞的时钟周期。stalled-cycles-frontend指指令读取或解码的指令步骤，而stalled-cycles-backend则是指令执行步骤。第二列中的cycles idle其实意思跟stalled是一样的，由于指令执行停滞了，所以指令管道也就空闲了，千万不要误解为CPU的空闲率。这个数值是由stalled-cycles-frontend或stalled-cycles-backend除以上面的cycles得出的</p><p>Back-end Bound<br>Back-end Bound 分为 Memory Bound 和 Core Bound，通过在每个周期内基于执行单元的占用情况来分析 Back-end 停顿。为了达到尽可能大的 IPC，需要使得执行单元保持繁忙。例如，在一个有4个 slot 的机器中，如果在稳定状态下只能执行三个或更少的 uOps，就不能达到最佳状态，即 IPC 等于4。这些次优周期称为 Execution Stalls。</p><p>非流水线：</p><p>对于非流水计算机而言，上一条指令的 5 个子过程全部执行完毕后才能开始下一条指令，每隔 5 个时 钟周期才有一个输出结果。因此，图3中用了 15 个时钟周期才完成 3 条指令，每条指令平均用时 5 个时钟周期。 非流水线工作方式的控制比较简单，但部件的利用率较低，系统工作速度较慢。</p><p>毫无疑问，非流水线效率很低下，5个单元同时只能有一个单元工作，每隔 5 个时 钟周期才有一个输出结果。每条指令用时5个时间周期。</p><p>标量流水线, 标量（Scalar）流水计算机是只有一条指令流水线的计算机:</p><p>对标量流水计算机而言，上一条指令与下一条指令的 5 个子过程在时间上可以重叠执行，当流水线满 载时，每一个时钟周期就可以输出一个结果。因此，图中仅用了 9 个时钟周期就完成了 5 条指令，每条指令平均用时 1.8 个时钟周期。</p><p>采用标量流水线工作方式，虽然每条指令的执行时间并未缩短，但 CPU 运行指令的总体速度却能成倍 提高。当然，作为速度提高的代价，需要增加部分硬件才能实现标量流水。</p><p>超标量流水线：所谓超标量（Superscalar）流 水计算机，是指它具有两条以上的指令流水线</p><p>当流水线满载时，每一个时钟周期可以执行 2 条以上的指令。图中仅用了 9 个时钟周期就完成了 10 条指令，每条指令平均用时 0.9 个时钟周期。 超标量流水计算机是时间并行技术和空间并行技术的综合应用。</p><p>在流水计算机中，指令的处理是重叠进行的，前一条指令还没有结束，第二、三条指令就陆续开始工 作。由于多条指令的重叠处理，当后继指令所需的操作数刚好是前一指令的运算结果时，便发生数据相关冲突。由于这两条指令的执行顺序直接影响到操作数读取的内容，必须等前一条指令执行完毕后才能执行后一条指令。</p><p>OoOE— Out-of-Order Execution 乱序执行也是在 Pentium Pro 开始引入的，它有些类似于多线程的概念。乱序执行是为了直接提升 ILP(Instruction Level Parallelism)指令级并行化的设计，在多个执行单元的超标量设计当中，一系列的执行单元可以同时运行一些没有数据关联性的若干指令，只有需要等待其他指令运算结果的数据会按照顺序执行，从而总体提升了运行效率。乱序执行引擎是一个很重要的部分，需要进行复杂的调度管理。</p><p>每一个功能单元的流水线的长度是不同的。事实上，不同的功能单元的流水线长度本来就不一样。我们平时所说的 14 级流水线，指的通常是进行整数计算指令的流水线长度。如果是浮点数运算，实际的流水线长度则会更长一些。</p><p>指令缓存（Instruction Cache）和数据缓存（Data Cache）<br>在第 1 条指令执行到访存（MEM）阶段的时候，流水线里的第 4 条指令，在执行取指令（Fetch）的操作。访存和取指令，都要进行内存数据的读取。我们的内存，只有一个地址译码器的作为地址输入，那就只能在一个时钟周期里面读取一条数据，没办法同时执行第 1 条指令的读取内存数据和第 4 条指令的读取指令代码。</p><p>把内存拆成两部分的解决方案，在计算机体系结构里叫作哈佛架构（Harvard Architecture），来自哈佛大学设计Mark I 型计算机时候的设计。我们今天使用的 CPU，仍然是冯·诺依曼体系结构的，并没有把内存拆成程序内存和数据内存这两部分。因为如果那样拆的话，对程序指令和数据需要的内存空间，我们就没有办法根据实际的应用去动态分配了。虽然解决了资源冲突的问题，但是也失去了灵活性。</p><p>在流水线产生依赖的时候必须pipeline stall，也就是让依赖的指令执行NOP。</p><p>每个指令需要的cycle<br>Intel xeon</p><p>perf 使用<br>sudo perf record -g -a -e skb:kfree_skb &#x2F;&#x2F;perf 记录丢包调用栈 然后sudo perf script 查看 （网络报文被丢弃时会调用该函数kfree_skb）<br>perf record -e ‘skb:consume_skb’ -ag  &#x2F;&#x2F;记录网络消耗<br>perf probe –add tcp_sendmsg &#x2F;&#x2F;增加监听probe  perf record -e probe:tcp_sendmsg -aR sleep 1<br>sudo perf sched record – sleep 1 &#x2F;&#x2F;记录cpu调度的延时<br>sudo perf sched latency &#x2F;&#x2F;查看<br>可以通过perf看到cpu的使用情况：</p><p>$sudo perf stat -a – sleep 10</p><p>Performance counter stats for ‘system wide’:</p><p> 239866.330098      task-clock (msec)         #   23.985 CPUs utilized    &#x2F;10*1000        (100.00%)<br>        45,709      context-switches          #    0.191 K&#x2F;sec                    (100.00%)<br>         1,715      cpu-migrations            #    0.007 K&#x2F;sec                    (100.00%)<br>        79,586      page-faults               #    0.332 K&#x2F;sec<br> 3,488,525,170      cycles                    #    0.015 GHz                      (83.34%)<br> 9,708,140,897      stalled-cycles-frontend   #  278.29% &#x2F;cycles frontend cycles idle     (83.34%)<br> 9,314,891,615      stalled-cycles-backend    #  267.02% &#x2F;cycles backend  cycles idle     (66.68%)<br> 2,292,955,367      instructions              #    0.66  insns per cycle  insn&#x2F;cycles<br>                                             #    4.23  stalled cycles per insn stalled-cycles-frontend&#x2F;insn (83.34%)<br>   447,584,805      branches                  #    1.866 M&#x2F;sec                    (83.33%)<br>     8,470,791      branch-misses             #    1.89% of all branches          (83.33%)</p><p>IPC测试<br>实际运行的时候增加如下nop到100个以上</p><p>void main() {</p><pre><code>while(1) &#123;     __asm__ (&quot;nop\n\t&quot;             &quot;nop\n\t&quot;             &quot;nop&quot;);&#125;</code></pre><p>}<br>鲲鹏920运行，ipc是指每个core的IPC，如果同时运行两个如上测试程序，每个程序的IPC都是3.99</p><p>#perf stat – .&#x2F;nop.out<br>failed to read counter branches</p><p> Performance counter stats for ‘.&#x2F;nop.out’:</p><pre><code>   8826.948260      task-clock (msec)         #    1.000 CPUs utilized             8      context-switches          #    0.001 K/sec             0      cpu-migrations            #    0.000 K/sec            37      page-faults               #    0.004 K/sec22,949,862,030      cycles                    #    2.600 GHz     2,099,719      stalled-cycles-frontend   #    0.01% frontend cycles idle    18,859,839      stalled-cycles-backend    #    0.08% backend  cycles idle91,465,043,922      instructions              #    3.99  insns per cycle                                              #    0.00  stalled cycles per insn</code></pre><p>   <not supported>      branches<br>            33,262      branch-misses             #    0.00% of all branches</p><pre><code>   8.827886000 seconds time elapsed</code></pre><p>intel X86 8260</p><p>#perf stat – .&#x2F;nop.out</p><p> Performance counter stats for ‘.&#x2F;nop.out’:</p><pre><code>  65061.160345      task-clock (msec)         #    1.001 CPUs utilized            46      context-switches          #    0.001 K/sec            92      cpu-migrations            #    0.001 K/sec           108      page-faults               #    0.002 K/sec</code></pre><p>   155,659,827,263      cycles                    #    2.393 GHz<br>   <not supported>      stalled-cycles-frontend<br>   <not supported>      stalled-cycles-backend<br>   603,247,401,995      instructions              #    3.88  insns per cycle<br>     4,742,051,659      branches                  #   72.886 M&#x2F;sec<br>         1,799,428      branch-misses             #    0.04% of all branches</p><pre><code>  65.012821629 seconds time elapsed</code></pre><p>这两块CPU理论IPC最大值都是4，实际x86离理论值更远一些. 增加while循环中的nop数量（从132增加到432个）IPC能提升到3.92</p><p>IPC和超线程的关系<br>IPC 和一个core上运行多少个进程没有关系。实际测试将两个nop绑定到一个core上，IPC不变, 因为IPC就是从core里面取到的，不针对具体进程。但是如果是两个进程绑定到一个物理core以及对应的超线程core上那么IPC就会减半。如果程序是IO bound（比如需要频繁读写内存）首先IPC远远低于理论值4的，这个时候超线程同时工作的话IPC基本能翻倍</p><p>对应的CPU使用率, 两个进程的CPU使用率是200%，实际产出IPC是2.1+1.64&#x3D;3.75，比单个进程的IPC为3.92小多了。而单个进程CPU使用率才100%</p><p>以上测试CPU为Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz (Thread(s) per core: 2)</p><p>perf 和火焰图<br>调用 perf record 采样几秒钟，一般需要加 -g 参数，也就是 call-graph，还需要抓取函数的调用关系。在多核的机器上，还要记得加上 -a 参数，保证获取所有 CPU Core 上的函数运行情况。至于采样数据的多少，在讲解 perf 概念的时候说过，我们可以用 -c 或者 -F 参数来控制。</p><p>   83  07&#x2F;08&#x2F;19 13:56:26 sudo perf record -ag -p 4759<br>   84  07&#x2F;08&#x2F;19 13:56:50 ls &#x2F;tmp&#x2F;<br>   85  07&#x2F;08&#x2F;19 13:57:06 history |tail -16<br>   86  07&#x2F;08&#x2F;19 13:57:20 sudo chmod 777 perf.data<br>   87  07&#x2F;08&#x2F;19 13:57:33 perf script &gt;out.perf<br>   88  07&#x2F;08&#x2F;19 13:59:24 ~&#x2F;tools&#x2F;FlameGraph-master&#x2F;.&#x2F;stackcollapse-perf.pl ~&#x2F;out.perf &gt;out.folded<br>   89  07&#x2F;08&#x2F;19 14:01:01 ~&#x2F;tools&#x2F;FlameGraph-master&#x2F;flamegraph.pl out.folded &gt; kernel-perf.svg<br>   90  07&#x2F;08&#x2F;19 14:01:07 ls -lh<br>   91  07&#x2F;08&#x2F;19 14:03:33 history</p><p>$ sudo perf record -F 99 -a -g – sleep 60 &#x2F;&#x2F;-F 99 指采样每秒钟做 99 次<br>　　执行这个命令将生成一个 perf.data 文件：</p><p>执行sudo perf report -n可以生成报告的预览。<br>执行sudo perf report -n –stdio可以生成一个详细的报告。<br>执行sudo perf script可以 dump 出 perf.data 的内容。</p><h1 id="折叠调用栈"><a href="#折叠调用栈" class="headerlink" title="折叠调用栈"></a>折叠调用栈</h1><p>$ FlameGraph&#x2F;stackcollapse-perf.pl out.perf &gt; out.folded</p><h1 id="生成火焰图"><a href="#生成火焰图" class="headerlink" title="生成火焰图"></a>生成火焰图</h1><p>$ FlameGraph&#x2F;flamegraph.pl out.folded &gt; out.svg<br>ECS和perf<br>在ECS会采集不到 cycles等，cpu-clock、page-faults都是内核中的软事件，cycles&#x2F;instructions得采集cpu的PMU数据，ECS采集不到这些PMU数据。</p><p>CPU cache</p><p>查看cpu cache数据</p><p>cat &#x2F;proc&#x2F;cpuinfo |grep -i cache</p><p>如下 Linux getconf 命令的输出，除了 _LINESIZE 指示了系统的 Cache Line 的大小是 64 字节外，还给出了 Cache 类别，大小。 其中 _ASSOC 则指示了该 Cache 是几路关联 (Way Associative) 的。</p><p>$sudo getconf -a |grep CACHE<br>LEVEL1_ICACHE_SIZE                 32768<br>LEVEL1_ICACHE_ASSOC                8<br>LEVEL1_ICACHE_LINESIZE             64<br>LEVEL1_DCACHE_SIZE                 32768<br>LEVEL1_DCACHE_ASSOC                8<br>LEVEL1_DCACHE_LINESIZE             64<br>LEVEL2_CACHE_SIZE                  262144<br>LEVEL2_CACHE_ASSOC                 4<br>LEVEL2_CACHE_LINESIZE              64<br>LEVEL3_CACHE_SIZE                  3145728<br>LEVEL3_CACHE_ASSOC                 12<br>LEVEL3_CACHE_LINESIZE              64<br>LEVEL4_CACHE_SIZE                  0<br>LEVEL4_CACHE_ASSOC                 0<br>LEVEL4_CACHE_LINESIZE              0<br>Socket、核<br>一个Socket理解一个CPU，一个CPU又可以是多核的</p><p>超线程（Hyperthreading，HT）<br>一个核还可以进一步分成几个逻辑核，来执行多个控制流程，这样可以进一步提高并行程度，这一技术就叫超线程，有时叫做 simultaneous multi-threading（SMT）。</p><p>超线程技术主要的出发点是，当处理器在运行一个线程，执行指令代码时，很多时候处理器并不会使用到全部的计算能力，部分计算能力就会处于空闲状态。而超线程技术就是通过多线程来进一步“压榨”处理器。pipeline进入stalled状态就可以切到其它超线程上</p><p>举个例子，如果一个线程运行过程中，必须要等到一些数据加载到缓存中以后才能继续执行，此时 CPU 就可以切换到另一个线程，去执行其他指令，而不用去处于空闲状态，等待当前线程的数据加载完毕。通常，一个传统的处理器在线程之间切换，可能需要几万个时钟周期。而一个具有 HT 超线程技术的处理器只需要 1 个时钟周期。因此就大大减小了线程之间切换的成本，从而最大限度地让处理器满负荷运转。</p><p>ARM芯片基本不做超线程，另外请思考为什么有了应用层的多线程切换还需要CPU层面的超线程？</p><p>如果physical id和core id都一样的话，说明这两个core实际是一个物理core，其中一个是HT</p><p>测试工具 toplev<br>toplev是一个基于perf和TMAM(Top-down Microarchitecture Analysis Method)方法的应用性能分析工具。从之前的介绍文章 中可以了解到TMAM本质上是对CPU Performance Counter的整理和加工。取得Performance Counter的读数需要perf来协助，对读数的计算进而明确是Frondend bound还是Backend bound等等。</p><p>在最终计算之前，你大概需要做三件事：</p><p>明确CPU型号，因为不同的CPU，对应的PMU也不一样（依赖网络）</p><p>读取TMAM需要的perf event读数</p><p>按TMAM规定的算法计算，具体算法在这个Excel表格里</p><p>这三步可以自动化地由程序来做。本质上toplev就是在做这件事。</p><p>toplev的Github地址：<a href="https://github.com/andikleen/pmu-tools">https://github.com/andikleen/pmu-tools</a></p><p>另外补充一下，TMAM作为一种Top-down方法，它一定是分级的。通过上一级的结果下钻，最终定位性能瓶颈。那么toplev在执行的时候，也一定是包含这个“等级”概念的。</p><p>pmu-tools 的工具在第一次运行的时会通过 event_download.py 把本机环境的 PMU 映射表自动下载下来, 但是前提是你的机器能正常连接 01.day 的网络. 很抱歉我司内部的服务器都是不行的, 因此 pmu-tools 也提供了手动下载的方式.</p><p>因此当我们的环境根本无法连接外部网络的时候, 我们只能通过其他机器下载实际目标环境的事件映射表下载到另一个系统上, 有点交叉编译的意思.</p><p>首先获取目标机器的 CPU 型号<br>printf “GenuineIntel-6-%X\n” $(awk ‘&#x2F;model\s+:&#x2F; { print $3 ; exit } ‘ &#x2F;proc&#x2F;cpuinfo )<br>cpu的型号信息是由 vendor_id&#x2F;cpu_family&#x2F;model&#x2F;stepping 等几个标记的.</p><p>他其实标记了当前 CPU 是哪个系列那一代的产品, 对应的就是其微架构以及版本信息.</p><p>注意我们使用了 %X 按照 16 进制来打印</p><p>注意上面的命令显示制定了 vendor_id 等信息, 因为当前服务器端的 CPU 前面基本默认是 GenuineIntel-6 等.</p><p>不过如果我们是其他机器, 最好查看下 cpufino 信息确认.</p><p>比如我这边机器的 CPU 型号为 :</p><p>processor       : 7<br>vendor_id       : GenuineIntel&#96;<br>cpu family      : 6<br>model           : 85<br>model name      : Intel(R) Xeon(R) Gold 6161 CPU @ 2.20GHz<br>stepping        : 4<br>microcode       : 0x1<br>对应的结果就是 GenuineIntel-6-55-4.</p><p>我们也可以直接用 -v 打出来 CPU 信息.</p><p>$ python .&#x2F;event_download.py  -v</p><p>My CPU GenuineIntel-6-55-4<br>TMAM(Top-down Microarchitecture Analysis Method)<br>在最近的英特尔微体系结构上，流水线的 Front-end 每个 CPU 周期（cycle）可以分配4个 uOps ，而 Back-end 可以在每个周期中退役4个 uOps。 流水线槽（pipeline slot）代表处理一个 uOp 所需的硬件资源。 TMAM 假定对于每个 CPU 核心，在每个 CPU 周期内，有4个 pipeline slot 可用，然后使用专门设计的 PMU 事件来测量这些 pipeline slot 的使用情况。在每个 CPU 周期中，pipeline slot 可以是空的或者被 uOp 填充。 如果在一个 CPU 周期内某个 pipeline slot 是空的，称之为一次停顿（stall）。如果 CPU 经常停顿，系统性能肯定是受到影响的。TMAM 的目标就是确定系统性能问题的主要瓶颈。</p><p>下图展示并总结了乱序执行微体系架构中自顶向下确定性能瓶颈的分类方法。这种自顶向下的分析框架的优点是一种结构化的方法，有选择地探索可能的性能瓶颈区域。 带有权重的层次化节点，使得我们能够将分析的重点放在确实重要的问题上，同时无视那些不重要的问题。</p><p>例如，如果应用程序性能受到指令提取问题的严重影响， TMAM 将它分类为 Front-end Bound 这个大类。 用户或者工具可以向下探索并仅聚焦在 Front-end Bound 这个分类上，直到找到导致应用程序性能瓶颈的直接原因或一类原因。</p><p>toplev实例<br>配置对应cpu型号的事件</p><p>export EVENTMAP&#x3D;&#x2F;root&#x2F;.cache&#x2F;pmu-events&#x2F;GenuineIntel-6-55-7-core.json 这样就可以了,上述资料中的两个export是可选的</p><h1 id="python-toplev-py-–core-C0-–no-desc-l1-taskset-c-0-bash-c-‘echo-“7-199999”-bc-gt-x2F-dev-x2F-null’"><a href="#python-toplev-py-–core-C0-–no-desc-l1-taskset-c-0-bash-c-‘echo-“7-199999”-bc-gt-x2F-dev-x2F-null’" class="headerlink" title="python toplev.py –core C0 –no-desc -l1 taskset -c 0  bash -c ‘echo “7^199999” | bc &gt; &#x2F;dev&#x2F;null’"></a>python toplev.py –core C0 –no-desc -l1 taskset -c 0  bash -c ‘echo “7^199999” | bc &gt; &#x2F;dev&#x2F;null’</h1><p>Will measure complete system.<br>Using level 1.</p><h1 id="4-2-full-perf-on-Intel-R-Xeon-R-Platinum-8269CY-CPU-2-50GHz-clx-x2F-skylake"><a href="#4-2-full-perf-on-Intel-R-Xeon-R-Platinum-8269CY-CPU-2-50GHz-clx-x2F-skylake" class="headerlink" title="4.2-full-perf on Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz [clx&#x2F;skylake]"></a>4.2-full-perf on Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz [clx&#x2F;skylake]</h1><p>S0-C0    BAD            Bad_Speculation  % Slots                   36.9  &lt;&#x3D;&#x3D;<br>S1-C0    BE             Backend_Bound    % Slots                   56.2  &lt;&#x3D;&#x3D;<br>Run toplev –describe Bad_Speculation^ Backend_Bound^ to get more information on bottlenecks<br>Add –nodes ‘!+Bad_Speculation*&#x2F;2,+Backend_Bound*&#x2F;2,+MUX’ for breakdown.<br>Linux 调度策略<br>Linux kernel支持两种实时(real-time)调度策略(scheduling policy)：SCHED_FIFO和SCHED_RR</p><p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;sched_rt_period_us</p><p>缺省值是1,000,000 μs (1秒)，表示实时进程的运行粒度为1秒。（注：修改这个参数请谨慎，太大或太小都可能带来问题）。</p><p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;sched_rt_runtime_us</p><p>缺省值是 950,000 μs (0.95秒)，表示在1秒的运行周期里所有的实时进程一起最多可以占用0.95秒的CPU时间。</p><p>如果sched_rt_runtime_us&#x3D;-1，表示取消限制，意味着实时进程可以占用100%的CPU时间（慎用，有可能使系统失去控制）。</p><p>所以，Linux kernel默认情况下保证了普通进程无论如何都可以得到5%的CPU时间，尽管系统可能会慢如蜗牛，但管理员仍然可以利用这5%的时间设法恢复系统，比如停掉失控的实时进程，或者给自己的shell进程赋予更高的实时优先级以便执行管理任务，等等。</p><p>进程自愿切换(Voluntary)和强制切换(Involuntary)的次数被统计在 &#x2F;proc&#x2F;&#x2F;status 中，其中voluntary_ctxt_switches表示自愿切换的次数，nonvoluntary_ctxt_switches表示强制切换的次数，两者都是自进程启动以来的累计值。 或pidstat -w 1 来统计 <a href="http://linuxperf.com/?cat=10">http://linuxperf.com/?cat=10</a></p><p>自愿切换发生的时候，进程不再处于运行状态，比如由于等待IO而阻塞(TASK_UNINTERRUPTIBLE)，或者因等待资源和特定事件而休眠(TASK_INTERRUPTIBLE)，又或者被debug&#x2F;trace设置为TASK_STOPPED&#x2F;TASK_TRACED状态；</p><p>强制切换发生的时候，进程仍然处于运行状态(TASK_RUNNING)，通常是由于被优先级更高的进程抢占(preempt)，或者进程的时间片用完了</p><p>如果一个进程的自愿切换占多数，意味着它对CPU资源的需求不高。如果一个进程的强制切换占多数，意味着对它来说CPU资源可能是个瓶颈，这里需要排除进程频繁调用sched_yield()导致强制切换的情况</p><p>spinlock(自旋锁)是内核中最常见的锁，它的特点是：等待锁的过程中不休眠，而是占着CPU空转，优点是避免了上下文切换的开销，缺点是该CPU空转属于浪费, 同时还有可能导致cache ping-pong，spinlock适合用来保护快进快出的临界区。持有spinlock的CPU不能被抢占，持有spinlock的代码不能休眠 <a href="http://linuxperf.com/?p=138">http://linuxperf.com/?p=138</a></p><p>从操作系统的角度讲，os会维护一个ready queue（就绪的线程队列）。并且在某一时刻cpu只为ready queue中位于队列头部的线程服务。</p><p>sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p><p>NMI(non-maskable interrupt)，就是不可屏蔽的中断. NMI通常用于通知操作系统发生了无法恢复的硬件错误，也可以用于系统调试与采样，大多数服务器还提供了人工触发NMI的接口，比如NMI按钮或者iLO命令等。</p><p><a href="http://cenalulu.github.io/linux/numa/">http://cenalulu.github.io/linux/numa/</a> numa原理和优缺点案例讲解</p><p>正在运行中的用户程序被中断之后，必须等到中断处理例程完成之后才能恢复运行，在此期间即使其它CPU是空闲的也不能换个CPU继续运行，就像被中断牢牢钉在了当前的CPU上，动弹不得，中断处理需要多长时间，用户进程就被冻结多长时间。</p><p>Linux kernel把中断分为两部分：hard IRQ和soft IRQ，hard IRQ只处理中断最基本的部分，保证迅速响应，尽量在最短的时间里完成，把相对耗时的工作量留给soft IRQ；soft IRQ可以被hard IRQ中断，如果soft IRQ运行时间过长，也可能会被交给内核线程ksoftirqd去继续完成。<br><a href="https://mp.weixin.qq.com/s/AzcB1DwqRCoiofOOI88T9Q">https://mp.weixin.qq.com/s/AzcB1DwqRCoiofOOI88T9Q</a> softirq导致一路CPU使用过高，其它CPU还是闲置，整个系统比较慢</p><p>Linux的进程调度有一个不太为人熟知的特性，叫做wakeup affinity，它的初衷是这样的：如果两个进程频繁互动，那么它们很有可能共享同样的数据，把它们放到亲缘性更近的scheduling domain有助于提高缓存和内存的访问性能，所以当一个进程唤醒另一个的时候，被唤醒的进程可能会被放到相同的CPU core或者相同的NUMA节点上。这个特性缺省是打开的，它有时候很有用，但有时候却对性能有伤害作用。设想这样一个应用场景：一个主进程给成百上千个辅进程派发任务，这成百上千个辅进程被唤醒后被安排到与主进程相同的CPU core或者NUMA节点上，就会导致负载严重失衡，CPU忙的忙死、闲的闲死，造成性能下降。<a href="https://mp.weixin.qq.com/s/DG1v8cUjcXpa0x2uvrRytA">https://mp.weixin.qq.com/s/DG1v8cUjcXpa0x2uvrRytA</a></p><p><a href="http://linuxperf.com/?p=197">http://linuxperf.com/?p=197</a></p><p>参考资料<br>perf详解</p><p>CPU体系结构</p><p>震惊，用了这么多年的 CPU 利用率，其实是错的cpu占用不代表在做事情，可能是stalled，也就是流水线卡顿，但是cpu占用了，实际没事情做。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjE3MTcwMg==&amp;mid=2247483755&amp;idx=1&amp;sn=5324f7e46c91739b566dfc1d0847fc4a&amp;chksm=f9aa33b2ceddbaa478729383cac89967cc515bafa472001adc4ad42fb37e3ce473eddc3b591a&amp;mpshare=1&amp;scene=1&amp;srcid=0127mp3WJ6Kd1UOQISFg3SIC#rd">https://mp.weixin.qq.com/s?__biz=MzUxNjE3MTcwMg==&amp;mid=2247483755&amp;idx=1&amp;sn=5324f7e46c91739b566dfc1d0847fc4a&amp;chksm=f9aa33b2ceddbaa478729383cac89967cc515bafa472001adc4ad42fb37e3ce473eddc3b591a&amp;mpshare=1&amp;scene=1&amp;srcid=0127mp3WJ6Kd1UOQISFg3SIC#rd</a></p><p><a href="https://kernel.taobao.org/2019/03/Top-down-Microarchitecture-Analysis-Method/">https://kernel.taobao.org/2019/03/Top-down-Microarchitecture-Analysis-Method/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器BMC与IPMI基础知识</title>
      <link href="/2022/10/13/01%20OS/%E6%9C%8D%E5%8A%A1%E5%99%A8BMC%E4%B8%8EIPMI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/10/13/01%20OS/%E6%9C%8D%E5%8A%A1%E5%99%A8BMC%E4%B8%8EIPMI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器BMC与IPMI基础知识"><a href="#服务器BMC与IPMI基础知识" class="headerlink" title="服务器BMC与IPMI基础知识"></a>服务器BMC与IPMI基础知识</h1><p>初识BMC与IPMI</p><h1 id="什么是BMC？"><a href="#什么是BMC？" class="headerlink" title="什么是BMC？"></a>什么是BMC？</h1><p>BMC全名Baseboard management controller, 是一种<a href="https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F&spm=1001.2101.3001.7020">嵌入式</a>管理微控制器。</p><p>BMC全称为基板管理控制器（Baseboard Manager Controller，简称<strong>BMC</strong>），它通过监控系统的电源、温度等来保证系统处于正常运行的状态。</p><p>其实BMC就是一个管家的角色。能对整个系统的电源、温度等性能进行管理，在系统死机时还能充当看门狗的角色对CPU进行重启操作。</p><p>一般的电脑系统，比如我们自己用的PC，并不会带BMC，因为没必要，CPU能把BMC要干的活都干了。但复杂的服务器，就非常有必要引入BMC了。这就好比一般的家庭不会有管家，但大户人家，家大业大，所以管家是能分担家务活的。</p><p>BMC系统一般依赖于BMC芯片，目前常用的是ASPEED公司生产的AST2500。</p><blockquote><p>AST2500是ASPEED公司生产的BMC芯片，用于服务器的远程管理，一般还兼用作服务器的显示芯片，输出VGA信号，显示功能很基础，但对于服务器而言足够了。</p><p>目前所知晓的绝大部分厂商（DELL、HP、联想、浪潮、曙光等）所使用的BMC芯片都是该公司所生产的，型号包括但不限于AST2050&#x2F;2300&#x2F;2400&#x2F;2520，华为以前也使用该公司的BMC，为了保证信息安全，现在已逐步切换为自研BMC芯片。</p></blockquote><p>BMC是实现IPMI通用接口规范的核心控制器。<br>在支持IPMI v1.5典型接口时，配置上需要有32K的RAM<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>和128K的flash memory。当然，配置越高它的性能越强大。<br>那么BMC在系统中是怎么起到其作用的呢？下面是2001年Intel发布的IPMI v1.5的<a href="https://so.csdn.net/so/search?q=%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">架构</a>图：<br><img src="./20190907000328488.png"><br>从图中我们可以看到BMC对外通过System Interface连接系统总线，对内通过IPMB：Intelligent platform management Bus连接其他的component。<br>特别地说，BMC连接了两个网卡，一条本地连接，一条可提供远程连接网口。<br>这也就提供了远程使用ipmitool工具管理的可能。<br>除此之外，这些传感器的具体配置信息，如告警门限、事件触发是否允许等配置都保存在一组名为SDR（Sensor Data Record）的数据里面。而传感器产生的告警事件则保存在一组叫做SEL（Sensor Event Log）的数据里面。</p><h2 id="什么是IPMI？"><a href="#什么是IPMI？" class="headerlink" title="什么是IPMI？"></a>什么是IPMI？</h2><p>IPMI全称是Intelligent platform management interface。 由它的英文我们可以看出，它是一种接口，一种协议。<br>也就是说，它这个IPMI定义了什么接口可以让使用对应工具管理者看到。也就是说，我通过BMC来控制这些sensor,Fan,voltage,etc…并计算出结果告诉user一个这些参数的序列。<br>这些参数都可以通过BMC的功能来查询。<br>上面还提到BMC还可以通过内存和外存存储系统的数据以及事件日志，这些功能的实现有点类似于在微型计算机系统课上实现存储功能。当然其实现是需要汇编语言的。<br>IPMI的系统组件主要包括如下：</p><ul><li>BMC:baseboard management controller;</li><li>IPMB:Intelligent Platform Management Bus;</li><li>ICMB:Intelligent Chassis management Bus;</li><li>SDR:Sensor Data Record;</li><li>SEL:System Event Log;</li><li>FRU:Field Replacement Unit</li></ul><p>User可以通过三种方式使用IPMI查询：</p><ul><li>Linux操作系统下通过命令行的方式查询；例如CPU温度等</li><li>管理软件；</li><li>浏览器，带Java虚拟机</li></ul><h1 id="什么是BMC"><a href="#什么是BMC" class="headerlink" title="什么是BMC"></a>什么是BMC</h1><p>在介绍BMC之前需要了解一个概念，即平台管理（platform management）。</p><p>平台管理表示的是一系列的监视和控制功能，操作的对象是系统硬件。比如通过监视系统的温度，电压，风扇、电源等等，并做相应的调节工作，以保证系统处于健康的状态。</p><p>当然如果系统真的不正常了，也可以通过复位的方式来重新启动系统。</p><p>同时平台管理还负责记录各种硬件的信息和日志记录，用于提示用户和后续问题的定位。</p><p>下图是平台管理涉及到的功能概述：<br><img src="./20200510114843136.png"></p><p>以上的这些功能可以集成到一个控制器上来实现，这个控制器被称为基板管理控制器（Baseboard Manager Controller，简称<strong>BMC</strong>）。</p><p>需要说明的是，BMC是一个独立的系统，它不依赖与系统上的其它硬件（比如CPU、内存等），也不依赖与BIOS、OS等（但是BMC可以与BIOS和OS交互，这样可以起到更好的平台管理作用，OS下有系统管理软件可以与BMC协同工作以达到更好的管理效果）。</p><p>一般我们的电脑不会带BMC，因为用处不大，一些温度、电源等的管理，CPU（或者EC，这就是另外一个话题了）来控制就够了。</p><p>但是对于系统要求高的设备，比如服务器，就会用到BMC。</p><p>当然因为BMC是一个独立的系统，对于某些嵌入式设备，可能不需要其它处理器，光一个BMC就能完成工作。</p><p>说到底BMC本身也是一个带外处理器（一般都是ARM处理器）的小系统，单独用来处理某些工作也完全是可以的。</p><p>不过这里既然叫做BMC，那么总的来说重点还是在平台管理，所以本文主要说的是服务器中的BMC。</p><p>BMC在系统中的位置大致如下图所示：<br><img src="./20170729231045492"></p><p>BMC通过不同的接口与系统中的其它组件连接。</p><p>LPC、I2C、SMBUS，Serial等，这些都是比较基本的接口，而IPMI，它是与BMC匹配的接口，所有的BMC都需要实现这种接口，这里需要特别的介绍。</p><p> IPMI</p><p>IPMI的全称是Intelligent Platform Management Interface，智能平台管理接口。</p><p>看了名字也不需要特别介绍它用来干什么的了，关于它的详细介绍可以参看<a href="https://www.intel.com/content/www/us/en/servers/ipmi/ipmi-home.html%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AA%E5%81%9A%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%B4%E6%98%8E%E3%80%82">https://www.intel.com/content/www/us/en/servers/ipmi/ipmi-home.html，这里只做简单的说明。</a></p><p>IPMI就是对“平台管理”这个概念的具体的规范定义，该规范定义了“平台管理”的软硬件架构，交互指令，事件格式，数据记录，能力集等。而BMC是IPMI中的一个核心部分，属于IPMI硬件架构。下图灰色部分就是IPMI涉及的范围：<br><img src="./20200510131422340.png"></p><p>可以看到BMC在硬件的最底层，而上层白色部分是系统中的管理软件。</p><p>由于本文是介绍BMC的，所以这里只介绍BMC相关的IPMI硬件模块。</p><h2 id="IPMI硬件模块"><a href="#IPMI硬件模块" class="headerlink" title="IPMI硬件模块"></a>IPMI硬件模块</h2><p>IPMI规定了很多的东西，BMC是其中最重要的一个部分，此外还有一些”卫星“控制器通过IPMB与BMC相连，这些”卫星“控制器一般控制特定的设备。</p><p>IPMB全称Intelligent Platform Management Bus，是一种基于I2C的串行总线，它用于BMC与”卫星“控制器的通信，其上传递的是IPMI命令。</p><p>对于相对简单的系统来说，BMC已经能够满足要求，但是当系统比较复杂，由多个子系统构成时，那么通过IPMB和“卫星”控制器，就能够更好地管理复杂系统。</p><p>下面的图描述了与IPMI有关的各个硬件模块：<br><img src="./20170729231924660"></p><p>下面简单的介绍各个部分。</p><h3 id="MOTHERBOARD"><a href="#MOTHERBOARD" class="headerlink" title="MOTHERBOARD"></a>MOTHERBOARD</h3><p>首先是图中的左下角部分，名称写着Mother Board。<br><img src="./20190713202735974.png"></p><p>通常，在服务器中，这一部分是主角，它包含了CPU，PCH等主要的部件。</p><p>这里我们可以看到它连接除了数个组件：网卡，串口和IPMI总线，其实还有一个部分在图中最上面中间的PCI总线。</p><p>网卡：服务器需要用到网卡，这个本身没有什么好介绍的，重点其实在于BMC到网卡的连接，后续会介绍。</p><p>串口：串口用于输出服务器的调试信息，但是这里值得注意的是其中的Serial Port Sharing，它使得服务器的串口输出可以直接输出，也可以输出到BMC。至于为什么要输出到BMC，这里其实需要注意的是一种常用的场景。服务器位于机房，而工作人员通常不会直接在机房操作，而是通过网络（这也是为什么BMC会连接网卡的原因）进行操作，这个时候过需要获取服务器的串口信息，就不方便直接去机房，这个时候通过BMC来获取服务器串口信息就是一个好主意。</p><p>IPMI总线：这是BMC与服务器通信并进行控制的主体，当然少不了。</p><p>PCI总线：这个部分的作用跟串口很像。服务器除了输出串口信息，当然还需要输出图形界面之类的东西。从服务器端来看，它通过PCI连接的就是一个显卡，通过它来输出显示。</p><h3 id="IPMB"><a href="#IPMB" class="headerlink" title="IPMB"></a>IPMB</h3><p>再来到图中的右上角，其中描述的是通过IPMB连接的设备。<br><img src="./2019071320275388.png"></p><p>这些设备跟BMC类似，也是用来进行管理芯片。</p><p>它们是对BMC的补充，从而扩展BMC的功能。</p><h3 id="Non-volatile-Storage"><a href="#Non-volatile-Storage" class="headerlink" title="Non-volatile Storage"></a>Non-volatile Storage</h3><p>我们知道BMC其实是一个独立的芯片，那么它肯定也需要运行系统。</p><p>通过BMC里面运行的是一个类Unix系统，而该系统就存放再Non-volatile Storage中，通常就是SPI Flash里面。<br><img src="./20190713202929368.png"></p><p>跟一般的存储介质没有本质的区别。</p><p>除了系统本身之后，还包含一系列BMC会存放的信息。</p><p>比如从服务器上面获取到的串口信息；系统本身的报警信息；FRU信息等。</p><h3 id="Sensors-amp-Control-Circuitry"><a href="#Sensors-amp-Control-Circuitry" class="headerlink" title="Sensors &amp; Control Circuitry"></a>Sensors &amp; Control Circuitry</h3><p>这一部分虽然图中只占很小的一部分，但却是BMC最基本的功能：获取信息和控制环境。</p><img src="./20190713203216400.png"><p>BMC会通过I2C&#x2F;PECI等总线去获取设备的温度，然后根据预先设定的策略去调整温度。</p><p>调整的方式两种，一种就是调整风扇，属于主动降温；另一种是调整供电，比如CPU的P状态，或者关闭多余的硬盘等，属于被动降温。</p><h3 id="FRU"><a href="#FRU" class="headerlink" title="FRU"></a>FRU</h3><p>FRU的全称是Field Replaceable Unit。</p><img src="./20190713203652204.png"><p>从图中也可以看出，类似内存条，CPU等就属于FRU，它们在服务器中通常是可以更换的。</p><p>BMC会检测这些设备并保存相关的信息。</p><p>当这些设备的在位情况发生变化时，BMC会发生相关的告警</p><p>来源：<a href="https://blog.csdn.net/star871016/article/details/112257689">https://blog.csdn.net/star871016/article/details/112257689</a></p><p>协议标准：<a href="https://www.intel.com/content/www/us/en/products/docs/servers/ipmi/ipmi-second-gen-interface-spec-v2-rev1-1.html">https://www.intel.com/content/www/us/en/products/docs/servers/ipmi/ipmi-second-gen-interface-spec-v2-rev1-1.html</a></p><h1 id="ipmitool源码解析（一）——一次带内ipmitool-raw-data发送过程"><a href="#ipmitool源码解析（一）——一次带内ipmitool-raw-data发送过程" class="headerlink" title="ipmitool源码解析（一）——一次带内ipmitool raw data发送过程"></a>ipmitool源码解析（一）——一次带内ipmitool raw data发送过程</h1><p>来源：<a href="https://blog.csdn.net/qq_40144132/article/details/114836282">https://blog.csdn.net/qq_40144132/article/details/114836282</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Perf-Report(1) — Linux Manual Page</title>
      <link href="/2022/10/13/01%20OS/Linux/Perf/perf-report/"/>
      <url>/2022/10/13/01%20OS/Linux/Perf/perf-report/</url>
      
        <content type="html"><![CDATA[<h1 id="perf-report-1-—-Linux-manual-page"><a href="#perf-report-1-—-Linux-manual-page" class="headerlink" title="perf-report(1) — Linux manual page"></a>perf-report(1) — Linux manual page</h1><table><thead><tr><th><a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#NAME">NAME</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#SYNOPSIS">SYNOPSIS</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#DESCRIPTION">DESCRIPTION</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#OPTIONS">OPTIONS</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#OVERHEAD_CALCULATION">OVERHEAD CALCULATION</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#SEE_ALSO">SEE ALSO</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#COLOPHON">COLOPHON</a></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PERF-REPORT(1)                 perf Manual                PERF-REPORT(1)</span><br></pre></td></tr></table></figure><h2 id="NAME-top"><a href="#NAME-top" class="headerlink" title="NAME     top"></a>NAME     <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perf-report - Read perf.data (created by perf record) and display</span><br><span class="line">the profile</span><br></pre></td></tr></table></figure><h2 id="SYNOPSIS-top"><a href="#SYNOPSIS-top" class="headerlink" title="SYNOPSIS     top"></a>SYNOPSIS     <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf report [-i &lt;file&gt; | --input=file]</span><br></pre></td></tr></table></figure><h2 id="DESCRIPTION-top"><a href="#DESCRIPTION-top" class="headerlink" title="DESCRIPTION     top"></a>DESCRIPTION     <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This command displays the performance counter profile information</span><br><span class="line">recorded via perf record.</span><br></pre></td></tr></table></figure><h2 id="OPTIONS-top"><a href="#OPTIONS-top" class="headerlink" title="OPTIONS     top"></a>OPTIONS     <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br></pre></td><td class="code"><pre><span class="line">-i, --input=</span><br><span class="line">    Input file name. (default: perf.data unless stdin is a fifo)</span><br><span class="line"></span><br><span class="line">-v, --verbose</span><br><span class="line">    Be more verbose. (show symbol address, etc)</span><br><span class="line"></span><br><span class="line">-q, --quiet</span><br><span class="line">    Do not show any message. (Suppress -v)</span><br><span class="line"></span><br><span class="line">-n, --show-nr-samples</span><br><span class="line">    Show the number of samples for each symbol</span><br><span class="line"></span><br><span class="line">--show-cpu-utilization</span><br><span class="line">    Show sample percentage for different cpu modes.</span><br><span class="line"></span><br><span class="line">-T, --threads</span><br><span class="line">    Show per-thread event counters. The input data file should be</span><br><span class="line">    recorded with -s option.</span><br><span class="line"></span><br><span class="line">-c, --comms=</span><br><span class="line">    Only consider symbols in these comms. CSV that understands</span><br><span class="line">    file://filename entries. This option will affect the</span><br><span class="line">    percentage of the overhead column. See --percentage for more</span><br><span class="line">    info.</span><br><span class="line"></span><br><span class="line">--pid=</span><br><span class="line">    Only show events for given process ID (comma separated list).</span><br><span class="line"></span><br><span class="line">--tid=</span><br><span class="line">    Only show events for given thread ID (comma separated list).</span><br><span class="line"></span><br><span class="line">-d, --dsos=</span><br><span class="line">    Only consider symbols in these dsos. CSV that understands</span><br><span class="line">    file://filename entries. This option will affect the</span><br><span class="line">    percentage of the overhead column. See --percentage for more</span><br><span class="line">    info.</span><br><span class="line"></span><br><span class="line">-S, --symbols=</span><br><span class="line">    Only consider these symbols. CSV that understands</span><br><span class="line">    file://filename entries. This option will affect the</span><br><span class="line">    percentage of the overhead column. See --percentage for more</span><br><span class="line">    info.</span><br><span class="line"></span><br><span class="line">--symbol-filter=</span><br><span class="line">    Only show symbols that match (partially) with this filter.</span><br><span class="line"></span><br><span class="line">-U, --hide-unresolved</span><br><span class="line">    Only display entries resolved to a symbol.</span><br><span class="line"></span><br><span class="line">-s, --sort=</span><br><span class="line">    Sort histogram entries by given key(s) - multiple keys can be</span><br><span class="line">    specified in CSV format. Following sort keys are available:</span><br><span class="line">    pid, comm, dso, symbol, parent, cpu, socket, srcline, weight,</span><br><span class="line">    local_weight, cgroup_id.</span><br><span class="line"></span><br><span class="line">        Each key has following meaning:</span><br><span class="line"></span><br><span class="line">    •   comm: command (name) of the task which can be read via</span><br><span class="line">        /proc/&lt;pid&gt;/comm</span><br><span class="line"></span><br><span class="line">    •   pid: command and tid of the task</span><br><span class="line"></span><br><span class="line">    •   dso: name of library or module executed at the time of</span><br><span class="line">        sample</span><br><span class="line"></span><br><span class="line">    •   dso_size: size of library or module executed at the time</span><br><span class="line">        of sample</span><br><span class="line"></span><br><span class="line">    •   symbol: name of function executed at the time of sample</span><br><span class="line"></span><br><span class="line">    •   symbol_size: size of function executed at the time of</span><br><span class="line">        sample</span><br><span class="line"></span><br><span class="line">    •   parent: name of function matched to the parent regex</span><br><span class="line">        filter. Unmatched entries are displayed as &quot;[other]&quot;.</span><br><span class="line"></span><br><span class="line">    •   cpu: cpu number the task ran at the time of sample</span><br><span class="line"></span><br><span class="line">    •   socket: processor socket number the task ran at the time</span><br><span class="line">        of sample</span><br><span class="line"></span><br><span class="line">    •   srcline: filename and line number executed at the time of</span><br><span class="line">        sample. The DWARF debugging info must be provided.</span><br><span class="line"></span><br><span class="line">    •   srcfile: file name of the source file of the samples.</span><br><span class="line">        Requires dwarf information.</span><br><span class="line"></span><br><span class="line">    •   weight: Event specific weight, e.g. memory latency or</span><br><span class="line">        transaction abort cost. This is the global weight.</span><br><span class="line"></span><br><span class="line">    •   local_weight: Local weight version of the weight above.</span><br><span class="line"></span><br><span class="line">    •   cgroup_id: ID derived from cgroup namespace device and</span><br><span class="line">        inode numbers.</span><br><span class="line"></span><br><span class="line">    •   cgroup: cgroup pathname in the cgroupfs.</span><br><span class="line"></span><br><span class="line">    •   transaction: Transaction abort flags.</span><br><span class="line"></span><br><span class="line">    •   overhead: Overhead percentage of sample</span><br><span class="line"></span><br><span class="line">    •   overhead_sys: Overhead percentage of sample running in</span><br><span class="line">        system mode</span><br><span class="line"></span><br><span class="line">    •   overhead_us: Overhead percentage of sample running in</span><br><span class="line">        user mode</span><br><span class="line"></span><br><span class="line">    •   overhead_guest_sys: Overhead percentage of sample running</span><br><span class="line">        in system mode on guest machine</span><br><span class="line"></span><br><span class="line">    •   overhead_guest_us: Overhead percentage of sample running</span><br><span class="line">        in user mode on guest machine</span><br><span class="line"></span><br><span class="line">    •   sample: Number of sample</span><br><span class="line"></span><br><span class="line">    •   period: Raw number of event count of sample</span><br><span class="line"></span><br><span class="line">    •   time: Separate the samples by time stamp with the</span><br><span class="line">        resolution specified by --time-quantum (default 100ms).</span><br><span class="line">        Specify with overhead and before it.</span><br><span class="line"></span><br><span class="line">    •   code_page_size: the code page size of sampled code</span><br><span class="line">        address (ip)</span><br><span class="line"></span><br><span class="line">    •   ins_lat: Instruction latency in core cycles. This is the</span><br><span class="line">        global instruction latency</span><br><span class="line"></span><br><span class="line">    •   local_ins_lat: Local instruction latency version</span><br><span class="line"></span><br><span class="line">    •   p_stage_cyc: On powerpc, this presents the number of</span><br><span class="line">        cycles spent in a pipeline stage. And currently supported</span><br><span class="line">        only on powerpc.</span><br><span class="line"></span><br><span class="line">            By default, comm, dso and symbol keys are used.</span><br><span class="line">            (i.e. --sort comm,dso,symbol)</span><br><span class="line"></span><br><span class="line">            If --branch-stack option is used, following sort keys are also</span><br><span class="line">            available:</span><br><span class="line"></span><br><span class="line">    •   dso_from: name of library or module branched from</span><br><span class="line"></span><br><span class="line">    •   dso_to: name of library or module branched to</span><br><span class="line"></span><br><span class="line">    •   symbol_from: name of function branched from</span><br><span class="line"></span><br><span class="line">    •   symbol_to: name of function branched to</span><br><span class="line"></span><br><span class="line">    •   srcline_from: source file and line branched from</span><br><span class="line"></span><br><span class="line">    •   srcline_to: source file and line branched to</span><br><span class="line"></span><br><span class="line">    •   mispredict: &quot;N&quot; for predicted branch, &quot;Y&quot; for</span><br><span class="line">        mispredicted branch</span><br><span class="line"></span><br><span class="line">    •   in_tx: branch in TSX transaction</span><br><span class="line"></span><br><span class="line">    •   abort: TSX transaction abort.</span><br><span class="line"></span><br><span class="line">    •   cycles: Cycles in basic block</span><br><span class="line"></span><br><span class="line">            And default sort keys are changed to comm, dso_from, symbol_from, dso_to</span><br><span class="line">            and symbol_to, see &#x27;--branch-stack&#x27;.</span><br><span class="line"></span><br><span class="line">            When the sort key symbol is specified, columns &quot;IPC&quot; and &quot;IPC Coverage&quot;</span><br><span class="line">            are enabled automatically. Column &quot;IPC&quot; reports the average IPC per function</span><br><span class="line">            and column &quot;IPC coverage&quot; reports the percentage of instructions with</span><br><span class="line">            sampled IPC in this function. IPC means Instruction Per Cycle. If it&#x27;s low,</span><br><span class="line">            it indicates there may be a performance bottleneck when the function is</span><br><span class="line">            executed, such as a memory access bottleneck. If a function has high overhead</span><br><span class="line">            and low IPC, it&#x27;s worth further analyzing it to optimize its performance.</span><br><span class="line"></span><br><span class="line">            If the --mem-mode option is used, the following sort keys are also available</span><br><span class="line">            (incompatible with --branch-stack):</span><br><span class="line">            symbol_daddr, dso_daddr, locked, tlb, mem, snoop, dcacheline, blocked.</span><br><span class="line"></span><br><span class="line">    •   symbol_daddr: name of data symbol being executed on at</span><br><span class="line">        the time of sample</span><br><span class="line"></span><br><span class="line">    •   dso_daddr: name of library or module containing the data</span><br><span class="line">        being executed on at the time of the sample</span><br><span class="line"></span><br><span class="line">    •   locked: whether the bus was locked at the time of the</span><br><span class="line">        sample</span><br><span class="line"></span><br><span class="line">    •   tlb: type of tlb access for the data at the time of the</span><br><span class="line">        sample</span><br><span class="line"></span><br><span class="line">    •   mem: type of memory access for the data at the time of</span><br><span class="line">        the sample</span><br><span class="line"></span><br><span class="line">    •   snoop: type of snoop (if any) for the data at the time of</span><br><span class="line">        the sample</span><br><span class="line"></span><br><span class="line">    •   dcacheline: the cacheline the data address is on at the</span><br><span class="line">        time of the sample</span><br><span class="line"></span><br><span class="line">    •   phys_daddr: physical address of data being executed on at</span><br><span class="line">        the time of sample</span><br><span class="line"></span><br><span class="line">    •   data_page_size: the data page size of data being executed</span><br><span class="line">        on at the time of sample</span><br><span class="line"></span><br><span class="line">    •   blocked: reason of blocked load access for the data at</span><br><span class="line">        the time of the sample</span><br><span class="line"></span><br><span class="line">            And the default sort keys are changed to local_weight, mem, sym, dso,</span><br><span class="line">            symbol_daddr, dso_daddr, snoop, tlb, locked, blocked, local_ins_lat,</span><br><span class="line">            see &#x27;--mem-mode&#x27;.</span><br><span class="line"></span><br><span class="line">            If the data file has tracepoint event(s), following (dynamic) sort keys</span><br><span class="line">            are also available:</span><br><span class="line">            trace, trace_fields, [&lt;event&gt;.]&lt;field&gt;[/raw]</span><br><span class="line"></span><br><span class="line">    •   trace: pretty printed trace output in a single column</span><br><span class="line"></span><br><span class="line">    •   trace_fields: fields in tracepoints in separate columns</span><br><span class="line"></span><br><span class="line">    •   &lt;field name&gt;: optional event and field name for a</span><br><span class="line">        specific field</span><br><span class="line"></span><br><span class="line">            The last form consists of event and field names.  If event name is</span><br><span class="line">            omitted, it searches all events for matching field name.  The matched</span><br><span class="line">            field will be shown only for the event has the field.  The event name</span><br><span class="line">            supports substring match so user doesn&#x27;t need to specify full subsystem</span><br><span class="line">            and event name everytime.  For example, &#x27;sched:sched_switch&#x27; event can</span><br><span class="line">            be shortened to &#x27;switch&#x27; as long as it&#x27;s not ambiguous.  Also event can</span><br><span class="line">            be specified by its index (starting from 1) preceded by the &#x27;%&#x27;.</span><br><span class="line">            So &#x27;%1&#x27; is the first event, &#x27;%2&#x27; is the second, and so on.</span><br><span class="line"></span><br><span class="line">            The field name can have &#x27;/raw&#x27; suffix which disables pretty printing</span><br><span class="line">            and shows raw field value like hex numbers.  The --raw-trace option</span><br><span class="line">            has the same effect for all dynamic sort keys.</span><br><span class="line"></span><br><span class="line">            The default sort keys are changed to &#x27;trace&#x27; if all events in the data</span><br><span class="line">            file are tracepoint.</span><br><span class="line"></span><br><span class="line">-F, --fields=</span><br><span class="line">    Specify output field - multiple keys can be specified in CSV</span><br><span class="line">    format. Following fields are available: overhead,</span><br><span class="line">    overhead_sys, overhead_us, overhead_children, sample and</span><br><span class="line">    period. Also it can contain any sort key(s).</span><br><span class="line"></span><br><span class="line">        By default, every sort keys not specified in -F will be appended</span><br><span class="line">        automatically.</span><br><span class="line"></span><br><span class="line">        If the keys starts with a prefix &#x27;+&#x27;, then it will append the specified</span><br><span class="line">        field(s) to the default field order. For example: perf report -F +period,sample.</span><br><span class="line"></span><br><span class="line">-p, --parent=&lt;regex&gt;</span><br><span class="line">    A regex filter to identify parent. The parent is a caller of</span><br><span class="line">    this function and searched through the callchain, thus it</span><br><span class="line">    requires callchain information recorded. The pattern is in</span><br><span class="line">    the extended regex format and defaults to</span><br><span class="line">    &quot;^sys_|^do_page_fault&quot;, see --sort parent.</span><br><span class="line"></span><br><span class="line">-x, --exclude-other</span><br><span class="line">    Only display entries with parent-match.</span><br><span class="line"></span><br><span class="line">-w, --column-widths=&lt;width[,width...]&gt;</span><br><span class="line">    Force each column width to the provided list, for large</span><br><span class="line">    terminal readability. 0 means no limit (default behavior).</span><br><span class="line"></span><br><span class="line">-t, --field-separator=</span><br><span class="line">    Use a special separator character and don’t pad with spaces,</span><br><span class="line">    replacing all occurrences of this separator in symbol names</span><br><span class="line">    (and other output) with a .  character, that thus it’s the</span><br><span class="line">    only non valid separator.</span><br><span class="line"></span><br><span class="line">-D, --dump-raw-trace</span><br><span class="line">    Dump raw trace in ASCII.</span><br><span class="line"></span><br><span class="line">--disable-order</span><br><span class="line">    Disable raw trace ordering.</span><br><span class="line"></span><br><span class="line">-g,</span><br><span class="line">--call-graph=&lt;print_type,threshold[,print_limit],order,sort_key[,branch],value&gt;</span><br><span class="line">    Display call chains using type, min percent threshold, print</span><br><span class="line">    limit, call order, sort key, optional branch and value. Note</span><br><span class="line">    that ordering is not fixed so any parameter can be given in</span><br><span class="line">    an arbitrary order. One exception is the print_limit which</span><br><span class="line">    should be preceded by threshold.</span><br><span class="line"></span><br><span class="line">        print_type can be either:</span><br><span class="line">        - flat: single column, linear exposure of call chains.</span><br><span class="line">        - graph: use a graph tree, displaying absolute overhead rates. (default)</span><br><span class="line">        - fractal: like graph, but displays relative rates. Each branch of</span><br><span class="line">                 the tree is considered as a new profiled object.</span><br><span class="line">        - folded: call chains are displayed in a line, separated by semicolons</span><br><span class="line">        - none: disable call chain display.</span><br><span class="line"></span><br><span class="line">        threshold is a percentage value which specifies a minimum percent to be</span><br><span class="line">        included in the output call graph.  Default is 0.5 (%).</span><br><span class="line"></span><br><span class="line">        print_limit is only applied when stdio interface is used.  It&#x27;s to limit</span><br><span class="line">        number of call graph entries in a single hist entry.  Note that it needs</span><br><span class="line">        to be given after threshold (but not necessarily consecutive).</span><br><span class="line">        Default is 0 (unlimited).</span><br><span class="line"></span><br><span class="line">        order can be either:</span><br><span class="line">        - callee: callee based call graph.</span><br><span class="line">        - caller: inverted caller based call graph.</span><br><span class="line">        Default is &#x27;caller&#x27; when --children is used, otherwise &#x27;callee&#x27;.</span><br><span class="line"></span><br><span class="line">        sort_key can be:</span><br><span class="line">        - function: compare on functions (default)</span><br><span class="line">        - address: compare on individual code addresses</span><br><span class="line">        - srcline: compare on source filename and line number</span><br><span class="line"></span><br><span class="line">        branch can be:</span><br><span class="line">        - branch: include last branch information in callgraph when available.</span><br><span class="line">                  Usually more convenient to use --branch-history for this.</span><br><span class="line"></span><br><span class="line">        value can be:</span><br><span class="line">        - percent: display overhead percent (default)</span><br><span class="line">        - period: display event period</span><br><span class="line">        - count: display event count</span><br><span class="line"></span><br><span class="line">--children</span><br><span class="line">    Accumulate callchain of children to parent entry so that then</span><br><span class="line">    can show up in the output. The output will have a new</span><br><span class="line">    &quot;Children&quot; column and will be sorted on the data. It requires</span><br><span class="line">    callchains are recorded. See the ‘overhead calculation’</span><br><span class="line">    section for more details. Enabled by default, disable with</span><br><span class="line">    --no-children.</span><br><span class="line"></span><br><span class="line">--max-stack</span><br><span class="line">    Set the stack depth limit when parsing the callchain,</span><br><span class="line">    anything beyond the specified depth will be ignored. This is</span><br><span class="line">    a trade-off between information loss and faster processing</span><br><span class="line">    especially for workloads that can have a very long callchain</span><br><span class="line">    stack. Note that when using the --itrace option the</span><br><span class="line">    synthesized callchain size will override this value if the</span><br><span class="line">    synthesized callchain size is bigger.</span><br><span class="line"></span><br><span class="line">        Default: 127</span><br><span class="line"></span><br><span class="line">-G, --inverted</span><br><span class="line">    alias for inverted caller based call graph.</span><br><span class="line"></span><br><span class="line">--ignore-callees=&lt;regex&gt;</span><br><span class="line">    Ignore callees of the function(s) matching the given regex.</span><br><span class="line">    This has the effect of collecting the callers of each such</span><br><span class="line">    function into one place in the call-graph tree.</span><br><span class="line"></span><br><span class="line">--pretty=&lt;key&gt;</span><br><span class="line">    Pretty printing style. key: normal, raw</span><br><span class="line"></span><br><span class="line">--stdio</span><br><span class="line">    Use the stdio interface.</span><br><span class="line"></span><br><span class="line">--stdio-color</span><br><span class="line">    always, never or auto, allowing configuring color output via</span><br><span class="line">    the command line, in addition to via &quot;color.ui&quot; .perfconfig.</span><br><span class="line">    Use --stdio-color always to generate color even when</span><br><span class="line">    redirecting to a pipe or file. Using just --stdio-color is</span><br><span class="line">    equivalent to using always.</span><br><span class="line"></span><br><span class="line">--tui</span><br><span class="line">    Use the TUI interface, that is integrated with annotate and</span><br><span class="line">    allows zooming into DSOs or threads, among other features.</span><br><span class="line">    Use of --tui requires a tty, if one is not present, as when</span><br><span class="line">    piping to other commands, the stdio interface is used.</span><br><span class="line"></span><br><span class="line">--gtk</span><br><span class="line">    Use the GTK2 interface.</span><br><span class="line"></span><br><span class="line">-k, --vmlinux=&lt;file&gt;</span><br><span class="line">    vmlinux pathname</span><br><span class="line"></span><br><span class="line">--ignore-vmlinux</span><br><span class="line">    Ignore vmlinux files.</span><br><span class="line"></span><br><span class="line">--kallsyms=&lt;file&gt;</span><br><span class="line">    kallsyms pathname</span><br><span class="line"></span><br><span class="line">-m, --modules</span><br><span class="line">    Load module symbols. WARNING: This should only be used with</span><br><span class="line">    -k and a LIVE kernel.</span><br><span class="line"></span><br><span class="line">-f, --force</span><br><span class="line">    Don’t do ownership validation.</span><br><span class="line"></span><br><span class="line">--symfs=&lt;directory&gt;</span><br><span class="line">    Look for files with symbols relative to this directory.</span><br><span class="line"></span><br><span class="line">-C, --cpu</span><br><span class="line">    Only report samples for the list of CPUs provided. Multiple</span><br><span class="line">    CPUs can be provided as a comma-separated list with no space:</span><br><span class="line">    0,1. Ranges of CPUs are specified with -: 0-2. Default is to</span><br><span class="line">    report samples on all CPUs.</span><br><span class="line"></span><br><span class="line">-M, --disassembler-style=</span><br><span class="line">    Set disassembler style for objdump.</span><br><span class="line"></span><br><span class="line">--source</span><br><span class="line">    Interleave source code with assembly code. Enabled by</span><br><span class="line">    default, disable with --no-source.</span><br><span class="line"></span><br><span class="line">--asm-raw</span><br><span class="line">    Show raw instruction encoding of assembly instructions.</span><br><span class="line"></span><br><span class="line">--show-total-period</span><br><span class="line">    Show a column with the sum of periods.</span><br><span class="line"></span><br><span class="line">-I, --show-info</span><br><span class="line">    Display extended information about the perf.data file. This</span><br><span class="line">    adds information which may be very large and thus may clutter</span><br><span class="line">    the display. It currently includes: cpu and numa topology of</span><br><span class="line">    the host system.</span><br><span class="line"></span><br><span class="line">-b, --branch-stack</span><br><span class="line">    Use the addresses of sampled taken branches instead of the</span><br><span class="line">    instruction address to build the histograms. To generate</span><br><span class="line">    meaningful output, the perf.data file must have been obtained</span><br><span class="line">    using perf record -b or perf record --branch-filter xxx where</span><br><span class="line">    xxx is a branch filter option. perf report is able to</span><br><span class="line">    auto-detect whether a perf.data file contains branch stacks</span><br><span class="line">    and it will automatically switch to the branch view mode,</span><br><span class="line">    unless --no-branch-stack is used.</span><br><span class="line"></span><br><span class="line">--branch-history</span><br><span class="line">    Add the addresses of sampled taken branches to the callstack.</span><br><span class="line">    This allows to examine the path the program took to each</span><br><span class="line">    sample. The data collection must have used -b (or -j) and -g.</span><br><span class="line"></span><br><span class="line">--objdump=&lt;path&gt;</span><br><span class="line">    Path to objdump binary.</span><br><span class="line"></span><br><span class="line">--prefix=PREFIX, --prefix-strip=N</span><br><span class="line">    Remove first N entries from source file path names in</span><br><span class="line">    executables and add PREFIX. This allows to display source</span><br><span class="line">    code compiled on systems with different file system layout.</span><br><span class="line"></span><br><span class="line">--group</span><br><span class="line">    Show event group information together. It forces group output</span><br><span class="line">    also if there are no groups defined in data file.</span><br><span class="line"></span><br><span class="line">--group-sort-idx</span><br><span class="line">    Sort the output by the event at the index n in group. If n is</span><br><span class="line">    invalid, sort by the first event. It can support multiple</span><br><span class="line">    groups with different amount of events. WARNING: This should</span><br><span class="line">    be used on grouped events.</span><br><span class="line"></span><br><span class="line">--demangle</span><br><span class="line">    Demangle symbol names to human readable form. It’s enabled by</span><br><span class="line">    default, disable with --no-demangle.</span><br><span class="line"></span><br><span class="line">--demangle-kernel</span><br><span class="line">    Demangle kernel symbol names to human readable form (for C++</span><br><span class="line">    kernels).</span><br><span class="line"></span><br><span class="line">--mem-mode</span><br><span class="line">    Use the data addresses of samples in addition to instruction</span><br><span class="line">    addresses to build the histograms. To generate meaningful</span><br><span class="line">    output, the perf.data file must have been obtained using perf</span><br><span class="line">    record -d -W and using a special event -e cpu/mem-loads/p or</span><br><span class="line">    -e cpu/mem-stores/p. See perf mem for simpler access.</span><br><span class="line"></span><br><span class="line">--percent-limit</span><br><span class="line">    Do not show entries which have an overhead under that</span><br><span class="line">    percent. (Default: 0). Note that this option also sets the</span><br><span class="line">    percent limit (threshold) of callchains. However the default</span><br><span class="line">    value of callchain threshold is different than the default</span><br><span class="line">    value of hist entries. Please see the --call-graph option for</span><br><span class="line">    details.</span><br><span class="line"></span><br><span class="line">--percentage</span><br><span class="line">    Determine how to display the overhead percentage of filtered</span><br><span class="line">    entries. Filters can be applied by --comms, --dsos and/or</span><br><span class="line">    --symbols options and Zoom operations on the TUI (thread,</span><br><span class="line">    dso, etc).</span><br><span class="line"></span><br><span class="line">        &quot;relative&quot; means it&#x27;s relative to filtered entries only so that the</span><br><span class="line">        sum of shown entries will be always 100%.  &quot;absolute&quot; means it retains</span><br><span class="line">        the original value before and after the filter is applied.</span><br><span class="line"></span><br><span class="line">--header</span><br><span class="line">    Show header information in the perf.data file. This includes</span><br><span class="line">    various information like hostname, OS and perf version,</span><br><span class="line">    cpu/mem info, perf command line, event list and so on.</span><br><span class="line">    Currently only --stdio output supports this feature.</span><br><span class="line"></span><br><span class="line">--header-only</span><br><span class="line">    Show only perf.data header (forces --stdio).</span><br><span class="line"></span><br><span class="line">--time</span><br><span class="line">    Only analyze samples within given time window:</span><br><span class="line">    &lt;start&gt;,&lt;stop&gt;. Times have the format seconds.nanoseconds. If</span><br><span class="line">    start is not given (i.e. time string is ,x.y) then analysis</span><br><span class="line">    starts at the beginning of the file. If stop time is not</span><br><span class="line">    given (i.e. time string is x.y,) then analysis goes to end of</span><br><span class="line">    file. Multiple ranges can be separated by spaces, which</span><br><span class="line">    requires the argument to be quoted e.g. --time</span><br><span class="line">    &quot;1234.567,1234.789 1235,&quot;</span><br><span class="line"></span><br><span class="line">        Also support time percent with multiple time ranges. Time string is</span><br><span class="line">        &#x27;a%/n,b%/m,...&#x27; or &#x27;a%-b%,c%-%d,...&#x27;.</span><br><span class="line"></span><br><span class="line">        For example:</span><br><span class="line">        Select the second 10% time slice:</span><br><span class="line"></span><br><span class="line">        perf report --time 10%/2</span><br><span class="line"></span><br><span class="line">        Select from 0% to 10% time slice:</span><br><span class="line"></span><br><span class="line">        perf report --time 0%-10%</span><br><span class="line"></span><br><span class="line">        Select the first and second 10% time slices:</span><br><span class="line"></span><br><span class="line">        perf report --time 10%/1,10%/2</span><br><span class="line"></span><br><span class="line">        Select from 0% to 10% and 30% to 40% slices:</span><br><span class="line"></span><br><span class="line">        perf report --time 0%-10%,30%-40%</span><br><span class="line"></span><br><span class="line">--switch-on EVENT_NAME</span><br><span class="line">    Only consider events after this event is found.</span><br><span class="line"></span><br><span class="line">        This may be interesting to measure a workload only after some initialization</span><br><span class="line">        phase is over, i.e. insert a perf probe at that point and then using this</span><br><span class="line">        option with that probe.</span><br><span class="line"></span><br><span class="line">--switch-off EVENT_NAME</span><br><span class="line">    Stop considering events after this event is found.</span><br><span class="line"></span><br><span class="line">--show-on-off-events</span><br><span class="line">    Show the --switch-on/off events too. This has no effect in</span><br><span class="line">    perf report now but probably we’ll make the default not to</span><br><span class="line">    show the switch-on/off events on the --group mode and if</span><br><span class="line">    there is only one event besides the off/on ones, go straight</span><br><span class="line">    to the histogram browser, just like perf report with no</span><br><span class="line">    events explicitly specified does.</span><br><span class="line"></span><br><span class="line">--itrace</span><br><span class="line">    Options for decoding instruction tracing data. The options</span><br><span class="line">    are:</span><br><span class="line"></span><br><span class="line">        i       synthesize instructions events</span><br><span class="line">        b       synthesize branches events (branch misses for Arm SPE)</span><br><span class="line">        c       synthesize branches events (calls only)</span><br><span class="line">        r       synthesize branches events (returns only)</span><br><span class="line">        x       synthesize transactions events</span><br><span class="line">        w       synthesize ptwrite events</span><br><span class="line">        p       synthesize power events (incl. PSB events for Intel PT)</span><br><span class="line">        o       synthesize other events recorded due to the use</span><br><span class="line">                of aux-output (refer to perf record)</span><br><span class="line">        e       synthesize error events</span><br><span class="line">        d       create a debug log</span><br><span class="line">        f       synthesize first level cache events</span><br><span class="line">        m       synthesize last level cache events</span><br><span class="line">        M       synthesize memory events</span><br><span class="line">        t       synthesize TLB events</span><br><span class="line">        a       synthesize remote access events</span><br><span class="line">        g       synthesize a call chain (use with i or x)</span><br><span class="line">        G       synthesize a call chain on existing event records</span><br><span class="line">        l       synthesize last branch entries (use with i or x)</span><br><span class="line">        L       synthesize last branch entries on existing event records</span><br><span class="line">        s       skip initial number of events</span><br><span class="line">        q       quicker (less detailed) decoding</span><br><span class="line">        Z       prefer to ignore timestamps (so-called &quot;timeless&quot; decoding)</span><br><span class="line"></span><br><span class="line">        The default is all events i.e. the same as --itrace=ibxwpe,</span><br><span class="line">        except for perf script where it is --itrace=ce</span><br><span class="line"></span><br><span class="line">        In addition, the period (default 100000, except for perf script where it is 1)</span><br><span class="line">        for instructions events can be specified in units of:</span><br><span class="line"></span><br><span class="line">        i       instructions</span><br><span class="line">        t       ticks</span><br><span class="line">        ms      milliseconds</span><br><span class="line">        us      microseconds</span><br><span class="line">        ns      nanoseconds (default)</span><br><span class="line"></span><br><span class="line">        Also the call chain size (default 16, max. 1024) for instructions or</span><br><span class="line">        transactions events can be specified.</span><br><span class="line"></span><br><span class="line">        Also the number of last branch entries (default 64, max. 1024) for</span><br><span class="line">        instructions or transactions events can be specified.</span><br><span class="line"></span><br><span class="line">        Similar to options g and l, size may also be specified for options G and L.</span><br><span class="line">        On x86, note that G and L work poorly when data has been recorded with</span><br><span class="line">        large PEBS. Refer linkperf:perf-intel-pt[1] man page for details.</span><br><span class="line"></span><br><span class="line">        It is also possible to skip events generated (instructions, branches, transactions,</span><br><span class="line">        ptwrite, power) at the beginning. This is useful to ignore initialization code.</span><br><span class="line"></span><br><span class="line">        --itrace=i0nss1000000</span><br><span class="line"></span><br><span class="line">        skips the first million instructions.</span><br><span class="line"></span><br><span class="line">        The &#x27;e&#x27; option may be followed by flags which affect what errors will or</span><br><span class="line">        will not be reported. Each flag must be preceded by either &#x27;+&#x27; or &#x27;-&#x27;.</span><br><span class="line">        The flags are:</span><br><span class="line">                o       overflow</span><br><span class="line">                l       trace data lost</span><br><span class="line"></span><br><span class="line">        If supported, the &#x27;d&#x27; option may be followed by flags which affect what</span><br><span class="line">        debug messages will or will not be logged. Each flag must be preceded</span><br><span class="line">        by either &#x27;+&#x27; or &#x27;-&#x27;. The flags are:</span><br><span class="line">                a       all perf events</span><br><span class="line"></span><br><span class="line">        If supported, the &#x27;q&#x27; option may be repeated to increase the effect.</span><br><span class="line"></span><br><span class="line">        To disable decoding entirely, use --no-itrace.</span><br><span class="line"></span><br><span class="line">--full-source-path</span><br><span class="line">    Show the full path for source files for srcline output.</span><br><span class="line"></span><br><span class="line">--show-ref-call-graph</span><br><span class="line">    When multiple events are sampled, it may not be needed to</span><br><span class="line">    collect callgraphs for all of them. The sample sites are</span><br><span class="line">    usually nearby, and it’s enough to collect the callgraphs on</span><br><span class="line">    a reference event. So user can use &quot;call-graph=no&quot; event</span><br><span class="line">    modifier to disable callgraph for other events to reduce the</span><br><span class="line">    overhead. However, perf report cannot show callgraphs for the</span><br><span class="line">    event which disable the callgraph. This option extends the</span><br><span class="line">    perf report to show reference callgraphs, which collected by</span><br><span class="line">    reference event, in no callgraph event.</span><br><span class="line"></span><br><span class="line">--stitch-lbr</span><br><span class="line">    Show callgraph with stitched LBRs, which may have more</span><br><span class="line">    complete callgraph. The perf.data file must have been</span><br><span class="line">    obtained using perf record --call-graph lbr. Disabled by</span><br><span class="line">    default. In common cases with call stack overflows, it can</span><br><span class="line">    recreate better call stacks than the default lbr call stack</span><br><span class="line">    output. But this approach is not full proof. There can be</span><br><span class="line">    cases where it creates incorrect call stacks from incorrect</span><br><span class="line">    matches. The known limitations include exception handing such</span><br><span class="line">    as setjmp/longjmp will have calls/returns not match.</span><br><span class="line"></span><br><span class="line">--socket-filter</span><br><span class="line">    Only report the samples on the processor socket that match</span><br><span class="line">    with this filter</span><br><span class="line"></span><br><span class="line">--samples=N</span><br><span class="line">    Save N individual samples for each histogram entry to show</span><br><span class="line">    context in perf report tui browser.</span><br><span class="line"></span><br><span class="line">--raw-trace</span><br><span class="line">    When displaying traceevent output, do not use print fmt or</span><br><span class="line">    plugins.</span><br><span class="line"></span><br><span class="line">--hierarchy</span><br><span class="line">    Enable hierarchical output.</span><br><span class="line"></span><br><span class="line">--inline</span><br><span class="line">    If a callgraph address belongs to an inlined function, the</span><br><span class="line">    inline stack will be printed. Each entry is function name or</span><br><span class="line">    file/line. Enabled by default, disable with --no-inline.</span><br><span class="line"></span><br><span class="line">--mmaps</span><br><span class="line">    Show --tasks output plus mmap information in a format similar</span><br><span class="line">    to /proc/&lt;PID&gt;/maps.</span><br><span class="line"></span><br><span class="line">        Please note that not all mmaps are stored, options affecting which ones</span><br><span class="line">        are include &#x27;perf record --data&#x27;, for instance.</span><br><span class="line"></span><br><span class="line">--ns</span><br><span class="line">    Show time stamps in nanoseconds.</span><br><span class="line"></span><br><span class="line">--stats</span><br><span class="line">    Display overall events statistics without any further</span><br><span class="line">    processing. (like the one at the end of the perf report -D</span><br><span class="line">    command)</span><br><span class="line"></span><br><span class="line">--tasks</span><br><span class="line">    Display monitored tasks stored in perf data. Displaying</span><br><span class="line">    pid/tid/ppid plus the command string aligned to distinguish</span><br><span class="line">    parent and child tasks.</span><br><span class="line"></span><br><span class="line">--percent-type</span><br><span class="line">    Set annotation percent type from following choices:</span><br><span class="line">    global-period, local-period, global-hits, local-hits</span><br><span class="line"></span><br><span class="line">        The local/global keywords set if the percentage is computed</span><br><span class="line">        in the scope of the function (local) or the whole data (global).</span><br><span class="line">        The period/hits keywords set the base the percentage is computed</span><br><span class="line">        on - the samples period or the number of samples (hits).</span><br><span class="line"></span><br><span class="line">--time-quantum</span><br><span class="line">    Configure time quantum for time sort key. Default 100ms.</span><br><span class="line">    Accepts s, us, ms, ns units.</span><br><span class="line"></span><br><span class="line">--total-cycles</span><br><span class="line">    When --total-cycles is specified, it supports sorting for all</span><br><span class="line">    blocks by Sampled Cycles%. This is useful to concentrate on</span><br><span class="line">    the globally hottest blocks. In output, there are some new</span><br><span class="line">    columns:</span><br><span class="line"></span><br><span class="line">        &#x27;Sampled Cycles%&#x27; - block sampled cycles aggregation / total sampled cycles</span><br><span class="line">        &#x27;Sampled Cycles&#x27;  - block sampled cycles aggregation</span><br><span class="line">        &#x27;Avg Cycles%&#x27;     - block average sampled cycles / sum of total block average</span><br><span class="line">                            sampled cycles</span><br><span class="line">        &#x27;Avg Cycles&#x27;      - block average sampled cycles</span><br><span class="line"></span><br><span class="line">--skip-empty</span><br><span class="line">    Do not print 0 results in the --stat output.</span><br></pre></td></tr></table></figure><h2 id="OVERHEAD-CALCULATION-top"><a href="#OVERHEAD-CALCULATION-top" class="headerlink" title="OVERHEAD CALCULATION     top"></a>OVERHEAD CALCULATION     <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">The overhead can be shown in two columns as Children and Self</span><br><span class="line">when perf collects callchains. The self overhead is simply</span><br><span class="line">calculated by adding all period values of the entry - usually a</span><br><span class="line">function (symbol). This is the value that perf shows</span><br><span class="line">traditionally and sum of all the self overhead values should be</span><br><span class="line">100%.</span><br><span class="line"></span><br><span class="line">The children overhead is calculated by adding all period values</span><br><span class="line">of the child functions so that it can show the total overhead of</span><br><span class="line">the higher level functions even if they don’t directly execute</span><br><span class="line">much. Children here means functions that are called from another</span><br><span class="line">(parent) function.</span><br><span class="line"></span><br><span class="line">It might be confusing that the sum of all the children overhead</span><br><span class="line">values exceeds 100% since each of them is already an accumulation</span><br><span class="line">of self overhead of its child functions. But with this enabled,</span><br><span class="line">users can find which function has the most overhead even if</span><br><span class="line">samples are spread over the children.</span><br><span class="line"></span><br><span class="line">Consider the following example; there are three functions like</span><br><span class="line">below.</span><br><span class="line"></span><br><span class="line">    .ft C</span><br><span class="line">    void foo(void) &#123;</span><br><span class="line">        /* do something */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void bar(void) &#123;</span><br><span class="line">        /* do something */</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int main(void) &#123;</span><br><span class="line">        bar()</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .ft</span><br><span class="line"></span><br><span class="line">In this case foo is a child of bar, and bar is an immediate child</span><br><span class="line">of main so foo also is a child of main. In other words, main is a</span><br><span class="line">parent of foo and bar, and bar is a parent of foo.</span><br><span class="line"></span><br><span class="line">Suppose all samples are recorded in foo and bar only. When it’s</span><br><span class="line">recorded with callchains the output will show something like</span><br><span class="line">below in the usual (self-overhead-only) output of perf report:</span><br><span class="line"></span><br><span class="line">    .ft C</span><br><span class="line">    Overhead  Symbol</span><br><span class="line">    ........  .....................</span><br><span class="line">      60.00%  foo</span><br><span class="line">              |</span><br><span class="line">              --- foo</span><br><span class="line">                  bar</span><br><span class="line">                  main</span><br><span class="line">                  __libc_start_main</span><br><span class="line"></span><br><span class="line">      40.00%  bar</span><br><span class="line">              |</span><br><span class="line">              --- bar</span><br><span class="line">                  main</span><br><span class="line">                  __libc_start_main</span><br><span class="line">    .ft</span><br><span class="line"></span><br><span class="line">When the --children option is enabled, the self overhead values</span><br><span class="line">of child functions (i.e. foo and bar) are added to the parents to</span><br><span class="line">calculate the children overhead. In this case the report could be</span><br><span class="line">displayed as:</span><br><span class="line"></span><br><span class="line">    .ft C</span><br><span class="line">    Children      Self  Symbol</span><br><span class="line">    ........  ........  ....................</span><br><span class="line">     100.00%     0.00%  __libc_start_main</span><br><span class="line">              |</span><br><span class="line">              --- __libc_start_main</span><br><span class="line"></span><br><span class="line">     100.00%     0.00%  main</span><br><span class="line">              |</span><br><span class="line">              --- main</span><br><span class="line">                  __libc_start_main</span><br><span class="line"></span><br><span class="line">     100.00%    40.00%  bar</span><br><span class="line">              |</span><br><span class="line">              --- bar</span><br><span class="line">                  main</span><br><span class="line">                  __libc_start_main</span><br><span class="line"></span><br><span class="line">      60.00%    60.00%  foo</span><br><span class="line">              |</span><br><span class="line">              --- foo</span><br><span class="line">                  bar</span><br><span class="line">                  main</span><br><span class="line">                  __libc_start_main</span><br><span class="line">    .ft</span><br><span class="line"></span><br><span class="line">In the above output, the self overhead of foo (60%) was add to</span><br><span class="line">the children overhead of bar, main and __libc_start_main.</span><br><span class="line">Likewise, the self overhead of bar (40%) was added to the</span><br><span class="line">children overhead of main and \_\_libc_start_main.</span><br><span class="line"></span><br><span class="line">So \_\_libc_start_main and main are shown first since they have</span><br><span class="line">same (100%) children overhead (even though they have zero self</span><br><span class="line">overhead) and they are the parents of foo and bar.</span><br><span class="line"></span><br><span class="line">Since v3.16 the children overhead is shown by default and the</span><br><span class="line">output is sorted by its values. The children overhead is disabled</span><br><span class="line">by specifying --no-children option on the command line or by</span><br><span class="line">adding report.children = false or top.children = false in the</span><br><span class="line">perf config file.</span><br></pre></td></tr></table></figure><h2 id="SEE-ALSO-top"><a href="#SEE-ALSO-top" class="headerlink" title="SEE ALSO     top"></a>SEE ALSO     <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf-stat(1), perf-annotate(1), perf-record(1), perf-intel-pt(1)</span><br></pre></td></tr></table></figure><h2 id="COLOPHON-top"><a href="#COLOPHON-top" class="headerlink" title="COLOPHON     top"></a>COLOPHON     <a href="https://www.man7.org/linux/man-pages/man1/perf-report.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">       This page is part of the perf (Performance analysis tools for</span><br><span class="line">       Linux (in Linux source tree)) project.  Information about the</span><br><span class="line">       project can be found at</span><br><span class="line">       ⟨https://perf.wiki.kernel.org/index.php/Main_Page⟩.  If you have a</span><br><span class="line">       bug report for this manual page, send it to</span><br><span class="line">       linux-kernel@vger.kernel.org.  This page was obtained from the</span><br><span class="line">       project&#x27;s upstream Git repository</span><br><span class="line">       ⟨http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git⟩</span><br><span class="line">       on 2021-08-27.  (At that time, the date of the most recent commit</span><br><span class="line">       that was found in the repository was 2021-08-26.)  If you</span><br><span class="line">       discover any rendering problems in this HTML version of the page,</span><br><span class="line">       or you believe there is a better or more up-to-date source for</span><br><span class="line">       the page, or you have corrections or improvements to the</span><br><span class="line">       information in this COLOPHON (which is not part of the original</span><br><span class="line">       manual page), send a mail to man-pages@man7.org</span><br><span class="line"></span><br><span class="line">perf                           2021-04-29                 PERF-REPORT(1)</span><br></pre></td></tr></table></figure><hr><p>Pages that refer to this page: <a href="https://www.man7.org/linux/man-pages/man1/perf.1.html">perf(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-annotate.1.html">perf-annotate(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-archive.1.html">perf-archive(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-buildid-cache.1.html">perf-buildid-cache(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-buildid-list.1.html">perf-buildid-list(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-diff.1.html">perf-diff(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-evlist.1.html">perf-evlist(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-inject.1.html">perf-inject(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-intel-pt.1.html">perf-intel-pt(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-kvm.1.html">perf-kvm(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-mem.1.html">perf-mem(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-top.1.html">perf-top(1)</a></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Perf-Stat(1)</title>
      <link href="/2022/10/13/01%20OS/Linux/Perf/perf-stat/"/>
      <url>/2022/10/13/01%20OS/Linux/Perf/perf-stat/</url>
      
        <content type="html"><![CDATA[<h1 id="perf-stat-1"><a href="#perf-stat-1" class="headerlink" title="perf-stat(1)"></a>perf-stat(1)</h1><h2 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h2><p>perf-stat - Run a command and gather performance counter statistics</p><h2 id="SYNOPSIS"><a href="#SYNOPSIS" class="headerlink" title="SYNOPSIS"></a>SYNOPSIS</h2><p>[verse]<br>‘perf stat’ [-e <EVENT> | –event&#x3D;EVENT] [-a] <command><br>‘perf stat’ [-e <EVENT> | –event&#x3D;EVENT] [-a] -- <command> [<options>]<br>‘perf stat’ [-e <EVENT> | –event&#x3D;EVENT] [-a] record [-o file] -- <command> [<options>]<br>‘perf stat’ report [-i file]</p><h2 id="DESCRIPTION"><a href="#DESCRIPTION" class="headerlink" title="DESCRIPTION"></a>DESCRIPTION</h2><p>This command runs a command and gathers performance counter statistics<br>from it.</p><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p><command>…::<br>    Any command you can specify in a shell.</p><p>record::<br>    See STAT RECORD.</p><p>report::<br>    See STAT REPORT.</p><p>-e::<br>–event&#x3D;::<br>    Select the PMU event. Selection can be:</p><pre><code>- a symbolic event name (use &#39;perf list&#39; to list all events)- a raw PMU event in the form of rN where N is a hexadecimal value  that represents the raw register encoding with the layout of the  event control registers as described by entries in  /sys/bus/event_source/devices/cpu/format/*.    - a symbolic or raw PMU event followed by an optional colon  and a list of event modifiers, e.g., cpu-cycles:p.  See the  linkperf:perf-list[1] man page for details on event modifiers.- a symbolically formed event like &#39;pmu/param1=0x3,param2/&#39; where  param1 and param2 are defined as formats for the PMU in  /sys/bus/event_source/devices/&lt;pmu&gt;/format/*  &#39;percore&#39; is a event qualifier that sums up the event counts for both  hardware threads in a core. For example:  perf stat -A -a -e cpu/event,percore=1/,otherevent ...- a symbolically formed event like &#39;pmu/config=M,config1=N,config2=K/&#39;  where M, N, K are numbers (in decimal, hex, octal format).  Acceptable values for each of &#39;config&#39;, &#39;config1&#39; and &#39;config2&#39;  parameters are defined by corresponding entries in  /sys/bus/event_source/devices/&lt;pmu&gt;/format/*Note that the last two syntaxes support prefix and glob matching inthe PMU name to simplify creation of events across multiple instancesof the same type of PMU in large systems (e.g. memory controller PMUs).Multiple PMU instances are typical for uncore PMUs, so the prefix&#39;uncore_&#39; is also ignored when performing this match.</code></pre><p>-i::<br>–no-inherit::<br>        child tasks do not inherit counters<br>-p::<br>–pid&#x3D;<pid>::<br>        stat events on existing process id (comma separated list)</p><p>-t::<br>–tid&#x3D;<tid>::<br>        stat events on existing thread id (comma separated list)</p><p>-b::<br>–bpf-prog::<br>        stat events on existing bpf program id (comma separated list),<br>        requiring root rights. bpftool-prog could be used to find program<br>        id all bpf programs in the system. For example:</p><h1 id="bpftool-prog-head-n-1"><a href="#bpftool-prog-head-n-1" class="headerlink" title="bpftool prog | head -n 1"></a>bpftool prog | head -n 1</h1><p>  17247: tracepoint  name sys_enter  tag 192d548b9d754067  gpl</p><h1 id="perf-stat-e-cycles-instructions-–bpf-prog-17247-–timeout-1000"><a href="#perf-stat-e-cycles-instructions-–bpf-prog-17247-–timeout-1000" class="headerlink" title="perf stat -e cycles,instructions –bpf-prog 17247 –timeout 1000"></a>perf stat -e cycles,instructions –bpf-prog 17247 –timeout 1000</h1><p>   Performance counter stats for ‘BPF program(s) 17247’:</p><pre><code>         85,967      cycles         28,982      instructions              #    0.34  insn per cycle    1.102235068 seconds time elapsed</code></pre><p>–bpf-counters::<br>    Use BPF programs to aggregate readings from perf_events.  This<br>    allows multiple perf-stat sessions that are counting the same metric (cycles,<br>    instructions, etc.) to share hardware counters.<br>    To use BPF programs on common events by default, use<br>    “perf config stat.bpf-counter-events&#x3D;<list_of_events>“.</p><p>–bpf-attr-map::<br>    With option “–bpf-counters”, different perf-stat sessions share<br>    information about shared BPF programs and maps via a pinned hashmap.<br>    Use “–bpf-attr-map” to specify the path of this pinned hashmap.<br>    The default path is &#x2F;sys&#x2F;fs&#x2F;bpf&#x2F;perf_attr_map.</p><p>ifdef::HAVE_LIBPFM[]<br>–pfm-events events::<br>Select a PMU event using libpfm4 syntax (see <a href="http://perfmon2.sf.net/">http://perfmon2.sf.net</a>)<br>including support for event filters. For example ‘–pfm-events<br>inst_retired:any_p:u:c&#x3D;1:i’. More than one event can be passed to the<br>option using the comma separator. Hardware events and generic hardware<br>events cannot be mixed together. The latter must be used with the -e<br>option. The -e option and this one can be mixed and matched.  Events<br>can be grouped using the {} notation.<br>endif::HAVE_LIBPFM[]</p><p>-a::<br>–all-cpus::<br>        system-wide collection from all CPUs (default if no target is specified)</p><p>–no-scale::<br>    Don’t scale&#x2F;normalize counter values</p><p>-d::<br>–detailed::<br>    print more detailed statistics, can be specified up to 3 times</p><pre><code>   -d:          detailed events, L1 and LLC data cache    -d -d:     more detailed events, dTLB and iTLB events -d -d -d:     very detailed events, adding prefetch events</code></pre><p>-r::<br>–repeat&#x3D;<n>::<br>    repeat command and print average + stddev (max: 100). 0 means forever.</p><p>-B::<br>–big-num::<br>        print large numbers with thousands’ separators according to locale.<br>    Enabled by default. Use “–no-big-num” to disable.<br>    Default setting can be changed with “perf config stat.big-num&#x3D;false”.</p><p>-C::<br>–cpu&#x3D;::<br>Count only on the list of CPUs provided. Multiple CPUs can be provided as a<br>comma-separated list with no space: 0,1. Ranges of CPUs are specified with -: 0-2.<br>In per-thread mode, this option is ignored. The -a option is still necessary<br>to activate system-wide monitoring. Default is to count on all CPUs.</p><p>-A::<br>–no-aggr::<br>Do not aggregate counts across all monitored CPUs.</p><p>-n::<br>–null::<br>null run - Don’t start any counters.</p><p>This can be useful to measure just elapsed wall-clock time - or to assess the<br>raw overhead of perf stat itself, without running any counters.</p><p>-v::<br>–verbose::<br>        be more verbose (show counter open errors, etc)</p><p>-x SEP::<br>–field-separator SEP::<br>print counts using a CSV-style output to make it easy to import directly into<br>spreadsheets. Columns are separated by the string specified in SEP.</p><p>–table:: Display time for each run (-r option), in a table format, e.g.:</p><p>  $ perf stat –null -r 5 –table perf bench sched pipe</p><p>   Performance counter stats for ‘perf bench sched pipe’ (5 runs):</p><pre><code>         # Table of individual measurements:         5.189 (-0.293) #         5.189 (-0.294) #         5.186 (-0.296) #         5.663 (+0.181) ##         6.186 (+0.703) ####         # Final result:         5.483 +- 0.198 seconds time elapsed  ( +-  3.62% )</code></pre><p>-G name::<br>–cgroup name::<br>monitor only in the container (cgroup) called “name”. This option is available only<br>in per-cpu mode. The cgroup filesystem must be mounted. All threads belonging to<br>container “name” are monitored when they run on the monitored CPUs. Multiple cgroups<br>can be provided. Each cgroup is applied to the corresponding event, i.e., first cgroup<br>to first event, second cgroup to second event and so on. It is possible to provide<br>an empty cgroup (monitor all the time) using, e.g., -G foo,,bar. Cgroups must have<br>corresponding events, i.e., they always refer to events defined earlier on the command<br>line. If the user wants to track multiple events for a specific cgroup, the user can<br>use ‘-e e1 -e e2 -G foo,foo’ or just use ‘-e e1 -e e2 -G foo’.</p><p>If wanting to monitor, say, ‘cycles’ for a cgroup and also for system wide, this<br>command line can be used: ‘perf stat -e cycles -G cgroup_name -a -e cycles’.</p><p>–for-each-cgroup name::<br>Expand event list for each cgroup in “name” (allow multiple cgroups separated<br>by comma).  It also support regex patterns to match multiple groups.  This has same<br>effect that repeating -e option and -G option for each event x name.  This option<br>cannot be used with -G&#x2F;–cgroup option.</p><p>-o file::<br>–output file::<br>Print the output into the designated file.</p><p>–append::<br>Append to the output file designated with the -o option. Ignored if -o is not specified.</p><p>–log-fd::</p><p>Log output to fd, instead of stderr.  Complementary to –output, and mutually exclusive<br>with it.  –append may be used here.  Examples:<br>     3&gt;results  perf stat –log-fd 3          -- $cmd<br>     3&gt;&gt;results perf stat –log-fd 3 –append -- $cmd</p><p>–control&#x3D;fifo:ctl-fifo[,ack-fifo]::<br>–control&#x3D;fd:ctl-fd[,ack-fd]::<br>ctl-fifo &#x2F; ack-fifo are opened and used as ctl-fd &#x2F; ack-fd as follows.<br>Listen on ctl-fd descriptor for command to control measurement (‘enable’: enable events,<br>‘disable’: disable events). Measurements can be started with events disabled using<br>–delay&#x3D;-1 option. Optionally send control command completion (‘ack\n’) to ack-fd descriptor<br>to synchronize with the controlling process. Example of bash shell script to enable and<br>disable events during measurements:</p><p> #!&#x2F;bin&#x2F;bash</p><p> ctl_dir&#x3D;&#x2F;tmp&#x2F;</p><p> ctl_fifo&#x3D;${ctl_dir}perf_ctl.fifo<br> test -p ${ctl_fifo} &amp;&amp; unlink ${ctl_fifo}<br> mkfifo ${ctl_fifo}<br> exec {ctl_fd}&lt;&gt;${ctl_fifo}</p><p> ctl_ack_fifo&#x3D;${ctl_dir}perf_ctl_ack.fifo<br> test -p ${ctl_ack_fifo} &amp;&amp; unlink ${ctl_ack_fifo}<br> mkfifo ${ctl_ack_fifo}<br> exec {ctl_fd_ack}&lt;&gt;${ctl_ack_fifo}</p><p> perf stat -D -1 -e cpu-cycles -a -I 1000       <br>           –control fd:${ctl_fd},${ctl_fd_ack} <br>           -- sleep 30 &amp;<br> perf_pid&#x3D;$!</p><p> sleep 5  &amp;&amp; echo ‘enable’ &gt;&amp;${ctl_fd} &amp;&amp; read -u ${ctl_fd_ack} e1 &amp;&amp; echo “enabled(${e1})”<br> sleep 10 &amp;&amp; echo ‘disable’ &gt;&amp;${ctl_fd} &amp;&amp; read -u ${ctl_fd_ack} d1 &amp;&amp; echo “disabled(${d1})”</p><p> exec {ctl_fd_ack}&gt;&amp;-<br> unlink ${ctl_ack_fifo}</p><p> exec {ctl_fd}&gt;&amp;-<br> unlink ${ctl_fifo}</p><p> wait -n ${perf_pid}<br> exit $?</p><p>–pre::<br>–post::<br>    Pre and post measurement hooks, e.g.:</p><p>perf stat –repeat 10 –null –sync –pre ‘make -s O&#x3D;defconfig-build&#x2F;clean’ -- make -s -j64 O&#x3D;defconfig-build&#x2F; bzImage</p><p>-I msecs::<br>–interval-print msecs::<br>Print count deltas every N milliseconds (minimum: 1ms)<br>The overhead percentage could be high in some cases, for instance with small, sub 100ms intervals.  Use with caution.<br>    example: ‘perf stat -I 1000 -e cycles -a sleep 5’</p><p>If the metric exists, it is calculated by the counts generated in this interval and the metric is printed after #.</p><p>–interval-count times::<br>Print count deltas for fixed number of times.<br>This option should be used together with “-I” option.<br>    example: ‘perf stat -I 1000 –interval-count 2 -e cycles -a’</p><p>–interval-clear::<br>Clear the screen before next interval.</p><p>–timeout msecs::<br>Stop the ‘perf stat’ session and print count deltas after N milliseconds (minimum: 10 ms).<br>This option is not supported with the “-I” option.<br>    example: ‘perf stat –time 2000 -e cycles -a’</p><p>–metric-only::<br>Only print computed metrics. Print them in a single line.<br>Don’t show any raw values. Not supported with –per-thread.</p><p>–per-socket::<br>Aggregate counts per processor socket for system-wide mode measurements.  This<br>is a useful mode to detect imbalance between sockets.  To enable this mode,<br>use –per-socket in addition to -a. (system-wide).  The output includes the<br>socket number and the number of online processors on that socket. This is<br>useful to gauge the amount of aggregation.</p><p>–per-die::<br>Aggregate counts per processor die for system-wide mode measurements.  This<br>is a useful mode to detect imbalance between dies.  To enable this mode,<br>use –per-die in addition to -a. (system-wide).  The output includes the<br>die number and the number of online processors on that die. This is<br>useful to gauge the amount of aggregation.</p><p>–per-core::<br>Aggregate counts per physical processor for system-wide mode measurements.  This<br>is a useful mode to detect imbalance between physical cores.  To enable this mode,<br>use –per-core in addition to -a. (system-wide).  The output includes the<br>core number and the number of online logical processors on that physical processor.</p><p>–per-thread::<br>Aggregate counts per monitored threads, when monitoring threads (-t option)<br>or processes (-p option).</p><p>–per-node::<br>Aggregate counts per NUMA nodes for system-wide mode measurements. This<br>is a useful mode to detect imbalance between NUMA nodes. To enable this<br>mode, use –per-node in addition to -a. (system-wide).</p><p>-D msecs::<br>–delay msecs::<br>After starting the program, wait msecs before measuring (-1: start with events<br>disabled). This is useful to filter out the startup phase of the program,<br>which is often very different.</p><p>-T::<br>–transaction::</p><p>Print statistics of transactional execution if supported.</p><p>–metric-no-group::<br>By default, events to compute a metric are placed in weak groups. The<br>group tries to enforce scheduling all or none of the events. The<br>–metric-no-group option places events outside of groups and may<br>increase the chance of the event being scheduled - leading to more<br>accuracy. However, as events may not be scheduled together accuracy<br>for metrics like instructions per cycle can be lower - as both metrics<br>may no longer be being measured at the same time.</p><p>–metric-no-merge::<br>By default metric events in different weak groups can be shared if one<br>group contains all the events needed by another. In such cases one<br>group will be eliminated reducing event multiplexing and making it so<br>that certain groups of metrics sum to 100%. A downside to sharing a<br>group is that the group may require multiplexing and so accuracy for a<br>small group that need not have multiplexing is lowered. This option<br>forbids the event merging logic from sharing events between groups and<br>may be used to increase accuracy in this case.</p><p>–quiet::<br>Don’t print output. This is useful with perf stat record below to only<br>write data to the perf.data file.</p><h2 id="STAT-RECORD"><a href="#STAT-RECORD" class="headerlink" title="STAT RECORD"></a>STAT RECORD</h2><p>Stores stat data into perf data file.</p><p>-o file::<br>–output file::<br>Output file name.</p><h2 id="STAT-REPORT"><a href="#STAT-REPORT" class="headerlink" title="STAT REPORT"></a>STAT REPORT</h2><p>Reads and reports stat data from perf data file.</p><p>-i file::<br>–input file::<br>Input file name.</p><p>–per-socket::<br>Aggregate counts per processor socket for system-wide mode measurements.</p><p>–per-die::<br>Aggregate counts per processor die for system-wide mode measurements.</p><p>–per-core::<br>Aggregate counts per physical processor for system-wide mode measurements.</p><p>-M::<br>–metrics::<br>Print metrics or metricgroups specified in a comma separated list.<br>For a group all metrics from the group are added.<br>The events from the metrics are automatically measured.<br>See perf list output for the possible metrics and metricgroups.</p><p>-A::<br>–no-aggr::<br>Do not aggregate counts across all monitored CPUs.</p><p>–topdown::<br>Print complete top-down metrics supported by the CPU. This allows to<br>determine bottle necks in the CPU pipeline for CPU bound workloads,<br>by breaking the cycles consumed down into frontend bound, backend bound,<br>bad speculation and retiring.</p><p>Frontend bound means that the CPU cannot fetch and decode instructions fast<br>enough. Backend bound means that computation or memory access is the bottle<br>neck. Bad Speculation means that the CPU wasted cycles due to branch<br>mispredictions and similar issues. Retiring means that the CPU computed without<br>an apparently bottleneck. The bottleneck is only the real bottleneck<br>if the workload is actually bound by the CPU and not by something else.</p><p>For best results it is usually a good idea to use it with interval<br>mode like -I 1000, as the bottleneck of workloads can change often.</p><p>This enables –metric-only, unless overridden with –no-metric-only.</p><p>The following restrictions only apply to older Intel CPUs and Atom,<br>on newer CPUs (IceLake and later) TopDown can be collected for any thread:</p><p>The top down metrics are collected per core instead of per<br>CPU thread. Per core mode is automatically enabled<br>and -a (global monitoring) is needed, requiring root rights or<br>perf.perf_event_paranoid&#x3D;-1.</p><p>Topdown uses the full Performance Monitoring Unit, and needs<br>disabling of the NMI watchdog (as root):<br>echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;nmi_watchdog<br>for best results. Otherwise the bottlenecks may be inconsistent<br>on workload with changing phases.</p><p>To interpret the results it is usually needed to know on which<br>CPUs the workload runs on. If needed the CPUs can be forced using<br>taskset.</p><p>–td-level::<br>Print the top-down statistics that equal to or lower than the input level.<br>It allows users to print the interested top-down metrics level instead of<br>the complete top-down metrics.</p><p>The availability of the top-down metrics level depends on the hardware. For<br>example, Ice Lake only supports L1 top-down metrics. The Sapphire Rapids<br>supports both L1 and L2 top-down metrics.</p><p>Default: 0 means the max level that the current hardware support.<br>Error out if the input is higher than the supported max level.</p><p>–no-merge::<br>Do not merge results from same PMUs.</p><p>When multiple events are created from a single event specification,<br>stat will, by default, aggregate the event counts and show the result<br>in a single row. This option disables that behavior and shows<br>the individual events and counts.</p><p>Multiple events are created from a single event specification when:</p><ol><li>Prefix or glob matching is used for the PMU name.</li><li>Aliases, which are listed immediately after the Kernel PMU events<br>by perf list, are used.</li></ol><p>–hybrid-merge::<br>Merge the hybrid event counts from all PMUs.</p><p>For hybrid events, by default, the stat aggregates and reports the event<br>counts per PMU. But sometimes, it’s also useful to aggregate event counts<br>from all PMUs. This option enables that behavior and reports the counts<br>without PMUs.</p><p>For non-hybrid events, it should be no effect.</p><p>–smi-cost::<br>Measure SMI cost if msr&#x2F;aperf&#x2F; and msr&#x2F;smi&#x2F; events are supported.</p><p>During the measurement, the &#x2F;sys&#x2F;device&#x2F;cpu&#x2F;freeze_on_smi will be set to<br>freeze core counters on SMI.<br>The aperf counter will not be effected by the setting.<br>The cost of SMI can be measured by (aperf - unhalted core cycles).</p><p>In practice, the percentages of SMI cycles is very useful for performance<br>oriented analysis. –metric_only will be applied by default.<br>The output is SMI cycles%, equals to (aperf - unhalted core cycles) &#x2F; aperf</p><p>Users who wants to get the actual value can apply –no-metric-only.</p><p>–all-kernel::<br>Configure all used events to run in kernel space.</p><p>–all-user::<br>Configure all used events to run in user space.</p><p>–percore-show-thread::<br>The event modifier “percore” has supported to sum up the event counts<br>for all hardware threads in a core and show the counts per core.</p><p>This option with event modifier “percore” enabled also sums up the event<br>counts for all hardware threads in a core but show the sum counts per<br>hardware thread. This is essentially a replacement for the any bit and<br>convenient for post processing.</p><p>–summary::<br>Print summary for interval mode (-I).</p><p>–no-csv-summary::<br>Don’t print ‘summary’ at the first column for CVS summary output.<br>This option must be used with -x and –summary.</p><p>This option can be enabled in perf config by setting the variable<br>‘stat.no-csv-summary’.</p><p>$ perf config stat.no-csv-summary&#x3D;true</p><p>–cputype::<br>Only enable events on applying cpu with this type for hybrid platform<br>(e.g. core or atom)”</p><h2 id="EXAMPLES"><a href="#EXAMPLES" class="headerlink" title="EXAMPLES"></a>EXAMPLES</h2><p>$ perf stat -- make</p><p>   Performance counter stats for ‘make’:</p><pre><code>    83723.452481      task-clock:u (msec)       #    1.004 CPUs utilized               0      context-switches:u        #    0.000 K/sec               0      cpu-migrations:u          #    0.000 K/sec       3,228,188      page-faults:u             #    0.039 M/sec 229,570,665,834      cycles:u                  #    2.742 GHz 313,163,853,778      instructions:u            #    1.36  insn per cycle  69,704,684,856      branches:u                #  832.559 M/sec   2,078,861,393      branch-misses:u           #    2.98% of all branches    83.409183620 seconds time elapsed    74.684747000 seconds user     8.739217000 seconds sys</code></pre><h2 id="TIMINGS"><a href="#TIMINGS" class="headerlink" title="TIMINGS"></a>TIMINGS</h2><p>As displayed in the example above we can display 3 types of timings.<br>We always display the time the counters were enabled&#x2F;alive:</p><pre><code>    83.409183620 seconds time elapsed</code></pre><p>For workload sessions we also display time the workloads spent in<br>user&#x2F;system lands:</p><pre><code>    74.684747000 seconds user     8.739217000 seconds sys</code></pre><p>Those times are the very same as displayed by the ‘time’ tool.</p><h2 id="CSV-FORMAT"><a href="#CSV-FORMAT" class="headerlink" title="CSV FORMAT"></a>CSV FORMAT</h2><p>With -x, perf stat is able to output a not-quite-CSV format output<br>Commas in the output are not put into “”. To make it easy to parse<br>it is recommended to use a different character like -x ;</p><p>The fields are in this order:</p><pre><code>- optional usec time stamp in fractions of second (with -I xxx)- optional CPU, core, or socket identifier- optional number of logical CPUs aggregated- counter value- unit of the counter value or empty- event name- run time of counter- percentage of measurement time the counter was running- optional variance if multiple values are collected with -r- optional metric value- optional unit of metric</code></pre><p>Additional metrics may be printed with all earlier fields being empty.</p><p>include::intel-hybrid.txt[]</p><h2 id="JSON-FORMAT"><a href="#JSON-FORMAT" class="headerlink" title="JSON FORMAT"></a>JSON FORMAT</h2><p>With -j, perf stat is able to print out a JSON format output<br>that can be used for parsing.</p><ul><li>timestamp : optional usec time stamp in fractions of second (with -I)</li><li>optional aggregate options:<br>  - core : core identifier (with –per-core)<br>  - die : die identifier (with –per-die)<br>  - socket : socket identifier (with –per-socket)<br>  - node : node identifier (with –per-node)<br>  - thread : thread identifier (with –per-thread)</li><li>counter-value : counter value</li><li>unit : unit of the counter value or empty</li><li>event : event name</li><li>variance : optional variance if multiple values are collected (with -r)</li><li>runtime : run time of counter</li><li>metric-value : optional metric value</li><li>metric-unit : optional unit of metric</li></ul><h2 id="SEE-ALSO"><a href="#SEE-ALSO" class="headerlink" title="SEE ALSO"></a>SEE ALSO</h2><p>linkperf:perf-top[1], linkperf:perf-list[1]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Perf-Script(1) — Linux Manual Page</title>
      <link href="/2022/10/13/01%20OS/Linux/Perf/perf-script/"/>
      <url>/2022/10/13/01%20OS/Linux/Perf/perf-script/</url>
      
        <content type="html"><![CDATA[<h1 id="perf-script-1-—-Linux-manual-page"><a href="#perf-script-1-—-Linux-manual-page" class="headerlink" title="perf-script(1) — Linux manual page"></a>perf-script(1) — Linux manual page</h1><table><thead><tr><th><a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#NAME">NAME</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#SYNOPSIS">SYNOPSIS</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#DESCRIPTION">DESCRIPTION</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#OPTIONS">OPTIONS</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#SEE_ALSO">SEE ALSO</a> | <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#COLOPHON">COLOPHON</a></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PERF-SCRIPT(1)                 perf Manual                PERF-SCRIPT(1)</span><br></pre></td></tr></table></figure><h2 id="NAME-top"><a href="#NAME-top" class="headerlink" title="NAME     top"></a>NAME     <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perf-script - Read perf.data (created by perf record) and display</span><br><span class="line">trace output</span><br></pre></td></tr></table></figure><h2 id="SYNOPSIS-top"><a href="#SYNOPSIS-top" class="headerlink" title="SYNOPSIS     top"></a>SYNOPSIS     <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">perf script [&lt;options&gt;]</span><br><span class="line">perf script [&lt;options&gt;] record &lt;script&gt; [&lt;record-options&gt;] &lt;command&gt;</span><br><span class="line">perf script [&lt;options&gt;] report &lt;script&gt; [script-args]</span><br><span class="line">perf script [&lt;options&gt;] &lt;script&gt; &lt;required-script-args&gt; [&lt;record-options&gt;] &lt;command&gt;</span><br><span class="line">perf script [&lt;options&gt;] &lt;top-script&gt; [script-args]</span><br></pre></td></tr></table></figure><h2 id="DESCRIPTION-top"><a href="#DESCRIPTION-top" class="headerlink" title="DESCRIPTION     top"></a>DESCRIPTION     <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">This command reads the input file and displays the trace</span><br><span class="line">recorded.</span><br><span class="line"></span><br><span class="line">There are several variants of perf script:</span><br><span class="line"></span><br><span class="line">    &#x27;perf script&#x27; to see a detailed trace of the workload that was</span><br><span class="line">    recorded.</span><br><span class="line"></span><br><span class="line">    You can also run a set of pre-canned scripts that aggregate and</span><br><span class="line">    summarize the raw trace data in various ways (the list of scripts is</span><br><span class="line">    available via &#x27;perf script -l&#x27;).  The following variants allow you to</span><br><span class="line">    record and run those scripts:</span><br><span class="line"></span><br><span class="line">    &#x27;perf script record &lt;script&gt; &lt;command&gt;&#x27; to record the events required</span><br><span class="line">    for &#x27;perf script report&#x27;.  &lt;script&gt; is the name displayed in the</span><br><span class="line">    output of &#x27;perf script --list&#x27; i.e. the actual script name minus any</span><br><span class="line">    language extension.  If &lt;command&gt; is not specified, the events are</span><br><span class="line">    recorded using the -a (system-wide) &#x27;perf record&#x27; option.</span><br><span class="line"></span><br><span class="line">    &#x27;perf script report &lt;script&gt; [args]&#x27; to run and display the results</span><br><span class="line">    of &lt;script&gt;.  &lt;script&gt; is the name displayed in the output of &#x27;perf</span><br><span class="line">    script --list&#x27; i.e. the actual script name minus any language</span><br><span class="line">    extension.  The perf.data output from a previous run of &#x27;perf script</span><br><span class="line">    record &lt;script&gt;&#x27; is used and should be present for this command to</span><br><span class="line">    succeed.  [args] refers to the (mainly optional) args expected by</span><br><span class="line">    the script.</span><br><span class="line"></span><br><span class="line">    &#x27;perf script &lt;script&gt; &lt;required-script-args&gt; &lt;command&gt;&#x27; to both</span><br><span class="line">    record the events required for &lt;script&gt; and to run the &lt;script&gt;</span><br><span class="line">    using &#x27;live-mode&#x27; i.e. without writing anything to disk.  &lt;script&gt;</span><br><span class="line">    is the name displayed in the output of &#x27;perf script --list&#x27; i.e. the</span><br><span class="line">    actual script name minus any language extension.  If &lt;command&gt; is</span><br><span class="line">    not specified, the events are recorded using the -a (system-wide)</span><br><span class="line">    &#x27;perf record&#x27; option.  If &lt;script&gt; has any required args, they</span><br><span class="line">    should be specified before &lt;command&gt;.  This mode doesn&#x27;t allow for</span><br><span class="line">    optional script args to be specified; if optional script args are</span><br><span class="line">    desired, they can be specified using separate &#x27;perf script record&#x27;</span><br><span class="line">    and &#x27;perf script report&#x27; commands, with the stdout of the record step</span><br><span class="line">    piped to the stdin of the report script, using the &#x27;-o -&#x27; and &#x27;-i -&#x27;</span><br><span class="line">    options of the corresponding commands.</span><br><span class="line"></span><br><span class="line">    &#x27;perf script &lt;top-script&gt;&#x27; to both record the events required for</span><br><span class="line">    &lt;top-script&gt; and to run the &lt;top-script&gt; using &#x27;live-mode&#x27;</span><br><span class="line">    i.e. without writing anything to disk.  &lt;top-script&gt; is the name</span><br><span class="line">    displayed in the output of &#x27;perf script --list&#x27; i.e. the actual</span><br><span class="line">    script name minus any language extension; a &lt;top-script&gt; is defined</span><br><span class="line">    as any script name ending with the string &#x27;top&#x27;.</span><br><span class="line"></span><br><span class="line">    [&lt;record-options&gt;] can be passed to the record steps of &#x27;perf script</span><br><span class="line">    record&#x27; and &#x27;live-mode&#x27; variants; this isn&#x27;t possible however for</span><br><span class="line">    &lt;top-script&gt; &#x27;live-mode&#x27; or &#x27;perf script report&#x27; variants.</span><br><span class="line"></span><br><span class="line">    See the &#x27;SEE ALSO&#x27; section for links to language-specific</span><br><span class="line">    information on how to write and run your own trace scripts.</span><br></pre></td></tr></table></figure><h2 id="OPTIONS-top"><a href="#OPTIONS-top" class="headerlink" title="OPTIONS     top"></a>OPTIONS     <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br></pre></td><td class="code"><pre><span class="line">&lt;command&gt;...</span><br><span class="line">    Any command you can specify in a shell.</span><br><span class="line"></span><br><span class="line">-D, --dump-raw-trace=</span><br><span class="line">    Display verbose dump of the trace data.</span><br><span class="line"></span><br><span class="line">-L, --Latency=</span><br><span class="line">    Show latency attributes (irqs/preemption disabled, etc).</span><br><span class="line"></span><br><span class="line">-l, --list=</span><br><span class="line">    Display a list of available trace scripts.</span><br><span class="line"></span><br><span class="line">-s [lang], --script=</span><br><span class="line">    Process trace data with the given script</span><br><span class="line">    ([lang]:script[.ext]). If the string lang is specified in</span><br><span class="line">    place of a script name, a list of supported languages will be</span><br><span class="line">    displayed instead.</span><br><span class="line"></span><br><span class="line">-g, --gen-script=</span><br><span class="line">    Generate perf-script.[ext] starter script for given language,</span><br><span class="line">    using current perf.data.</span><br><span class="line"></span><br><span class="line">--dlfilter=&lt;file&gt;</span><br><span class="line">    Filter sample events using the given shared object file.</span><br><span class="line">    Refer perf-dlfilter(1)</span><br><span class="line"></span><br><span class="line">--dlarg=&lt;arg&gt;</span><br><span class="line">    Pass arg as an argument to the dlfilter. --dlarg may be</span><br><span class="line">    repeated to add more arguments.</span><br><span class="line"></span><br><span class="line">--list-dlfilters=</span><br><span class="line">    Display a list of available dlfilters. Use with option -v</span><br><span class="line">    (must come before option --list-dlfilters) to show long</span><br><span class="line">    descriptions.</span><br><span class="line"></span><br><span class="line">-a</span><br><span class="line">    Force system-wide collection. Scripts run without a &lt;command&gt;</span><br><span class="line">    normally use -a by default, while scripts run with a</span><br><span class="line">    &lt;command&gt; normally don’t - this option allows the latter to</span><br><span class="line">    be run in system-wide mode.</span><br><span class="line"></span><br><span class="line">-i, --input=</span><br><span class="line">    Input file name. (default: perf.data unless stdin is a fifo)</span><br><span class="line"></span><br><span class="line">-d, --debug-mode</span><br><span class="line">    Do various checks like samples ordering and lost events.</span><br><span class="line"></span><br><span class="line">-F, --fields</span><br><span class="line">    Comma separated list of fields to print. Options are: comm,</span><br><span class="line">    tid, pid, time, cpu, event, trace, ip, sym, dso, addr,</span><br><span class="line">    symoff, srcline, period, iregs, uregs, brstack, brstacksym,</span><br><span class="line">    flags, bpf-output, brstackinsn, brstackoff, callindent, insn,</span><br><span class="line">    insnlen, synth, phys_addr, metric, misc, srccode, ipc,</span><br><span class="line">    data_page_size, code_page_size. Field list can be prepended</span><br><span class="line">    with the type, trace, sw or hw, to indicate to which event</span><br><span class="line">    type the field list applies. e.g., -F sw:comm,tid,time,ip,sym</span><br><span class="line">    and -F trace:time,cpu,trace</span><br><span class="line"></span><br><span class="line">        perf script -F &lt;fields&gt;</span><br><span class="line"></span><br><span class="line">        is equivalent to:</span><br><span class="line"></span><br><span class="line">        perf script -F trace:&lt;fields&gt; -F sw:&lt;fields&gt; -F hw:&lt;fields&gt;</span><br><span class="line"></span><br><span class="line">        i.e., the specified fields apply to all event types if the type string</span><br><span class="line">        is not given.</span><br><span class="line"></span><br><span class="line">        In addition to overriding fields, it is also possible to add or remove</span><br><span class="line">        fields from the defaults. For example</span><br><span class="line"></span><br><span class="line">        -F -cpu,+insn</span><br><span class="line"></span><br><span class="line">        removes the cpu field and adds the insn field. Adding/removing fields</span><br><span class="line">        cannot be mixed with normal overriding.</span><br><span class="line"></span><br><span class="line">        The arguments are processed in the order received. A later usage can</span><br><span class="line">        reset a prior request. e.g.:</span><br><span class="line"></span><br><span class="line">        -F trace: -F comm,tid,time,ip,sym</span><br><span class="line"></span><br><span class="line">        The first -F suppresses trace events (field list is &quot;&quot;), but then the</span><br><span class="line">        second invocation sets the fields to comm,tid,time,ip,sym. In this case a</span><br><span class="line">        warning is given to the user:</span><br><span class="line"></span><br><span class="line">        &quot;Overriding previous field request for all events.&quot;</span><br><span class="line"></span><br><span class="line">        Alternatively, consider the order:</span><br><span class="line"></span><br><span class="line">        -F comm,tid,time,ip,sym -F trace:</span><br><span class="line"></span><br><span class="line">        The first -F sets the fields for all events and the second -F</span><br><span class="line">        suppresses trace events. The user is given a warning message about</span><br><span class="line">        the override, and the result of the above is that only S/W and H/W</span><br><span class="line">        events are displayed with the given fields.</span><br><span class="line"></span><br><span class="line">        It&#x27;s possible tp add/remove fields only for specific event type:</span><br><span class="line"></span><br><span class="line">        -Fsw:-cpu,-period</span><br><span class="line"></span><br><span class="line">        removes cpu and period from software events.</span><br><span class="line"></span><br><span class="line">        For the &#x27;wildcard&#x27; option if a user selected field is invalid for an</span><br><span class="line">        event type, a message is displayed to the user that the option is</span><br><span class="line">        ignored for that type. For example:</span><br><span class="line"></span><br><span class="line">        $ perf script -F comm,tid,trace</span><br><span class="line">        &#x27;trace&#x27; not valid for hardware events. Ignoring.</span><br><span class="line">        &#x27;trace&#x27; not valid for software events. Ignoring.</span><br><span class="line"></span><br><span class="line">        Alternatively, if the type is given an invalid field is specified it</span><br><span class="line">        is an error. For example:</span><br><span class="line"></span><br><span class="line">        perf script -v -F sw:comm,tid,trace</span><br><span class="line">        &#x27;trace&#x27; not valid for software events.</span><br><span class="line"></span><br><span class="line">        At this point usage is displayed, and perf-script exits.</span><br><span class="line"></span><br><span class="line">        The flags field is synthesized and may have a value when Instruction</span><br><span class="line">        Trace decoding. The flags are &quot;bcrosyiABExgh&quot; which stand for branch,</span><br><span class="line">        call, return, conditional, system, asynchronous, interrupt,</span><br><span class="line">        transaction abort, trace begin, trace end, in transaction, VM-Entry, and VM-Exit</span><br><span class="line">        respectively. Known combinations of flags are printed more nicely e.g.</span><br><span class="line">        &quot;call&quot; for &quot;bc&quot;, &quot;return&quot; for &quot;br&quot;, &quot;jcc&quot; for &quot;bo&quot;, &quot;jmp&quot; for &quot;b&quot;,</span><br><span class="line">        &quot;int&quot; for &quot;bci&quot;, &quot;iret&quot; for &quot;bri&quot;, &quot;syscall&quot; for &quot;bcs&quot;, &quot;sysret&quot; for &quot;brs&quot;,</span><br><span class="line">        &quot;async&quot; for &quot;by&quot;, &quot;hw int&quot; for &quot;bcyi&quot;, &quot;tx abrt&quot; for &quot;bA&quot;, &quot;tr strt&quot; for &quot;bB&quot;,</span><br><span class="line">        &quot;tr end&quot; for &quot;bE&quot;, &quot;vmentry&quot; for &quot;bcg&quot;, &quot;vmexit&quot; for &quot;bch&quot;.</span><br><span class="line">        However the &quot;x&quot; flag will be displayed separately in those</span><br><span class="line">        cases e.g. &quot;jcc     (x)&quot; for a condition branch within a transaction.</span><br><span class="line"></span><br><span class="line">        The callindent field is synthesized and may have a value when</span><br><span class="line">        Instruction Trace decoding. For calls and returns, it will display the</span><br><span class="line">        name of the symbol indented with spaces to reflect the stack depth.</span><br><span class="line"></span><br><span class="line">        When doing instruction trace decoding insn and insnlen give the</span><br><span class="line">        instruction bytes and the instruction length of the current</span><br><span class="line">        instruction.</span><br><span class="line"></span><br><span class="line">        The synth field is used by synthesized events which may be created when</span><br><span class="line">        Instruction Trace decoding.</span><br><span class="line"></span><br><span class="line">        The ipc (instructions per cycle) field is synthesized and may have a value when</span><br><span class="line">        Instruction Trace decoding.</span><br><span class="line"></span><br><span class="line">        Finally, a user may not set fields to none for all event types.</span><br><span class="line">        i.e., -F &quot;&quot; is not allowed.</span><br><span class="line"></span><br><span class="line">        The brstack output includes branch related information with raw addresses using the</span><br><span class="line">        /v/v/v/v/cycles syntax in the following order:</span><br><span class="line">        FROM: branch source instruction</span><br><span class="line">        TO  : branch target instruction</span><br><span class="line">        M/P/-: M=branch target mispredicted or branch direction was mispredicted, P=target predicted or direction predicted, -=not supported</span><br><span class="line">        X/- : X=branch inside a transactional region, -=not in transaction region or not supported</span><br><span class="line">        A/- : A=TSX abort entry, -=not aborted region or not supported</span><br><span class="line">        cycles</span><br><span class="line"></span><br><span class="line">        The brstacksym is identical to brstack, except that the FROM and TO addresses are printed in a symbolic form if possible.</span><br><span class="line"></span><br><span class="line">        When brstackinsn is specified the full assembler sequences of branch sequences for each sample</span><br><span class="line">        is printed. This is the full execution path leading to the sample. This is only supported when the</span><br><span class="line">        sample was recorded with perf record -b or -j any.</span><br><span class="line"></span><br><span class="line">        The brstackoff field will print an offset into a specific dso/binary.</span><br><span class="line"></span><br><span class="line">        With the metric option perf script can compute metrics for</span><br><span class="line">        sampling periods, similar to perf stat. This requires</span><br><span class="line">        specifying a group with multiple events defining metrics with the :S option</span><br><span class="line">        for perf record. perf will sample on the first event, and</span><br><span class="line">        print computed metrics for all the events in the group. Please note</span><br><span class="line">        that the metric computed is averaged over the whole sampling</span><br><span class="line">        period (since the last sample), not just for the sample point.</span><br><span class="line"></span><br><span class="line">        For sample events it&#x27;s possible to display misc field with -F +misc option,</span><br><span class="line">        following letters are displayed for each bit:</span><br><span class="line"></span><br><span class="line">        PERF_RECORD_MISC_KERNEL               K</span><br><span class="line">        PERF_RECORD_MISC_USER                 U</span><br><span class="line">        PERF_RECORD_MISC_HYPERVISOR           H</span><br><span class="line">        PERF_RECORD_MISC_GUEST_KERNEL         G</span><br><span class="line">        PERF_RECORD_MISC_GUEST_USER           g</span><br><span class="line">        PERF_RECORD_MISC_MMAP_DATA*           M</span><br><span class="line">        PERF_RECORD_MISC_COMM_EXEC            E</span><br><span class="line">        PERF_RECORD_MISC_SWITCH_OUT           S</span><br><span class="line">        PERF_RECORD_MISC_SWITCH_OUT_PREEMPT   Sp</span><br><span class="line"></span><br><span class="line">        $ perf script -F +misc ...</span><br><span class="line">         sched-messaging  1414 K     28690.636582:       4590 cycles ...</span><br><span class="line">         sched-messaging  1407 U     28690.636600:     325620 cycles ...</span><br><span class="line">         sched-messaging  1414 K     28690.636608:      19473 cycles ...</span><br><span class="line">        misc field ___________/</span><br><span class="line"></span><br><span class="line">-k, --vmlinux=&lt;file&gt;</span><br><span class="line">    vmlinux pathname</span><br><span class="line"></span><br><span class="line">--kallsyms=&lt;file&gt;</span><br><span class="line">    kallsyms pathname</span><br><span class="line"></span><br><span class="line">--symfs=&lt;directory&gt;</span><br><span class="line">    Look for files with symbols relative to this directory.</span><br><span class="line"></span><br><span class="line">-G, --hide-call-graph</span><br><span class="line">    When printing symbols do not display call chain.</span><br><span class="line"></span><br><span class="line">--stop-bt</span><br><span class="line">    Stop display of callgraph at these symbols</span><br><span class="line"></span><br><span class="line">-C, --cpu</span><br><span class="line">    Only report samples for the list of CPUs provided. Multiple</span><br><span class="line">    CPUs can be provided as a comma-separated list with no space:</span><br><span class="line">    0,1. Ranges of CPUs are specified with -: 0-2. Default is to</span><br><span class="line">    report samples on all CPUs.</span><br><span class="line"></span><br><span class="line">-c, --comms=</span><br><span class="line">    Only display events for these comms. CSV that understands</span><br><span class="line">    file://filename entries.</span><br><span class="line"></span><br><span class="line">--pid=</span><br><span class="line">    Only show events for given process ID (comma separated list).</span><br><span class="line"></span><br><span class="line">--tid=</span><br><span class="line">    Only show events for given thread ID (comma separated list).</span><br><span class="line"></span><br><span class="line">-I, --show-info</span><br><span class="line">    Display extended information about the perf.data file. This</span><br><span class="line">    adds information which may be very large and thus may clutter</span><br><span class="line">    the display. It currently includes: cpu and numa topology of</span><br><span class="line">    the host system. It can only be used with the perf script</span><br><span class="line">    report mode.</span><br><span class="line"></span><br><span class="line">--show-kernel-path</span><br><span class="line">    Try to resolve the path of [kernel.kallsyms]</span><br><span class="line"></span><br><span class="line">--show-task-events Display task related events (e.g. FORK, COMM,</span><br><span class="line">EXIT).</span><br><span class="line"></span><br><span class="line">--show-mmap-events Display mmap related events (e.g. MMAP,</span><br><span class="line">MMAP2).</span><br><span class="line"></span><br><span class="line">--show-namespace-events Display namespace events i.e. events of</span><br><span class="line">type PERF_RECORD_NAMESPACES.</span><br><span class="line"></span><br><span class="line">--show-switch-events Display context switch events i.e. events of</span><br><span class="line">type PERF_RECORD_SWITCH or PERF_RECORD_SWITCH_CPU_WIDE.</span><br><span class="line"></span><br><span class="line">--show-lost-events Display lost events i.e. events of type</span><br><span class="line">PERF_RECORD_LOST.</span><br><span class="line"></span><br><span class="line">--show-round-events Display finished round events i.e. events of</span><br><span class="line">type PERF_RECORD_FINISHED_ROUND.</span><br><span class="line"></span><br><span class="line">--show-bpf-events Display bpf events i.e. events of type</span><br><span class="line">PERF_RECORD_KSYMBOL and PERF_RECORD_BPF_EVENT.</span><br><span class="line"></span><br><span class="line">--show-cgroup-events Display cgroup events i.e. events of type</span><br><span class="line">PERF_RECORD_CGROUP.</span><br><span class="line"></span><br><span class="line">--show-text-poke-events Display text poke events i.e. events of</span><br><span class="line">type PERF_RECORD_TEXT_POKE and PERF_RECORD_KSYMBOL.</span><br><span class="line"></span><br><span class="line">--demangle</span><br><span class="line">    Demangle symbol names to human readable form. It’s enabled by</span><br><span class="line">    default, disable with --no-demangle.</span><br><span class="line"></span><br><span class="line">--demangle-kernel</span><br><span class="line">    Demangle kernel symbol names to human readable form (for C++</span><br><span class="line">    kernels).</span><br><span class="line"></span><br><span class="line">--header Show perf.data header.</span><br><span class="line"></span><br><span class="line">--header-only Show only perf.data header.</span><br><span class="line"></span><br><span class="line">--itrace</span><br><span class="line">    Options for decoding instruction tracing data. The options</span><br><span class="line">    are:</span><br><span class="line"></span><br><span class="line">        i       synthesize instructions events</span><br><span class="line">        b       synthesize branches events (branch misses for Arm SPE)</span><br><span class="line">        c       synthesize branches events (calls only)</span><br><span class="line">        r       synthesize branches events (returns only)</span><br><span class="line">        x       synthesize transactions events</span><br><span class="line">        w       synthesize ptwrite events</span><br><span class="line">        p       synthesize power events (incl. PSB events for Intel PT)</span><br><span class="line">        o       synthesize other events recorded due to the use</span><br><span class="line">                of aux-output (refer to perf record)</span><br><span class="line">        e       synthesize error events</span><br><span class="line">        d       create a debug log</span><br><span class="line">        f       synthesize first level cache events</span><br><span class="line">        m       synthesize last level cache events</span><br><span class="line">        M       synthesize memory events</span><br><span class="line">        t       synthesize TLB events</span><br><span class="line">        a       synthesize remote access events</span><br><span class="line">        g       synthesize a call chain (use with i or x)</span><br><span class="line">        G       synthesize a call chain on existing event records</span><br><span class="line">        l       synthesize last branch entries (use with i or x)</span><br><span class="line">        L       synthesize last branch entries on existing event records</span><br><span class="line">        s       skip initial number of events</span><br><span class="line">        q       quicker (less detailed) decoding</span><br><span class="line">        Z       prefer to ignore timestamps (so-called &quot;timeless&quot; decoding)</span><br><span class="line"></span><br><span class="line">        The default is all events i.e. the same as --itrace=ibxwpe,</span><br><span class="line">        except for perf script where it is --itrace=ce</span><br><span class="line"></span><br><span class="line">        In addition, the period (default 100000, except for perf script where it is 1)</span><br><span class="line">        for instructions events can be specified in units of:</span><br><span class="line"></span><br><span class="line">        i       instructions</span><br><span class="line">        t       ticks</span><br><span class="line">        ms      milliseconds</span><br><span class="line">        us      microseconds</span><br><span class="line">        ns      nanoseconds (default)</span><br><span class="line"></span><br><span class="line">        Also the call chain size (default 16, max. 1024) for instructions or</span><br><span class="line">        transactions events can be specified.</span><br><span class="line"></span><br><span class="line">        Also the number of last branch entries (default 64, max. 1024) for</span><br><span class="line">        instructions or transactions events can be specified.</span><br><span class="line"></span><br><span class="line">        Similar to options g and l, size may also be specified for options G and L.</span><br><span class="line">        On x86, note that G and L work poorly when data has been recorded with</span><br><span class="line">        large PEBS. Refer linkperf:perf-intel-pt[1] man page for details.</span><br><span class="line"></span><br><span class="line">        It is also possible to skip events generated (instructions, branches, transactions,</span><br><span class="line">        ptwrite, power) at the beginning. This is useful to ignore initialization code.</span><br><span class="line"></span><br><span class="line">        --itrace=i0nss1000000</span><br><span class="line"></span><br><span class="line">        skips the first million instructions.</span><br><span class="line"></span><br><span class="line">        The &#x27;e&#x27; option may be followed by flags which affect what errors will or</span><br><span class="line">        will not be reported. Each flag must be preceded by either &#x27;+&#x27; or &#x27;-&#x27;.</span><br><span class="line">        The flags are:</span><br><span class="line">                o       overflow</span><br><span class="line">                l       trace data lost</span><br><span class="line"></span><br><span class="line">        If supported, the &#x27;d&#x27; option may be followed by flags which affect what</span><br><span class="line">        debug messages will or will not be logged. Each flag must be preceded</span><br><span class="line">        by either &#x27;+&#x27; or &#x27;-&#x27;. The flags are:</span><br><span class="line">                a       all perf events</span><br><span class="line"></span><br><span class="line">        If supported, the &#x27;q&#x27; option may be repeated to increase the effect.</span><br><span class="line"></span><br><span class="line">        To disable decoding entirely, use --no-itrace.</span><br><span class="line"></span><br><span class="line">--full-source-path</span><br><span class="line">    Show the full path for source files for srcline output.</span><br><span class="line"></span><br><span class="line">--max-stack</span><br><span class="line">    Set the stack depth limit when parsing the callchain,</span><br><span class="line">    anything beyond the specified depth will be ignored. This is</span><br><span class="line">    a trade-off between information loss and faster processing</span><br><span class="line">    especially for workloads that can have a very long callchain</span><br><span class="line">    stack. Note that when using the --itrace option the</span><br><span class="line">    synthesized callchain size will override this value if the</span><br><span class="line">    synthesized callchain size is bigger.</span><br><span class="line"></span><br><span class="line">        Default: 127</span><br><span class="line"></span><br><span class="line">--ns</span><br><span class="line">    Use 9 decimal places when displaying time (i.e. show the</span><br><span class="line">    nanoseconds)</span><br><span class="line"></span><br><span class="line">-f, --force</span><br><span class="line">    Don’t do ownership validation.</span><br><span class="line"></span><br><span class="line">--time</span><br><span class="line">    Only analyze samples within given time window:</span><br><span class="line">    &lt;start&gt;,&lt;stop&gt;. Times have the format seconds.nanoseconds. If</span><br><span class="line">    start is not given (i.e. time string is ,x.y) then analysis</span><br><span class="line">    starts at the beginning of the file. If stop time is not</span><br><span class="line">    given (i.e. time string is x.y,) then analysis goes to end of</span><br><span class="line">    file. Multiple ranges can be separated by spaces, which</span><br><span class="line">    requires the argument to be quoted e.g. --time</span><br><span class="line">    &quot;1234.567,1234.789 1235,&quot;</span><br><span class="line"></span><br><span class="line">        Also support time percent with multiple time ranges. Time string is</span><br><span class="line">        &#x27;a%/n,b%/m,...&#x27; or &#x27;a%-b%,c%-%d,...&#x27;.</span><br><span class="line"></span><br><span class="line">        For example:</span><br><span class="line">        Select the second 10% time slice:</span><br><span class="line">        perf script --time 10%/2</span><br><span class="line"></span><br><span class="line">        Select from 0% to 10% time slice:</span><br><span class="line">        perf script --time 0%-10%</span><br><span class="line"></span><br><span class="line">        Select the first and second 10% time slices:</span><br><span class="line">        perf script --time 10%/1,10%/2</span><br><span class="line"></span><br><span class="line">        Select from 0% to 10% and 30% to 40% slices:</span><br><span class="line">        perf script --time 0%-10%,30%-40%</span><br><span class="line"></span><br><span class="line">--max-blocks</span><br><span class="line">    Set the maximum number of program blocks to print with</span><br><span class="line">    brstackinsn for each sample.</span><br><span class="line"></span><br><span class="line">--reltime</span><br><span class="line">    Print time stamps relative to trace start.</span><br><span class="line"></span><br><span class="line">--deltatime</span><br><span class="line">    Print time stamps relative to previous event.</span><br><span class="line"></span><br><span class="line">--per-event-dump</span><br><span class="line">    Create per event files with a &quot;perf.data.EVENT.dump&quot; name</span><br><span class="line">    instead of printing to stdout, useful, for instance, for</span><br><span class="line">    generating flamegraphs.</span><br><span class="line"></span><br><span class="line">--inline</span><br><span class="line">    If a callgraph address belongs to an inlined function, the</span><br><span class="line">    inline stack will be printed. Each entry has function name</span><br><span class="line">    and file/line. Enabled by default, disable with --no-inline.</span><br><span class="line"></span><br><span class="line">--insn-trace</span><br><span class="line">    Show instruction stream for intel_pt traces. Combine with</span><br><span class="line">    --xed to show disassembly.</span><br><span class="line"></span><br><span class="line">--xed</span><br><span class="line">    Run xed disassembler on output. Requires installing the xed</span><br><span class="line">    disassembler.</span><br><span class="line"></span><br><span class="line">-S, --symbols=symbol[,symbol...]</span><br><span class="line">    Only consider the listed symbols. Symbols are typically a</span><br><span class="line">    name but they may also be hexadecimal address.</span><br><span class="line"></span><br><span class="line">        The hexadecimal address may be the start address of a symbol or</span><br><span class="line">        any other address to filter the trace records</span><br><span class="line"></span><br><span class="line">        For example, to select the symbol noploop or the address 0x4007a0:</span><br><span class="line">        perf script --symbols=noploop,0x4007a0</span><br><span class="line"></span><br><span class="line">        Support filtering trace records by symbol name, start address of</span><br><span class="line">        symbol, any hexadecimal address and address range.</span><br><span class="line"></span><br><span class="line">        The comparison order is:</span><br><span class="line"></span><br><span class="line">     1. symbol name comparison</span><br><span class="line"></span><br><span class="line">     2. symbol start address comparison.</span><br><span class="line"></span><br><span class="line">     3. any hexadecimal address comparison.</span><br><span class="line"></span><br><span class="line">     4. address range comparison (see --addr-range).</span><br><span class="line"></span><br><span class="line">--addr-range</span><br><span class="line">    Use with -S or --symbols to list traced records within</span><br><span class="line">    address range.</span><br><span class="line"></span><br><span class="line">        For example, to list the traced records within the address range</span><br><span class="line">        [0x4007a0, 0x0x4007a9]:</span><br><span class="line">        perf script -S 0x4007a0 --addr-range 10</span><br><span class="line"></span><br><span class="line">--dsos=</span><br><span class="line">    Only consider symbols in these DSOs.</span><br><span class="line"></span><br><span class="line">--call-trace</span><br><span class="line">    Show call stream for intel_pt traces. The CPUs are</span><br><span class="line">    interleaved, but can be filtered with -C.</span><br><span class="line"></span><br><span class="line">--call-ret-trace</span><br><span class="line">    Show call and return stream for intel_pt traces.</span><br><span class="line"></span><br><span class="line">--graph-function</span><br><span class="line">    For itrace only show specified functions and their callees</span><br><span class="line">    for itrace. Multiple functions can be separated by comma.</span><br><span class="line"></span><br><span class="line">--switch-on EVENT_NAME</span><br><span class="line">    Only consider events after this event is found.</span><br><span class="line"></span><br><span class="line">--switch-off EVENT_NAME</span><br><span class="line">    Stop considering events after this event is found.</span><br><span class="line"></span><br><span class="line">--show-on-off-events</span><br><span class="line">    Show the --switch-on/off events too.</span><br><span class="line"></span><br><span class="line">--stitch-lbr</span><br><span class="line">    Show callgraph with stitched LBRs, which may have more</span><br><span class="line">    complete callgraph. The perf.data file must have been</span><br><span class="line">    obtained using perf record --call-graph lbr. Disabled by</span><br><span class="line">    default. In common cases with call stack overflows, it can</span><br><span class="line">    recreate better call stacks than the default lbr call stack</span><br><span class="line">    output. But this approach is not full proof. There can be</span><br><span class="line">    cases where it creates incorrect call stacks from incorrect</span><br><span class="line">    matches. The known limitations include exception handing such</span><br><span class="line">    as setjmp/longjmp will have calls/returns not match.</span><br></pre></td></tr></table></figure><h2 id="SEE-ALSO-top"><a href="#SEE-ALSO-top" class="headerlink" title="SEE ALSO     top"></a>SEE ALSO     <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perf-record(1), perf-script-perl(1), perf-script-python(1),</span><br><span class="line">perf-intel-pt(1), perf-dlfilter(1)</span><br></pre></td></tr></table></figure><h2 id="COLOPHON-top"><a href="#COLOPHON-top" class="headerlink" title="COLOPHON     top"></a>COLOPHON     <a href="https://www.man7.org/linux/man-pages/man1/perf-script.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">       This page is part of the perf (Performance analysis tools for</span><br><span class="line">       Linux (in Linux source tree)) project.  Information about the</span><br><span class="line">       project can be found at</span><br><span class="line">       ⟨https://perf.wiki.kernel.org/index.php/Main_Page⟩.  If you have a</span><br><span class="line">       bug report for this manual page, send it to</span><br><span class="line">       linux-kernel@vger.kernel.org.  This page was obtained from the</span><br><span class="line">       project&#x27;s upstream Git repository</span><br><span class="line">       ⟨http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git⟩</span><br><span class="line">       on 2021-08-27.  (At that time, the date of the most recent commit</span><br><span class="line">       that was found in the repository was 2021-08-26.)  If you</span><br><span class="line">       discover any rendering problems in this HTML version of the page,</span><br><span class="line">       or you believe there is a better or more up-to-date source for</span><br><span class="line">       the page, or you have corrections or improvements to the</span><br><span class="line">       information in this COLOPHON (which is not part of the original</span><br><span class="line">       manual page), send a mail to man-pages@man7.org</span><br><span class="line"></span><br><span class="line">perf                           2021-07-01                 PERF-SCRIPT(1)</span><br></pre></td></tr></table></figure><hr><p>Pages that refer to this page: <a href="https://www.man7.org/linux/man-pages/man1/perf.1.html">perf(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-dlfilter.1.html">perf-dlfilter(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-intel-pt.1.html">perf-intel-pt(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-script-perl.1.html">perf-script-perl(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-script-python.1.html">perf-script-python(1)</a>, <a href="https://www.man7.org/linux/man-pages/man1/perf-trace.1.html">perf-trace(1)</a></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PERF EVENT 内核篇</title>
      <link href="/2022/10/13/01%20OS/Linux/Perf/perf_kernel/"/>
      <url>/2022/10/13/01%20OS/Linux/Perf/perf_kernel/</url>
      
        <content type="html"><![CDATA[<h1 id="PERF-EVENT-内核篇"><a href="#PERF-EVENT-内核篇" class="headerlink" title="PERF EVENT 内核篇"></a>PERF EVENT 内核篇</h1><p>简介<br>本文将以 X86 硬件事件为入手点，介绍 linux kernel 中 perf_event 子系统的部分实现，通过本文读者将初步了解到 perf_event 资源是如何在内核中呈现，运行，会依次如何对硬件进行操作，如何产生分时复用，以及在软件层面如何产生影响</p><p>注：阅读本文前需要对 perf_event api 和 perf 硬件有所了解</p><h2 id="内核数据结构实现"><a href="#内核数据结构实现" class="headerlink" title="内核数据结构实现"></a>内核数据结构实现</h2><p>perf_event</p><p>代表一种事件资源，用户态调用 perf_open_event 即会创建一个与之对应的 perf_event 对象，相应的一些重要数据都会以这个数据结构为维度存放 包含 pmu ctx enabled_time running_time count 等信息</p><p>pmu</p><p>代表一种抽象的软硬件操作单元，它可以是 cpu，software，在 cpu 的实现下，它负责对硬件 PMC&#x2F;PERFEVTSEL&#x2F;FIXED_CTR&#x2F;FIXED_CTR_CTRL 进行操作。每一种厂商在内核实现的 pmu 是不同的。在内核中 PMCx 与 PERFEVTSELx 属于 cpu pmu，而 RDT 属于 intel_cqm pmu</p><p>pmu 包含一系列方法（以 perf_event 为输入参数），用于 初始化&#x2F;关闭&#x2F;读取 硬件pmu设备，cpu 就是一个 pmu，这一个对象包含了所有的 cpu 硬件事件。它是一个类对象（可以认为是单例实现），全局共享，由 attr.type 来定位，开机时内核会注册一系列（arch&#x2F;x86&#x2F;kernel&#x2F;cpu&#x2F;perf_event.c）pmu 放置 pmu_idr 中</p><p>它会实现一系列对硬件操作和状态管理函数，如enable，disable，add，del。同时分时复用的一些分配通用 pmc 的逻辑也在里面</p><p>perf_event_context</p><p>代表 perf_event 和 pmu 的一种抽象，它会包含 perf_event_list 和 pmu。是 perf_event 子系统操作的最小单元。它会被包含在 task 或 cpu 结构中，这样一来与其他子系统如 sched 产生协作</p><p>perf_event_context 是 perf_event 的一个 container, 以列表的方式维护多个perf_event对象，ctx 包含 perf_event 后以 task 和 cpu 两个维度维护，per-cpu 对象中会包含 context（当指定 per-cpu event的时候，会alloc context 并赋值到p er-cpu 数组中），同样 task 的结构对象中也会包含 context，这两者用sched_switch 时会判断 context 中的内容作出决定</p><h2 id="事件作用域"><a href="#事件作用域" class="headerlink" title="事件作用域"></a>事件作用域</h2><p>perf_event 系统调用中提供两种维度的作用域</p><ol><li>task</li><li>cpu</li></ol><p>在内核中将 event 分为 per-task 和 per-cpu, 还有一种 per-cgroup，它实际上是 per-task 类型的</p><p>如果是 per-task 它会将 perf_context 分配到 task struct 中</p><p>如果是 per-cpu 它会将 perf_context 分配到一个全局 per_cpu 变量中</p><h2 id="内核系统调用实现"><a href="#内核系统调用实现" class="headerlink" title="内核系统调用实现"></a>内核系统调用实现</h2><p>系统开机时会通过 cpuid 汇编指令获取 pmu 硬件信息，初始化和注册 pmu 对象<br>arch&#x2F;x86&#x2F;kernel&#x2F;cpu&#x2F;perf_event.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf_pmu_register(&amp;pmu, &quot;cpu&quot;, PERF_TYPE_RAW);</span><br></pre></td></tr></table></figure><p>会将所有扫描到的 pmu 对象放到字典对象 pmus 中，以便后续用户调用 perf_event_open 中定位 pmu</p><p>perf_event_open 实现源码 (kernel&#x2F;events&#x2F;core.c)</p><ol><li>为调用者创建句柄资源</li><li>根据用户参数 attr，定位 pmu 对象，通过 pmu 初始化event</li><li>根据作用域创建相应的 perf_context</li><li>将回调函数和相关的数据资源绑定到句柄中</li></ol><h2 id="内核操作硬件-——-事件激活"><a href="#内核操作硬件-——-事件激活" class="headerlink" title="内核操作硬件 —— 事件激活"></a>内核操作硬件 —— 事件激活</h2><p>内核中定义了两个重要的 pmu 操作函数</p><ul><li>perf_pmu_enable</li><li>perf_pmu_disable</li></ul><p>我们可以理解这两个函数是用于事物提交，也就是最终生效的函数</p><p>我们先撇开per-task per-cpu， 只说说当用户在一个cpu上定义了一个event时的逻辑</p><p>内核先会以 event_context 维度处理一些逻辑，暂放不表，直接进入 event_sched_in 函数，这个函数会调用 pmu-&gt;add （pmu 里面包含一个 x86_pmu 里面有 per-cpu 的全局对象了，它包含这个cpu的所有event。下面我们就称之为pmu）， 它做了以下事情</p><ol><li>将 perf_event 对象添加到生效列表</li><li>同时为它分配一个具体的 PMC 硬件 （敲黑板！！）</li></ol><p>注：还记得在 PERF EVENT 硬件篇 中描述的那几个MSR&#x2F;PMC么？步骤2中就会对那几个硬件的状态进行判断，然后分配一个硬件给event，并记录在event-&gt;hw结构中</p><p>此时硬件层面并没有任何事件生效的动作，只要内核真正调用了 perf_pmu_enable 后才会根据 pmu 对象中的 event_list 遍历操作对应 pmc 设备</p><h2 id="内核操作硬件-——-事件计数读取"><a href="#内核操作硬件-——-事件计数读取" class="headerlink" title="内核操作硬件 —— 事件计数读取"></a>内核操作硬件 —— 事件计数读取</h2><p>同样类似事件激活的过程，pmu 从 event_list 中遍历出 pmc 设备的地址，通过 rdpmc 指令读取出计数，然后记录在 event-&gt;count 中，同时也会记录运行的时间戳</p><h2 id="性能负载"><a href="#性能负载" class="headerlink" title="性能负载"></a>性能负载</h2><p>除了功能以外，用户最关心的就是性能了，同样 perf_event 的性能开销是尤其重要的一个点，好在该子系统代码结构良好，从源代码中就可以分析出一定的性能开销</p><p>注：本系列只针对 cpu 硬件事件</p><p>由于 PMC 是硬件实现的，它本身的硬件开销我们只能通过黑盒测试进行判断，但好在硬件强大，对单一 event 的测试过程中，没有肉眼可发现的性能开销，下面我们内核软件层面的开销进行分析。主要有以下几个点会引发性能开销</p><ol><li>per-task 进程切换导致的硬件状态读取和修改</li><li>时钟中断导致的硬件读取和修改<br>其实，以上两者都是对硬件操作产生的开销，不同在于产生的入口不同，比如读取 perf_event 的数值也会产生对硬件操作，但是这个毕竟不是频繁操作，我们就不讨论了。</li></ol><p>per-task 故名思义，它是以 task 为维度定义的 event， 如 进程a 要开启事件a的计数，进程b 要开启 事件a 和 事件c，当 进程a 切换到 进程b 时要做如下操作</p><ol><li>读取进程a 的事件a 状态，并计入到对应的 event 对象中</li><li>关闭进程a 的所有事件的硬件激活状态</li><li>激活进程b 的事件a 和 事件c<br>以上操作要操作若干次硬件，然后硬件是同步操作，会引发cpu stall。而且从代码上来看，会比理论上操作硬件次数多的多。通过构造一个频繁进行上下文切换的测试，最多可造成50%性能损失</li></ol><p>所以说，per-task 在依照进程状态的情况下，可能对性能造成不同程度的影响，但从直观的角度来说，是不建议使用的。但是有一个例外，就是在进程fork大量的子进程前就对该进程进行事件监控，perf_event 会感知到子进程为父进程的同类进程，而不操作硬件，大大降低了性能开销</p><p>之前也说过 per-cgroup 是通过 per-task 来实现的，那么 per-cgroup 的性能如何？per-cpu 的性能又是怎样的呢？</p><p>其实，上面针对 per-task 的特例已经回答了！</p><p>我们再来说说时钟中断导致的硬件读取和修改。为何这里会引入一个时钟中断？</p><p>我们来回忆一下 PMC 的硬件个数，每个cpu 是4个通用PMC（关虚拟化则是8个）3个专用 pmc，这三个分别记录其固定事件</p><p>所以，一个事件至多在一个cpu上能同时激活5个。如果，我们定义了6个，那么内核就会机智地帮我们处理分时复用（multiplexing）的问题。也就是说，如果是10个事件，每个事件会运行50%的事件，而这个切换过程由时钟中断来触发，一毫秒触发一次。这个次数跟 per-task 的进程切换相比会低上很多。这个开销大约在每CPU 2%左右</p><p>相关资料<br><a href="http://openlab.cern/sites/openlab.web.cern.ch/files/technical_documents/TheOverheadOfProfilingUsingPMUhardwareCounters.pdf">http://openlab.cern/sites/openlab.web.cern.ch/files/technical_documents/TheOverheadOfProfilingUsingPMUhardwareCounters.pdf</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux Shell中捕获CTRL+C</title>
      <link href="/2022/10/13/01%20OS/Linux/Shell/ctrlc/"/>
      <url>/2022/10/13/01%20OS/Linux/Shell/ctrlc/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Shell中捕获CTRL-C"><a href="#Linux-Shell中捕获CTRL-C" class="headerlink" title="Linux Shell中捕获CTRL+C"></a>Linux Shell中捕获CTRL+C</h1><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">trap &#x27;onCtrlC&#x27; INT</span><br><span class="line">function onCtrlC () &#123;</span><br><span class="line">    echo &#x27;Ctrl+C is captured&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while true; do</span><br><span class="line">    echo &#x27;I am working!&#x27;</span><br><span class="line">     sleep 1</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>执行上述脚本，按下Ctrl+C按键将会触发onCtrlC函数</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Df(1)</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/df/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/df/</url>
      
        <content type="html"><![CDATA[<h1 id="df-1-—-Linux-manual-page"><a href="#df-1-—-Linux-manual-page" class="headerlink" title="df(1) — Linux manual page"></a>df(1) — Linux manual page</h1><table><thead><tr><th><a href="https://man7.org/linux/man-pages/man1/df.1.html#NAME">NAME</a> | <a href="https://man7.org/linux/man-pages/man1/df.1.html#SYNOPSIS">SYNOPSIS</a> | <a href="https://man7.org/linux/man-pages/man1/df.1.html#DESCRIPTION">DESCRIPTION</a> | <a href="https://man7.org/linux/man-pages/man1/df.1.html#OPTIONS">OPTIONS</a> | <a href="https://man7.org/linux/man-pages/man1/df.1.html#AUTHOR">AUTHOR</a> | <a href="https://man7.org/linux/man-pages/man1/df.1.html#REPORTING_BUGS">REPORTING BUGS</a> | <a href="https://man7.org/linux/man-pages/man1/df.1.html#COPYRIGHT">COPYRIGHT</a> | <a href="https://man7.org/linux/man-pages/man1/df.1.html#SEE_ALSO">SEE ALSO</a> | <a href="https://man7.org/linux/man-pages/man1/df.1.html#COLOPHON">COLOPHON</a></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DF(1)                         User Commands                        DF(1)</span><br></pre></td></tr></table></figure><h2 id="NAME-top"><a href="#NAME-top" class="headerlink" title="NAME     top"></a>NAME     <a href="https://man7.org/linux/man-pages/man1/df.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df - report file system disk space usage</span><br></pre></td></tr></table></figure><h2 id="SYNOPSIS-top"><a href="#SYNOPSIS-top" class="headerlink" title="SYNOPSIS     top"></a>SYNOPSIS     <a href="https://man7.org/linux/man-pages/man1/df.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><h2 id="DESCRIPTION-top"><a href="#DESCRIPTION-top" class="headerlink" title="DESCRIPTION     top"></a>DESCRIPTION     <a href="https://man7.org/linux/man-pages/man1/df.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">This manual page documents the GNU version of df.  df displays</span><br><span class="line">the amount of disk space available on the file system containing</span><br><span class="line">each file name argument.  If no file name is given, the space</span><br><span class="line">available on all currently mounted file systems is shown.  Disk</span><br><span class="line">space is shown in 1K blocks by default, unless the environment</span><br><span class="line">variable POSIXLY_CORRECT is set, in which case 512-byte blocks</span><br><span class="line">are used.</span><br><span class="line"></span><br><span class="line">If an argument is the absolute file name of a disk device node</span><br><span class="line">containing a mounted file system, df shows the space available on</span><br><span class="line">that file system rather than on the file system containing the</span><br><span class="line">device node.  This version of df cannot show the space available</span><br><span class="line">on unmounted file systems, because on most kinds of systems doing</span><br><span class="line">so requires very nonportable intimate knowledge of file system</span><br><span class="line">structures.</span><br></pre></td></tr></table></figure><h2 id="OPTIONS-top"><a href="#OPTIONS-top" class="headerlink" title="OPTIONS     top"></a>OPTIONS     <a href="https://man7.org/linux/man-pages/man1/df.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Show information about the file system on which each FILE</span><br><span class="line">resides, or all file systems by default.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory for short</span><br><span class="line">options too.</span><br><span class="line"></span><br><span class="line">-a, --all</span><br><span class="line">       include pseudo, duplicate, inaccessible file systems</span><br><span class="line"></span><br><span class="line">-B, --block-size=SIZE</span><br><span class="line">       scale sizes by SIZE before printing them; e.g., &#x27;-BM&#x27;</span><br><span class="line">       prints sizes in units of 1,048,576 bytes; see SIZE format</span><br><span class="line">       below</span><br><span class="line"></span><br><span class="line">-h, --human-readable</span><br><span class="line">       print sizes in powers of 1024 (e.g., 1023M)</span><br><span class="line"></span><br><span class="line">-H, --si</span><br><span class="line">       print sizes in powers of 1000 (e.g., 1.1G)</span><br><span class="line"></span><br><span class="line">-i, --inodes</span><br><span class="line">       list inode information instead of block usage</span><br><span class="line"></span><br><span class="line">-k     like --block-size=1K</span><br><span class="line"></span><br><span class="line">-l, --local</span><br><span class="line">       limit listing to local file systems</span><br><span class="line"></span><br><span class="line">--no-sync</span><br><span class="line">       do not invoke sync before getting usage info (default)</span><br><span class="line"></span><br><span class="line">--output[=FIELD_LIST]</span><br><span class="line">       use the output format defined by FIELD_LIST, or print all</span><br><span class="line">       fields if FIELD_LIST is omitted.</span><br><span class="line"></span><br><span class="line">-P, --portability</span><br><span class="line">       use the POSIX output format</span><br><span class="line"></span><br><span class="line">--sync invoke sync before getting usage info</span><br><span class="line"></span><br><span class="line">--total</span><br><span class="line">       elide all entries insignificant to available space, and</span><br><span class="line">       produce a grand total</span><br><span class="line"></span><br><span class="line">-t, --type=TYPE</span><br><span class="line">       limit listing to file systems of type TYPE</span><br><span class="line"></span><br><span class="line">-T, --print-type</span><br><span class="line">       print file system type</span><br><span class="line"></span><br><span class="line">-x, --exclude-type=TYPE</span><br><span class="line">       limit listing to file systems not of type TYPE</span><br><span class="line"></span><br><span class="line">-v     (ignored)</span><br><span class="line"></span><br><span class="line">--help display this help and exit</span><br><span class="line"></span><br><span class="line">--version</span><br><span class="line">       output version information and exit</span><br><span class="line"></span><br><span class="line">Display values are in units of the first available SIZE from</span><br><span class="line">--block-size, and the DF_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE</span><br><span class="line">environment variables.  Otherwise, units default to 1024 bytes</span><br><span class="line">(or 512 if POSIXLY_CORRECT is set).</span><br><span class="line"></span><br><span class="line">The SIZE argument is an integer and optional unit (example: 10K</span><br><span class="line">is 10*1024).  Units are K,M,G,T,P,E,Z,Y (powers of 1024) or</span><br><span class="line">KB,MB,... (powers of 1000).  Binary prefixes can be used, too:</span><br><span class="line">KiB=K, MiB=M, and so on.</span><br><span class="line"></span><br><span class="line">FIELD_LIST is a comma-separated list of columns to be included.</span><br><span class="line">Valid field names are: &#x27;source&#x27;, &#x27;fstype&#x27;, &#x27;itotal&#x27;, &#x27;iused&#x27;,</span><br><span class="line">&#x27;iavail&#x27;, &#x27;ipcent&#x27;, &#x27;size&#x27;, &#x27;used&#x27;, &#x27;avail&#x27;, &#x27;pcent&#x27;, &#x27;file&#x27; and</span><br><span class="line">&#x27;target&#x27; (see info page).</span><br></pre></td></tr></table></figure><h2 id="AUTHOR-top"><a href="#AUTHOR-top" class="headerlink" title="AUTHOR     top"></a>AUTHOR     <a href="https://man7.org/linux/man-pages/man1/df.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Written by Torbjorn Granlund, David MacKenzie, and Paul Eggert.</span><br></pre></td></tr></table></figure><h2 id="REPORTING-BUGS-top"><a href="#REPORTING-BUGS-top" class="headerlink" title="REPORTING BUGS     top"></a>REPORTING BUGS     <a href="https://man7.org/linux/man-pages/man1/df.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GNU coreutils online help:</span><br><span class="line">&lt;https://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">Report any translation bugs to</span><br><span class="line">&lt;https://translationproject.org/team/&gt;</span><br></pre></td></tr></table></figure><h2 id="COPYRIGHT-top"><a href="#COPYRIGHT-top" class="headerlink" title="COPYRIGHT     top"></a>COPYRIGHT     <a href="https://man7.org/linux/man-pages/man1/df.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyright © 2020 Free Software Foundation, Inc.  License GPLv3+:</span><br><span class="line">GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;.</span><br><span class="line">This is free software: you are free to change and redistribute</span><br><span class="line">it.  There is NO WARRANTY, to the extent permitted by law.</span><br></pre></td></tr></table></figure><h2 id="SEE-ALSO-top"><a href="#SEE-ALSO-top" class="headerlink" title="SEE ALSO     top"></a>SEE ALSO     <a href="https://man7.org/linux/man-pages/man1/df.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Full documentation &lt;https://www.gnu.org/software/coreutils/df&gt;</span><br><span class="line">or available locally via: info &#x27;(coreutils) df invocation&#x27;</span><br></pre></td></tr></table></figure><h2 id="COLOPHON-top"><a href="#COLOPHON-top" class="headerlink" title="COLOPHON     top"></a>COLOPHON     <a href="https://man7.org/linux/man-pages/man1/df.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">This page is part of the coreutils (basic file, shell and text</span><br><span class="line">manipulation utilities) project.  Information about the project</span><br><span class="line">can be found at ⟨http://www.gnu.org/software/coreutils/⟩.  If you</span><br><span class="line">have a bug report for this manual page, see</span><br><span class="line">⟨http://www.gnu.org/software/coreutils/⟩.  This page was obtained</span><br><span class="line">from the tarball coreutils-8.32.tar.xz fetched from</span><br><span class="line">⟨http://ftp.gnu.org/gnu/coreutils/⟩ on 2021-08-27.  If you</span><br><span class="line">discover any rendering problems in this HTML version of the page,</span><br><span class="line">or you believe there is a better or more up-to-date source for</span><br><span class="line">the page, or you have corrections or improvements to the</span><br><span class="line">information in this COLOPHON (which is not part of the original</span><br><span class="line">manual page), send a mail to man-pages@man7.org</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Du(1)</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/du/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/du/</url>
      
        <content type="html"><![CDATA[<h1 id="du-1-—-Linux-manual-page"><a href="#du-1-—-Linux-manual-page" class="headerlink" title="du(1) — Linux manual page"></a>du(1) — Linux manual page</h1><table><thead><tr><th><a href="https://man7.org/linux/man-pages/man1/du.1.html#NAME">NAME</a> | <a href="https://man7.org/linux/man-pages/man1/du.1.html#SYNOPSIS">SYNOPSIS</a> | <a href="https://man7.org/linux/man-pages/man1/du.1.html#DESCRIPTION">DESCRIPTION</a> | <a href="https://man7.org/linux/man-pages/man1/du.1.html#PATTERNS">PATTERNS</a> | <a href="https://man7.org/linux/man-pages/man1/du.1.html#AUTHOR">AUTHOR</a> | <a href="https://man7.org/linux/man-pages/man1/du.1.html#REPORTING_BUGS">REPORTING BUGS</a> | <a href="https://man7.org/linux/man-pages/man1/du.1.html#COPYRIGHT">COPYRIGHT</a> | <a href="https://man7.org/linux/man-pages/man1/du.1.html#SEE_ALSO">SEE ALSO</a> | <a href="https://man7.org/linux/man-pages/man1/du.1.html#COLOPHON">COLOPHON</a></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DU(1)                         User Commands                        DU(1)</span><br></pre></td></tr></table></figure><h2 id="NAME-top"><a href="#NAME-top" class="headerlink" title="NAME     top"></a>NAME     <a href="https://man7.org/linux/man-pages/man1/du.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du - estimate file space usage</span><br></pre></td></tr></table></figure><h2 id="SYNOPSIS-top"><a href="#SYNOPSIS-top" class="headerlink" title="SYNOPSIS     top"></a>SYNOPSIS     <a href="https://man7.org/linux/man-pages/man1/du.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">du [OPTION]... [FILE]...</span><br><span class="line">du [OPTION]... --files0-from=F</span><br></pre></td></tr></table></figure><h2 id="DESCRIPTION-top"><a href="#DESCRIPTION-top" class="headerlink" title="DESCRIPTION     top"></a>DESCRIPTION     <a href="https://man7.org/linux/man-pages/man1/du.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">Summarize disk usage of the set of FILEs, recursively for</span><br><span class="line">directories.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory for short</span><br><span class="line">options too.</span><br><span class="line"></span><br><span class="line">-0, --null</span><br><span class="line">       end each output line with NUL, not newline</span><br><span class="line"></span><br><span class="line">-a, --all</span><br><span class="line">       write counts for all files, not just directories</span><br><span class="line"></span><br><span class="line">--apparent-size</span><br><span class="line">       print apparent sizes, rather than disk usage; although the</span><br><span class="line">       apparent size is usually smaller, it may be larger due to</span><br><span class="line">       holes in (&#x27;sparse&#x27;) files, internal fragmentation,</span><br><span class="line">       indirect blocks, and the like</span><br><span class="line"></span><br><span class="line">-B, --block-size=SIZE</span><br><span class="line">       scale sizes by SIZE before printing them; e.g., &#x27;-BM&#x27;</span><br><span class="line">       prints sizes in units of 1,048,576 bytes; see SIZE format</span><br><span class="line">       below</span><br><span class="line"></span><br><span class="line">-b, --bytes</span><br><span class="line">       equivalent to &#x27;--apparent-size --block-size=1&#x27;</span><br><span class="line"></span><br><span class="line">-c, --total</span><br><span class="line">       produce a grand total</span><br><span class="line"></span><br><span class="line">-D, --dereference-args</span><br><span class="line">       dereference only symlinks that are listed on the command</span><br><span class="line">       line</span><br><span class="line"></span><br><span class="line">-d, --max-depth=N</span><br><span class="line">       print the total for a directory (or file, with --all) only</span><br><span class="line">       if it is N or fewer levels below the command line</span><br><span class="line">       argument;  --max-depth=0 is the same as --summarize</span><br><span class="line"></span><br><span class="line">--files0-from=F</span><br><span class="line">       summarize disk usage of the NUL-terminated file names</span><br><span class="line">       specified in file F; if F is -, then read names from</span><br><span class="line">       standard input</span><br><span class="line"></span><br><span class="line">-H     equivalent to --dereference-args (-D)</span><br><span class="line"></span><br><span class="line">-h, --human-readable</span><br><span class="line">       print sizes in human readable format (e.g., 1K 234M 2G)</span><br><span class="line"></span><br><span class="line">--inodes</span><br><span class="line">       list inode usage information instead of block usage</span><br><span class="line"></span><br><span class="line">-k     like --block-size=1K</span><br><span class="line"></span><br><span class="line">-L, --dereference</span><br><span class="line">       dereference all symbolic links</span><br><span class="line"></span><br><span class="line">-l, --count-links</span><br><span class="line">       count sizes many times if hard linked</span><br><span class="line"></span><br><span class="line">-m     like --block-size=1M</span><br><span class="line"></span><br><span class="line">-P, --no-dereference</span><br><span class="line">       don&#x27;t follow any symbolic links (this is the default)</span><br><span class="line"></span><br><span class="line">-S, --separate-dirs</span><br><span class="line">       for directories do not include size of subdirectories</span><br><span class="line"></span><br><span class="line">--si   like -h, but use powers of 1000 not 1024</span><br><span class="line"></span><br><span class="line">-s, --summarize</span><br><span class="line">       display only a total for each argument</span><br><span class="line"></span><br><span class="line">-t, --threshold=SIZE</span><br><span class="line">       exclude entries smaller than SIZE if positive, or entries</span><br><span class="line">       greater than SIZE if negative</span><br><span class="line"></span><br><span class="line">--time show time of the last modification of any file in the</span><br><span class="line">       directory, or any of its subdirectories</span><br><span class="line"></span><br><span class="line">--time=WORD</span><br><span class="line">       show time as WORD instead of modification time: atime,</span><br><span class="line">       access, use, ctime or status</span><br><span class="line"></span><br><span class="line">--time-style=STYLE</span><br><span class="line">       show times using STYLE, which can be: full-iso, long-iso,</span><br><span class="line">       iso, or +FORMAT; FORMAT is interpreted like in &#x27;date&#x27;</span><br><span class="line"></span><br><span class="line">-X, --exclude-from=FILE</span><br><span class="line">       exclude files that match any pattern in FILE</span><br><span class="line"></span><br><span class="line">--exclude=PATTERN</span><br><span class="line">       exclude files that match PATTERN</span><br><span class="line"></span><br><span class="line">-x, --one-file-system</span><br><span class="line">       skip directories on different file systems</span><br><span class="line"></span><br><span class="line">--help display this help and exit</span><br><span class="line"></span><br><span class="line">--version</span><br><span class="line">       output version information and exit</span><br><span class="line"></span><br><span class="line">Display values are in units of the first available SIZE from</span><br><span class="line">--block-size, and the DU_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE</span><br><span class="line">environment variables.  Otherwise, units default to 1024 bytes</span><br><span class="line">(or 512 if POSIXLY_CORRECT is set).</span><br><span class="line"></span><br><span class="line">The SIZE argument is an integer and optional unit (example: 10K</span><br><span class="line">is 10*1024).  Units are K,M,G,T,P,E,Z,Y (powers of 1024) or</span><br><span class="line">KB,MB,... (powers of 1000).  Binary prefixes can be used, too:</span><br><span class="line">KiB=K, MiB=M, and so on.</span><br></pre></td></tr></table></figure><h2 id="PATTERNS-top"><a href="#PATTERNS-top" class="headerlink" title="PATTERNS     top"></a>PATTERNS     <a href="https://man7.org/linux/man-pages/man1/du.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PATTERN is a shell pattern (not a regular expression).  The</span><br><span class="line">pattern ? matches any one character, whereas * matches any string</span><br><span class="line">(composed of zero, one or multiple characters).  For example, *.o</span><br><span class="line">will match any files whose names end in .o.  Therefore, the</span><br><span class="line">command</span><br><span class="line"></span><br><span class="line">       du --exclude=&#x27;*.o&#x27;</span><br><span class="line"></span><br><span class="line">will skip all files and subdirectories ending in .o (including</span><br><span class="line">the file .o itself).</span><br></pre></td></tr></table></figure><h2 id="AUTHOR-top"><a href="#AUTHOR-top" class="headerlink" title="AUTHOR     top"></a>AUTHOR     <a href="https://man7.org/linux/man-pages/man1/du.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Written by Torbjorn Granlund, David MacKenzie, Paul Eggert, and</span><br><span class="line">Jim Meyering.</span><br></pre></td></tr></table></figure><h2 id="REPORTING-BUGS-top"><a href="#REPORTING-BUGS-top" class="headerlink" title="REPORTING BUGS     top"></a>REPORTING BUGS     <a href="https://man7.org/linux/man-pages/man1/du.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GNU coreutils online help:</span><br><span class="line">&lt;https://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">Report any translation bugs to</span><br><span class="line">&lt;https://translationproject.org/team/&gt;</span><br></pre></td></tr></table></figure><h2 id="COPYRIGHT-top"><a href="#COPYRIGHT-top" class="headerlink" title="COPYRIGHT     top"></a>COPYRIGHT     <a href="https://man7.org/linux/man-pages/man1/du.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyright © 2020 Free Software Foundation, Inc.  License GPLv3+:</span><br><span class="line">GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;.</span><br><span class="line">This is free software: you are free to change and redistribute</span><br><span class="line">it.  There is NO WARRANTY, to the extent permitted by law.</span><br></pre></td></tr></table></figure><h2 id="SEE-ALSO-top"><a href="#SEE-ALSO-top" class="headerlink" title="SEE ALSO     top"></a>SEE ALSO     <a href="https://man7.org/linux/man-pages/man1/du.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Full documentation &lt;https://www.gnu.org/software/coreutils/du&gt;</span><br><span class="line">or available locally via: info &#x27;(coreutils) du invocation&#x27;</span><br></pre></td></tr></table></figure><h2 id="COLOPHON-top"><a href="#COLOPHON-top" class="headerlink" title="COLOPHON     top"></a>COLOPHON     <a href="https://man7.org/linux/man-pages/man1/du.1.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">This page is part of the coreutils (basic file, shell and text</span><br><span class="line">manipulation utilities) project.  Information about the project</span><br><span class="line">can be found at ⟨http://www.gnu.org/software/coreutils/⟩.  If you</span><br><span class="line">have a bug report for this manual page, see</span><br><span class="line">⟨http://www.gnu.org/software/coreutils/⟩.  This page was obtained</span><br><span class="line">from the tarball coreutils-8.32.tar.xz fetched from</span><br><span class="line">⟨http://ftp.gnu.org/gnu/coreutils/⟩ on 2021-08-27.  If you</span><br><span class="line">discover any rendering problems in this HTML version of the page,</span><br><span class="line">or you believe there is a better or more up-to-date source for</span><br><span class="line">the page, or you have corrections or improvements to the</span><br><span class="line">information in this COLOPHON (which is not part of the original</span><br><span class="line">manual page), send a mail to man-pages@man7.org</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ftrace</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ftrace/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ftrace/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-ftrace框架介绍及运用"><a href="#Linux-ftrace框架介绍及运用" class="headerlink" title="Linux ftrace框架介绍及运用"></a><a href="https://www.cnblogs.com/arnoldlu/p/7211249.html">Linux ftrace框架介绍及运用</a></h2><p>目录：</p><p><a href="https://www.cnblogs.com/arnoldlu/p/7211249.html#ftrace_background">1. ftrace背景</a></p><p><a href="https://www.cnblogs.com/arnoldlu/p/7211249.html#ftrace_framework">2. 框架介绍</a></p><p><a href="https://www.cnblogs.com/arnoldlu/p/7211249.html#ftrace_code_analyze">3. 主要代码分析</a></p><p><a href="https://www.cnblogs.com/arnoldlu/p/7211249.html#ftrace_setting">4. ftrace的配置和使用</a></p><p><a href="https://www.cnblogs.com/arnoldlu/p/7211249.html#ftrace_tools">5. ftrace相关工具</a></p><p>在日常工作中，经常会需要对内核进行Debug、或者进行优化工作。一些简单的问题，可以通过dmesg&#x2F;printk查看，优化借助一些工具进行。</p><p>但是当问题逻辑复杂，优化面宽泛的时候，往往无从下手。</p><p>需要从上到下、模块到模块之间分析，这时候就不得不借助于Linux提供的静态(Trace Event)动态(各种Tracer)进行分析。</p><p>同时还不得不借助工具、或者编写脚本进行分析，以缩小问题范围、发现问题。</p><p>简单的使用Tracepoint已经不能满足需求，因此就花点精力进行梳理。</p><h1 id="1-ftrace背景"><a href="#1-ftrace背景" class="headerlink" title="1. ftrace背景"></a>1. ftrace背景</h1><p>ftrace是Function Trace的意思，最开始主要用于记录内核函数运行轨迹；随着功能的逐渐增加，演变成一个跟踪框架。</p><p>包含了静态tracepoint，针对不同subsystem提供一个目录进行开关；还包括不同的动态跟踪器，function、function_graph、wakeup等等。</p><p>ftrace的帮助文档在<a href="http://elixir.free-electrons.com/linux/v3.4.110/source/Documentation/trace">Documentation&#x2F;trace</a>，ftrace代码主要在<a href="http://elixir.free-electrons.com/linux/v3.4.110/source/kernel/trace">kernel&#x2F;trace</a>，ftrace相关头文件在<a href="http://elixir.free-electrons.com/linux/v3.4.110/source/include/trace">include&#x2F;trace</a>中。</p><p>WiKiPedia有关于<a href="https://en.wikipedia.org/wiki/Ftrace">ftrace</a>的简单介绍。</p><p>ftrace的作者在LinuxCon 2010有一篇关于**<a href="https://events.static.linuxfound.org/slides/2010/linuxcon_japan/linuxcon_jp2010_rostedt.pdf">Ftrace Linux Kernel Tracing</a>**的slides值得一读。</p><h1 id="2-ftrace框架介绍"><a href="#2-ftrace框架介绍" class="headerlink" title="2. ftrace框架介绍"></a>2. ftrace框架介绍</h1><p>整个ftrace框架可以分为几部分：ftrace核心框架，RingBuffer，debugfs，Tracepoint，各种Tracer。</p><p>ftrace框架是整个ftrace功能的纽带，包括对内和的修改，Tracer的注册，RingBuffer的控制等等。</p><p>RingBuffer是静态动态ftrace的载体。</p><p>debugfs则提供了用户空间对ftrace设置接口。</p><p>Tracepoint是静态trace，他需要提前编译进内核;可以定制打印内容，自由添加;并且内核对主要subsystem提供了Tracepoint。</p><p>Tracer有很多种，主要几大类：</p><blockquote><p>函数类：function， function_graph， stack</p><p>延时类：irqsoff， preemptoff， preemptirqsoff， wakeup， wakeup_rt， waktup_dl</p><p>其他类：nop， mmiotrace， blk</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/image001.jpg" alt="ftrace 组成"></p><h2 id="2-1-ftrace核心初始化"><a href="#2-1-ftrace核心初始化" class="headerlink" title="2.1 ftrace核心初始化"></a>2.1 ftrace核心初始化</h2><p> trace.c是ftrace的核心，包括三个initcall：tracer_alloc_buffers、trace_init_debugfs、clear_boot_tracer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">start_kernel--&gt;</span><br><span class="line">    trace_init--&gt;</span><br><span class="line">        tracer_alloc_buffers--------------------分配ftrace需要的RingBuffer</span><br><span class="line">            register_tracer(&amp;nop_trace)---------默认nop跟踪器</span><br><span class="line">        trace_event_init------------------------创建静态Trace Event，进行初始化。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs_initcall(tracer_init_debugfs);--&gt;</span><br><span class="line">    tracing_init_dentry--------------------------在sys/kernel/debug下，创建tracing目录</span><br><span class="line">    init_tracer_debugfs--------------------------</span><br><span class="line">        ftrace_create_function_files-------------创建主要的tracing目录下节点</span><br><span class="line">            allocate_ftrace_ops------------------function_trace_call</span><br><span class="line">            ftrace_create_filter_files-----------创建function tracer相关的节点set_ftrace_filter/set_ftrace_notrace</span><br><span class="line">    trace_create_file----------------------------创建saved_cmdlines等</span><br><span class="line">    create_trace_instances-----------------------创建tracing/instances/目录</span><br><span class="line">    create_trace_options_dir---------------------创建tracing/optoins/目录</span><br><span class="line">    tracing_init_debugfs_percpu------------------创建per_cpu目录</span><br><span class="line">late_initcall(clear_boot_tracer);</span><br></pre></td></tr></table></figure><p> tracer_alloc_buffers主要申请一个最小1KB的RingBuffer，然后注册一些Notifier和初始化一些列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">__init static int tracer_alloc_buffers(void)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    /* To save memory, keep the ring buffer size to its minimum */</span><br><span class="line">    if (ring_buffer_expanded)----------------------------------------------在初始化的时候，分配一个最小量</span><br><span class="line">        ring_buf_size = trace_buf_size;</span><br><span class="line">    else</span><br><span class="line">        ring_buf_size = 1;</span><br><span class="line">...</span><br><span class="line">    /* TODO: make the number of buffers hot pluggable with CPUS */</span><br><span class="line">    if (allocate_trace_buffers(&amp;global_trace, ring_buf_size) &lt; 0) &#123;--------分配RingBuffer内存</span><br><span class="line">        printk(KERN_ERR &quot;tracer: failed to allocate ring buffer!\n&quot;);</span><br><span class="line">        WARN_ON(1);</span><br><span class="line">        goto out_free_savedcmd;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    /*</span><br><span class="line">     * register_tracer() might reference current_trace, so it</span><br><span class="line">     * needs to be set before we register anything. This is</span><br><span class="line">     * just a bootstrap of current_trace anyway.</span><br><span class="line">     */</span><br><span class="line">    global_trace.current_trace = &amp;nop_trace;----------------------------默认nop跟踪器</span><br><span class="line"></span><br><span class="line">    global_trace.max_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;</span><br><span class="line"></span><br><span class="line">    ftrace_init_global_array_ops(&amp;global_trace);</span><br><span class="line"></span><br><span class="line">    register_tracer(&amp;nop_trace);----------------------------------------注册nop跟踪器</span><br><span class="line"></span><br><span class="line">    /* All seems OK, enable tracing */</span><br><span class="line">    tracing_disabled = 0;</span><br><span class="line"></span><br><span class="line">    atomic_notifier_chain_register(&amp;panic_notifier_list,</span><br><span class="line">                       &amp;trace_panic_notifier);</span><br><span class="line"></span><br><span class="line">    register_die_notifier(&amp;trace_die_notifier);</span><br><span class="line"></span><br><span class="line">    global_trace.flags = TRACE_ARRAY_FL_GLOBAL;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;global_trace.systems);</span><br><span class="line">    INIT_LIST_HEAD(&amp;global_trace.events);</span><br><span class="line">    list_add(&amp;global_trace.list, &amp;ftrace_trace_arrays);</span><br><span class="line"></span><br><span class="line">    while (trace_boot_options) &#123;</span><br><span class="line">        char *option;</span><br><span class="line"></span><br><span class="line">        option = strsep(&amp;trace_boot_options, &quot;,&quot;);</span><br><span class="line">        trace_set_options(&amp;global_trace, option);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    register_snapshot_cmd();------------------------------------------创建snapshot节点</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-trace-event"><a href="#2-2-trace-event" class="headerlink" title="2.2 trace event"></a>2.2 trace event</h2><p> 在trace_init–&gt;trace_event_init–&gt;event_trace_enable中，已经创建了tracing&#x2F;events下的节点，并且做好了准备工作。</p><p>event_trace_enable被初次调用的地方很靠前，甚至在pid 1之前。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void __init trace_event_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    event_trace_memsetup();------------------------------------------创建field_cachep、file_cachep高速缓存</span><br><span class="line">    init_ftrace_syscalls();------------------------------------------对所有系统调用如后保存在syscalls_metadata</span><br><span class="line">    event_trace_enable();--------------------------------------------在系统启动阶段初始化Trace Event，在debug创建后在附着到上面</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static __init int event_trace_enable(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct trace_array *tr = top_trace_array();</span><br><span class="line">    struct ftrace_event_call **iter, *call;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    if (!tr)</span><br><span class="line">        return -ENODEV;</span><br><span class="line"></span><br><span class="line">    for_each_event(iter, __start_ftrace_events, __stop_ftrace_events) &#123;----------遍历所有的Events，放入ftrace_events链表</span><br><span class="line"></span><br><span class="line">        call = *iter;</span><br><span class="line">        ret = event_init(call);</span><br><span class="line">        if (!ret)</span><br><span class="line">            list_add(&amp;call-&gt;list, &amp;ftrace_events);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We need the top trace array to have a working set of trace</span><br><span class="line">     * points at early init, before the debug files and directories</span><br><span class="line">     * are created. Create the file entries now, and attach them</span><br><span class="line">     * to the actual file dentries later.</span><br><span class="line">     */</span><br><span class="line">    __trace_early_add_events(tr);</span><br><span class="line"></span><br><span class="line">    early_enable_events(tr, false);</span><br><span class="line"></span><br><span class="line">    trace_printk_start_comm();</span><br><span class="line"></span><br><span class="line">    register_event_cmds();--------------------------------------------------------注册enable_event、disable_event两个命令</span><br><span class="line"></span><br><span class="line">    register_trigger_cmds();------------------------------------------------------注册traceon、traceoff、snapshot等命令</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他Events相关初始化如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">early_initcall(event_trace_enable_again);----------在trace_event_init已经调用过early_enable_events，这里在early_initcall再次使能。</span><br><span class="line"></span><br><span class="line">fs_initcall(event_trace_init);---------------------创建available_events节点</span><br></pre></td></tr></table></figure><h2 id="2-3-function跟踪器"><a href="#2-3-function跟踪器" class="headerlink" title="2.3 function跟踪器"></a>2.3 function跟踪器</h2><p>function tracer的初始化通过init_function_trace建立。</p><p><code>core_initcall(init_function_trace);</code></p><p>init_function_trace在init_func_cmd_traceon中，创建了一系列命令：traceon&#x2F;traceoff&#x2F;stacktrace&#x2F;dump&#x2F;cpudump。然后是注册function_trace这个tracer。</p><p>Tracer结构体如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static struct tracer function_trace __tracer_data =</span><br><span class="line">&#123;</span><br><span class="line">    .name        = &quot;function&quot;,</span><br><span class="line">    .init        = function_trace_init,--------------通过echo function &gt; current_tracer触发</span><br><span class="line">    .reset        = function_trace_reset,------------通过echo 1 &gt;tracing_on触发</span><br><span class="line">    .start        = function_trace_start,------------通过echo 0 &gt;tracing_off触发</span><br><span class="line">    .flags        = &amp;func_flags,</span><br><span class="line">    .set_flag    = func_set_flag,</span><br><span class="line">    .allow_instances = true,</span><br><span class="line">#ifdef CONFIG_FTRACE_SELFTEST</span><br><span class="line">    .selftest    = trace_selftest_startup_function,</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> function_trace_init进行function tracer相关设置。</p><h2 id="2-4-function-graph跟踪器"><a href="#2-4-function-graph跟踪器" class="headerlink" title="2.4 function_graph跟踪器"></a>2.4 function_graph跟踪器</h2><p>注册function_graph跟踪器，创建max_graph_depth节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static struct tracer graph_trace __tracer_data = &#123;</span><br><span class="line">    .name        = &quot;function_graph&quot;,</span><br><span class="line">    .update_thresh    = graph_trace_update_thresh,</span><br><span class="line">    .open        = graph_trace_open,</span><br><span class="line">    .pipe_open    = graph_trace_open,</span><br><span class="line">    .close        = graph_trace_close,</span><br><span class="line">    .pipe_close    = graph_trace_close,</span><br><span class="line">    .init        = graph_trace_init,</span><br><span class="line">    .reset        = graph_trace_reset,</span><br><span class="line">    .print_line    = print_graph_function,</span><br><span class="line">    .print_header    = print_graph_headers,</span><br><span class="line">    .flags        = &amp;tracer_flags,</span><br><span class="line">    .set_flag    = func_graph_set_flag,</span><br><span class="line">#ifdef CONFIG_FTRACE_SELFTEST</span><br><span class="line">    .selftest    = trace_selftest_startup_function_graph,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct file_operations graph_depth_fops = &#123;</span><br><span class="line">    .open        = tracing_open_generic,</span><br><span class="line">    .write        = graph_depth_write,</span><br><span class="line">    .read        = graph_depth_read,</span><br><span class="line">    .llseek        = generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static __init int init_graph_debugfs(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct dentry *d_tracer;</span><br><span class="line"></span><br><span class="line">    d_tracer = tracing_init_dentry();</span><br><span class="line">    if (IS_ERR(d_tracer))</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    trace_create_file(&quot;max_graph_depth&quot;, 0644, d_tracer,</span><br><span class="line">              NULL, &amp;graph_depth_fops);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(init_graph_debugfs);</span><br><span class="line"></span><br><span class="line">static __init int init_graph_trace(void)</span><br><span class="line">&#123;</span><br><span class="line">    max_bytes_for_cpu = snprintf(NULL, 0, &quot;%d&quot;, nr_cpu_ids - 1);</span><br><span class="line"></span><br><span class="line">    if (!register_ftrace_event(&amp;graph_trace_entry_event)) &#123;</span><br><span class="line">        pr_warning(&quot;Warning: could not register graph trace events\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!register_ftrace_event(&amp;graph_trace_ret_event)) &#123;</span><br><span class="line">        pr_warning(&quot;Warning: could not register graph trace events\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return register_tracer(&amp;graph_trace);--------------------------------------注册function_graph跟踪器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">core_initcall(init_graph_trace);</span><br></pre></td></tr></table></figure><h2 id="2-5-irqoff-x2F-preemptoff-x2F-preemptirqoff跟踪器"><a href="#2-5-irqoff-x2F-preemptoff-x2F-preemptirqoff跟踪器" class="headerlink" title="2.5 irqoff&#x2F;preemptoff&#x2F;preemptirqoff跟踪器"></a>2.5 irqoff&#x2F;preemptoff&#x2F;preemptirqoff跟踪器</h2><p>irqoff&#x2F;preemptoff&#x2F;preemptirqoff：注册irqsoff、preemptoff、preemptirqsoff三个跟踪器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core_initcall(init_irqsoff_tracer);</span><br></pre></td></tr></table></figure><h2 id="2-6-wakeup跟踪器"><a href="#2-6-wakeup跟踪器" class="headerlink" title="2.6 wakeup跟踪器"></a>2.6 wakeup跟踪器</h2><p>注册wakeup、wakeup_rt、wakeup_dl三个跟踪器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core_initcall(init_wakeup_tracer);</span><br></pre></td></tr></table></figure><h2 id="2-7-mmiotrace跟踪器"><a href="#2-7-mmiotrace跟踪器" class="headerlink" title="2.7 mmiotrace跟踪器"></a>2.7 mmiotrace跟踪器</h2><p>mmiotrace：注册mmiotrace跟踪器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(init_mmio_trace);</span><br></pre></td></tr></table></figure><h2 id="2-8-branch跟踪器"><a href="#2-8-branch跟踪器" class="headerlink" title="2.8 branch跟踪器"></a>2.8 branch跟踪器</h2><p>branch：注册branch跟踪器，和branch_annotated、branch_all两个统计信息跟踪器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">core_initcall(init_branch_tracer);</span><br><span class="line">fs_initcall(init_annotated_branch_stats);</span><br><span class="line">fs_initcall(all_annotated_branch_stats);</span><br></pre></td></tr></table></figure><h2 id="2-9-blk跟踪器"><a href="#2-9-blk跟踪器" class="headerlink" title="2.9 blk跟踪器"></a>2.9 blk跟踪器</h2><p>blk：注册blk跟踪器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(init_blk_tracer);</span><br></pre></td></tr></table></figure><p> trace_printk：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs_initcall(init_trace_printk_function_export);</span><br><span class="line">early_initcall(init_trace_printk);</span><br></pre></td></tr></table></figure><p> stack_trace：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(stack_trace_init);</span><br></pre></td></tr></table></figure><p>kprobe&#x2F;upbobe：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs_initcall(init_kprobe_trace);</span><br><span class="line">fs_initcall(init_uprobe_trace);</span><br></pre></td></tr></table></figure><h1 id="3-主要代码分析"><a href="#3-主要代码分析" class="headerlink" title="3. 主要代码分析"></a>3. 主要代码分析</h1><h2 id="3-1-内核模块初始化顺序"><a href="#3-1-内核模块初始化顺序" class="headerlink" title="3.1 内核模块初始化顺序"></a>3.1 内核模块初始化顺序</h2><p>内核中不同功能需要有序初始化，但是相同等级的顺序是没有保证的。</p><p>Linux ftrace相关的模块众多，使用了不同等级的initcall。</p><p>从下面的定义可以看出他们在内核启动时的调用顺序，模块等级在include&#x2F;linux&#x2F;init.h中定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#define __define_initcall(level,fn,id) \</span><br><span class="line">    static initcall_t __initcall_##fn##id __used \</span><br><span class="line">    __attribute__((__section__(&quot;.initcall&quot; level &quot;.init&quot;))) = fn</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Early initcalls run before initializing SMP.</span><br><span class="line"> *</span><br><span class="line"> * Only for built-in code, not modules.</span><br><span class="line"> */</span><br><span class="line">#define early_initcall(fn)        __define_initcall(&quot;early&quot;,fn,early)--------------------所谓的early就是在初始化SMP之前调用</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * A &quot;pure&quot; initcall has no dependencies on anything else, and purely</span><br><span class="line"> * initializes variables that couldn&#x27;t be statically initialized.</span><br><span class="line"> *</span><br><span class="line"> * This only exists for built-in code, not for modules.</span><br><span class="line"> */</span><br><span class="line">#define pure_initcall(fn)        __define_initcall(&quot;0&quot;,fn,0)</span><br><span class="line"></span><br><span class="line">#define core_initcall(fn)        __define_initcall(&quot;1&quot;,fn,1)</span><br><span class="line">#define core_initcall_sync(fn)        __define_initcall(&quot;1s&quot;,fn,1s)</span><br><span class="line">#define postcore_initcall(fn)        __define_initcall(&quot;2&quot;,fn,2)</span><br><span class="line">#define postcore_initcall_sync(fn)    __define_initcall(&quot;2s&quot;,fn,2s)</span><br><span class="line">#define arch_initcall(fn)        __define_initcall(&quot;3&quot;,fn,3)</span><br><span class="line">#define arch_initcall_sync(fn)        __define_initcall(&quot;3s&quot;,fn,3s)</span><br><span class="line">#define subsys_initcall(fn)        __define_initcall(&quot;4&quot;,fn,4)</span><br><span class="line">#define subsys_initcall_sync(fn)    __define_initcall(&quot;4s&quot;,fn,4s)</span><br><span class="line">#define fs_initcall(fn)            __define_initcall(&quot;5&quot;,fn,5)</span><br><span class="line">#define fs_initcall_sync(fn)        __define_initcall(&quot;5s&quot;,fn,5s)</span><br><span class="line">#define rootfs_initcall(fn)        __define_initcall(&quot;rootfs&quot;,fn,rootfs)</span><br><span class="line">#define device_initcall(fn)        __define_initcall(&quot;6&quot;,fn,6)----------------------------对应module_init</span><br><span class="line">#define device_initcall_sync(fn)    __define_initcall(&quot;6s&quot;,fn,6s)</span><br><span class="line">#define late_initcall(fn)        __define_initcall(&quot;7&quot;,fn,7)</span><br><span class="line">#define late_initcall_sync(fn)        __define_initcall(&quot;7s&quot;,fn,7s)</span><br></pre></td></tr></table></figure><h2 id="3-2-ftrace初始化"><a href="#3-2-ftrace初始化" class="headerlink" title="3.2 ftrace初始化"></a>3.2 ftrace初始化</h2><h2 id="3-3-RingBuffer"><a href="#3-3-RingBuffer" class="headerlink" title="3.3 RingBuffer"></a>3.3 RingBuffer</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="4-ftrace的配置和使用"><a href="#4-ftrace的配置和使用" class="headerlink" title="4. ftrace的配置和使用"></a>4. ftrace的配置和使用</h1><p>&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing目录下提供了ftrace的设置和属性接口，对ftrace的配置可以通过echo。了解每个文件的作用和如何设置对于理解整个ftrace框架很有作用。</p><p>下面是Ubuntu 16.04+Kernel 4.10.0-42-generic的&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">README------------------------一个简单的关于Tracepoing的HOWTO，cat读取，echo设置。</span><br><span class="line"></span><br><span class="line">通用配置：</span><br><span class="line">available_tracers-------------当前编译及内核的跟踪器列表，current_tracer必须是这里面支持的跟踪器。</span><br><span class="line">current_tracer----------------用于设置或者显示当前使用的跟踪器列表。系统启动缺省值为nop，使用echo将跟踪器名字写入即可打开。可以通过写入nop重置跟踪器。</span><br><span class="line">buffer_size_kb----------------用于设置单个CPU所使用的跟踪缓存的大小。跟踪缓存为RingBuffer形式，如果跟踪太多，旧的信息会被新的跟踪信息覆盖掉。需要先将current_trace设置为nop才可以。</span><br><span class="line">buffer_total_size_kb----------显示所有的跟踪缓存大小，不同之处在于buffer_size_kb是单个CPU的，buffer_total_size_kb是所有CPU的和。</span><br><span class="line"></span><br><span class="line">free_buffer-------------------此文件用于在一个进程被关闭后，同时释放RingBuffer内存，并将调整大小到最小值。</span><br><span class="line">hwlat_detector/</span><br><span class="line">instances/--------------------创建不同的trace buffer实例，可以在不同的trace buffers中分开记录。</span><br><span class="line">tracing_cpumask---------------可以通过此文件设置允许跟踪特定CPU，二进制格式。</span><br><span class="line">per_cpu-----------------------CPU相关的trace信息，包括stats、trace、trace_pipe和trace_pipe_raw。</span><br><span class="line">　　　　　　　　　　　　　　　　　　stats：当前CPU的trace统计信息</span><br><span class="line">　　　　　　　　　　　　　　　　　　trace：当前CPU的trace文件。</span><br><span class="line">　　　　　　　　　　　　　　　　　　trace_pipe：当前CPU的trace_pipe文件。</span><br><span class="line">printk_formats----------------提供给工具读取原始格式trace的文件。</span><br><span class="line">saved_cmdlines----------------存放pid对应的comm名称作为ftrace的cache，这样ftrace中不光能显示pid还能显示comm。</span><br><span class="line">saved_cmdlines_size-----------saved_cmdlines的数目</span><br><span class="line">snapshot----------------------是对trace的snapshot。</span><br><span class="line">                              echo 0清空缓存，并释放对应内存。</span><br><span class="line">                              echo 1进行对当前trace进行snapshot，如没有内存则分配。</span><br><span class="line">                              echo 2清空缓存，不释放也不分配内存。</span><br><span class="line">trace-------------------------查看获取到的跟踪信息的接口，echo &gt; trace可以清空当前RingBuffer。</span><br><span class="line">trace_pipe--------------------输出和trace一样的内容，但是此文件输出Trace同时将RingBuffer中的内容删除，这样就避免了RingBuffer的溢出。可以通过cat trace_pipe &gt; trace.txt &amp;保存文件。</span><br><span class="line">trace_clock-------------------显示当前Trace的timestamp所基于的时钟，默认使用local时钟。local：默认时钟；可能无法在不同CPU间同步；global：不同CUP间同步，但是可能比local慢；counter：这是一个跨CPU计数器，需要分析不同CPU间event顺序比较有效。</span><br><span class="line">trace_marker------------------从用户空间写入标记到trace中，用于用户空间行为和内核时间同步。</span><br><span class="line">trace_marker_raw--------------以二进制格式写入到trace中。</span><br><span class="line">trace_options-----------------控制Trace打印内容或者操作跟踪器，可以通过trace_options添加很多附加信息。</span><br><span class="line">options-----------------------trace选项的一系列文件，和trace_options对应。</span><br><span class="line">trace_stat/-------------------每个CPU的Trace统计信息</span><br><span class="line">tracing_max_latency-----------记录Tracer的最大延时，</span><br><span class="line">tracing_on--------------------用于控制跟踪打开或停止，0停止跟踪，1继续跟踪。</span><br><span class="line">tracing_thresh----------------延时记录Trace的阈值，当延时超过此值时才开始记录Trace。单位是ms，只有非0才起作用。</span><br><span class="line"></span><br><span class="line">Events配置：</span><br><span class="line">available_events--------------列出系统中所有可用的Trace events，分两个层级，用冒号隔开。</span><br><span class="line">events/-----------------------系统Trace events目录，在每个events下面都有enable、filter和fotmat。enable是开关；format是events的格式，然后根据格式设置 filter。</span><br><span class="line">set_event---------------------将Trace events名称直接写入set_event就可以打开。</span><br><span class="line">set_event_pid-----------------指定追踪特定进程的events。</span><br><span class="line"></span><br><span class="line">Function配置：</span><br><span class="line">available_filter_functions----记录了当前可以跟踪的内核函数，不在该文件中列出的函数，无法跟踪其活动。</span><br><span class="line">dyn_ftrace_total_info---------显示available_filter_functins中跟中函数的数目，两者一致。</span><br><span class="line">enabled_functions-------------显示有回调附着的函数名称。</span><br><span class="line">function_profile_enabled------打开此选项，在trace_stat中就会显示function的统计信息。</span><br><span class="line">set_ftrace_filter-------------用于显示指定要跟踪的函数</span><br><span class="line">set_ftrace_notrace------------用于指定不跟踪的函数，缺省为空。</span><br><span class="line">set_ftrace_pid----------------用于指定要追踪特定进程的函数。</span><br><span class="line"></span><br><span class="line">Function graph配置：</span><br><span class="line">max_graph_depth---------------函数嵌套的最大深度。</span><br><span class="line">set_graph_function------------设置要清晰显示调用关系的函数，在使用function_graph跟踪器是使用，缺省对所有函数都生成调用关系。</span><br><span class="line">set_graph_notrace-------------不跟踪特定的函数嵌套调用。</span><br><span class="line"></span><br><span class="line">Stack trace设置：</span><br><span class="line">stack_max_size----------------当使用stack跟踪器时，记录产生过的最大stack size</span><br><span class="line">stack_trace-------------------显示stack的back trace</span><br><span class="line">stack_trace_filter------------设置stack tracer不检查的函数名称</span><br><span class="line"></span><br><span class="line">Kernel dynamic events:</span><br><span class="line">kprobe_events</span><br><span class="line">kprobe_profile</span><br><span class="line"></span><br><span class="line">Userspace dynamic events:</span><br><span class="line">uprobe_events</span><br><span class="line">uprobe_profile</span><br></pre></td></tr></table></figure><h2 id="4-1-通用配置"><a href="#4-1-通用配置" class="headerlink" title="4.1 通用配置"></a>4.1 通用配置</h2><h3 id="使能和配置大小"><a href="#使能和配置大小" class="headerlink" title="使能和配置大小"></a>使能和配置大小</h3><p>常用的配置有对Trace的开关(tracing_on)</p><blockquote><p>echo 0&#x2F;1 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;tracing_on</p></blockquote><p>设置RingBuffer大小(buffer_size_kb),同时buffer_total_size_kb就变成NR_CPUS的倍数。</p><h3 id="trace、trace-pipe和snapshot的区别？"><a href="#trace、trace-pipe和snapshot的区别？" class="headerlink" title="trace、trace_pipe和snapshot的区别？"></a><strong>trace、trace_pipe和snapshot的区别？</strong></h3><p>trace是从RingBuffer中取出内容，trace_pipe会一直读取Buffer流。</p><p>snapshot是trace的一个瞬间快照：</p><blockquote><p>echo 0 &gt; snapshot : Clears and frees snapshot buffer<br>echo 1 &gt; snapshot : Allocates snapshot buffer, if not already allocated.<br>           Takes a snapshot of the main buffer.<br>echo 2 &gt; snapshot : Clears snapshot buffer (but does not allocate or free)<br>           (Doesn’t have to be ‘2’ works with any number that<br>            is not a ‘0’ or ‘1’)</p></blockquote><h3 id="Tracer"><a href="#Tracer" class="headerlink" title="Tracer"></a><strong>Tracer</strong></h3><p>从available_tracers可以获取系统支持的Tracer,current_tracer是当前使用中的Tracer。</p><p>Events只有在nop tracer下才会起作用，同时多个tracer不能共享。同一时候只能一个Tracer在生效。</p><blockquote><p>cat available_tracers</p><p><em>hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function nop</em></p><p>echo function &gt; current_tracer</p></blockquote><h3 id="instances"><a href="#instances" class="headerlink" title="instances"></a><strong>instances</strong></h3><p>在instances目录下，可以通过mkdir创建instance，rmdir删除instance。</p><p>新目录下，有很多类似tracing下的文件，可以对其进行配置。然后读取专有的trace&#x2F;trace_pipe。</p><blockquote><p>mkdir foo</p><p>ls foo</p><p><em>available_tracers   options       set_ftrace_pid  trace_options<br>buffer_size_kb    per_cpu       snapshot     trace_pipe<br>buffer_total_size_kb set_event      trace       tracing_cpumask<br>current_tracer    set_event_pid    trace_clock    tracing_max_latency<br>events        set_ftrace_filter  trace_marker   tracing_on<br>free_buffer      set_ftrace_notrace trace_marker_raw</em></p><p>rmdir foo</p></blockquote><h3 id="特定CPU信息"><a href="#特定CPU信息" class="headerlink" title="特定CPU信息"></a>特定CPU信息</h3><p>抓取特定CPU信息0~3：</p><blockquote><p>echo f &gt; tracing_cpumask</p></blockquote><p>查看特定CPU信息：</p><blockquote><p>cat per_cpu&#x2F;cpu3&#x2F;trace</p></blockquote><h3 id="用户空间插入Trace标记"><a href="#用户空间插入Trace标记" class="headerlink" title="用户空间插入Trace标记"></a>用户空间插入Trace标记</h3><p>有时候需要往Trace中插入标记，trace_marker&#x2F;trace_marker_raw提供了这样功能。</p><blockquote><p>echo CAPTURE_START &gt; trace_marker</p><p>echo CAPTURE_START &gt; trace_marker_raw</p></blockquote><h3 id="Trace选项设置"><a href="#Trace选项设置" class="headerlink" title="Trace选项设置"></a>Trace选项设置</h3><p>通过options内容设置，对Trace的输出进行定制，控制输出大小。</p><p>trace_option是options设置的结果，可以看出开了哪些选项，关闭了哪些选项。</p><blockquote><p>echo 0&#x2F;1 &gt; options&#x2F;irq-info</p></blockquote><h2 id="4-2-Tracepoint"><a href="#4-2-Tracepoint" class="headerlink" title="4.2 Tracepoint"></a>4.2 Tracepoint</h2><p>可以对系统特定事件进行跟踪，在available_events可以找到所有事件。然后将需要的时间通过echo xxx &gt;&gt; set_event写入。也可以通过events目录来打开。</p><h3 id="4-2-1-Trace-Events生效条件"><a href="#4-2-1-Trace-Events生效条件" class="headerlink" title="4.2.1 Trace Events生效条件"></a>4.2.1 Trace Events生效条件</h3><p>在current_tracer为nop，然后设置tracing&#x2F;events下面的enable，即可通过tracing&#x2F;trace或者tracing&#x2F;trace_pipe查看内容。</p><h3 id="4-2-2-Trace-Events的过滤功能？"><a href="#4-2-2-Trace-Events的过滤功能？" class="headerlink" title="4.2.2 Trace Events的过滤功能？"></a>4.2.2 Trace Events的过滤功能？</h3><h4 id="对特定Events的过滤，只打开需要监控的Events。"><a href="#对特定Events的过滤，只打开需要监控的Events。" class="headerlink" title="对特定Events的过滤，只打开需要监控的Events。"></a>对特定Events的过滤，只打开需要监控的Events。</h4><p>如果要禁用某个时间在事件前加上！，如echo “!sys_enter_nic” &gt;&gt; set_event。</p><blockquote><p>echo net &gt;set_event——————————–打开所有net目录下的事件</p><p>echo skb &gt;&gt;set_event——————————附加设置skb到目录下</p></blockquote><p>过滤的表达式是：field-name relational-operator value，多表达式可以通过逻辑运算符&amp;&amp;或者||来组合。</p><p>数字可以通过&#x3D;&#x3D;、！&#x3D;、&gt;、&lt;、&amp;&amp;、||等等来组合filter，来过滤掉很多不需要信息。</p><p>文字可以通过&#x3D;&#x3D;、!&#x3D;、~l来组合filter。</p><p>如针对timer_start事件的Trace：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># tracer: nop</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 327/327   #P:4</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">            Xorg-1684  [000] d... 1140567.102754: timer_start: timer=ffff8800b20300f0 function=intel_uncore_fw_release_timer [i915] expires=4579967822 [timeout=1] flags=0x00000001</span><br><span class="line">      nxnode.bin-11900 [000] d.s. 1140567.105061: timer_start: timer=ffff8803aa293508 function=intel_pstate_timer_func expires=4579967825 [timeout=3] flags=0x00100000</span><br><span class="line">          &lt;idle&gt;-0     [000] dNs. 1140567.108404: timer_start: timer=ffff8802cf845698 function=tcp_delack_timer expires=4579967832 [timeout=10] flags=0x00000000</span><br></pre></td></tr></table></figure><p>在events目录下，有很多子目录。这些目录里面可以使用filter，过滤很多不需要的信息。</p><p>通过format可以知道，timer_start这个时间的field名称，然后在filter进行设置。</p><h4 id="针对某一pid进行过滤。"><a href="#针对某一pid进行过滤。" class="headerlink" title="针对某一pid进行过滤。"></a>针对某一pid进行过滤。</h4><p>将对应pid写入set_event_pid，就可达到只监控某个进程的Events。</p><h4 id="清空跟踪器"><a href="#清空跟踪器" class="headerlink" title="清空跟踪器"></a>清空跟踪器</h4><p>对子系统的filter写入0，即可清空整个子系统的filter</p><p>echo 0 &gt; filter</p><h3 id="4-2-3-Events的trigger功能"><a href="#4-2-3-Events的trigger功能" class="headerlink" title="4.2.3 Events的trigger功能"></a>4.2.3 Events的trigger功能</h3><p>enable_event&#x2F;disable_event</p><p>stacktrace</p><p>snapshot</p><p>traceon&#x2F;traceoff</p><h2 id="4-3-如何在Linux-command-line启动Events"><a href="#4-3-如何在Linux-command-line启动Events" class="headerlink" title="4.3 如何在Linux command line启动Events"></a>4.3 如何在Linux command line启动Events</h2><h2 id="4-3-function跟踪器及动态ftrace"><a href="#4-3-function跟踪器及动态ftrace" class="headerlink" title="4.3 function跟踪器及动态ftrace"></a>4.3 function跟踪器及动态ftrace</h2><p>function跟踪器可以用于跟踪内核函数的调用情况，用于调试分析bug或者了解内核运行过程。</p><h3 id="4-3-1-打开Function跟踪器"><a href="#4-3-1-打开Function跟踪器" class="headerlink" title="4.3.1 打开Function跟踪器"></a>4.3.1 打开Function跟踪器</h3><blockquote><p>echo function &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;current_tracer</p></blockquote><h3 id="4-3-2-在trace-stat中显示function的统计信息"><a href="#4-3-2-在trace-stat中显示function的统计信息" class="headerlink" title="4.3.2 在trace_stat中显示function的统计信息"></a>4.3.2 在trace_stat中显示function的统计信息</h3><h4 id="4-3-2-1-trace-stat的使用"><a href="#4-3-2-1-trace-stat的使用" class="headerlink" title="4.3.2.1 trace_stat的使用"></a>4.3.2.1 trace_stat的使用</h4><p>trace_stat&#x2F;function0在系统初始化就创建，通过function_profile_enabled进行开关。</p><p>统计的函数在set_ftrace_filter和set_ftrace_notrace中设置。</p><blockquote><p>echo 0&#x2F;1 &gt; function_profile_enabled</p></blockquote><p>在使能function优化功能之后，可以查看不同CPU下每个函数执行时间统计信息。</p><p>每列表示的内容分别是：函数名称、调用次数、总耗时、平均耗时、耗时均方差。</p><blockquote><p>cat trace_stat&#x2F;function0</p><p>*Function                Hit  Time      Avg       s^2</p><hr><p>  schedule               65154  1721953948 us   26428.98 us   940990.8 us<br>  schedule_hrtimeout_range       9655  920051856 us   95292.78 us   1284647 us<br>  schedule_hrtimeout_range_clock    9655  920046552 us   95292.23 us   1139416 us<br>  poll_schedule_timeout         5562  768940036 us   138248.8 us   13748771 us<br>  do_sys_poll              9188  485558063 us   52846.98 us   6242561 us<br>  SyS_poll               8419  469986128 us   55824.45 us   6183267 us<br>  core_sys_select            1853  283704721 us   153105.6 us   2109401 us<br>  do_select               1853  283689546 us   153097.4 us   3187699 us<br>  SyS_futex              40313  260910692 us   6472.122 us   8796046 us<br>  do_futex               40313  260888660 us   6471.576 us   8397810 us<br>  futex_wait              18824  260325650 us   13829.45 us   4756645 us*</p></blockquote><h4 id="4-3-2-2-通用tracer-stat注册register-stat-tracer"><a href="#4-3-2-2-通用tracer-stat注册register-stat-tracer" class="headerlink" title="4.3.2.2 通用tracer_stat注册register_stat_tracer()"></a>4.3.2.2 通用tracer_stat注册register_stat_tracer()</h4><p>register_stat_tracer()-&gt;init_stat_file()-&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations tracing_stat_fops = &#123;</span><br><span class="line">    .open        = tracing_stat_open,</span><br><span class="line">    .read        = seq_read,</span><br><span class="line">    .llseek        = seq_lseek,</span><br><span class="line">    .release    = tracing_stat_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int init_stat_file(struct stat_session *session)</span><br><span class="line">&#123;</span><br><span class="line">    if (!stat_dir &amp;&amp; tracing_stat_init())</span><br><span class="line">        return -ENODEV;</span><br><span class="line"></span><br><span class="line">    session-&gt;file = debugfs_create_file(session-&gt;ts-&gt;name, 0644,</span><br><span class="line">                        stat_dir,</span><br><span class="line">                        session, &amp;tracing_stat_fops);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int tracing_stat_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    ret = stat_seq_init(session);</span><br><span class="line">    if (ret)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    ret = seq_open(file, &amp;trace_stat_seq_ops);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct seq_operations trace_stat_seq_ops = &#123;</span><br><span class="line">    .start        = stat_seq_start,</span><br><span class="line">    .next        = stat_seq_next,</span><br><span class="line">    .stop        = stat_seq_stop,</span><br><span class="line">    .show        = stat_seq_show</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int stat_seq_show(struct seq_file *s, void *v)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    return session-&gt;ts-&gt;stat_show(s, l-&gt;stat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-3-function-trace-stat流程"><a href="#4-3-2-3-function-trace-stat流程" class="headerlink" title="4.3.2.3 function trace_stat流程"></a>4.3.2.3 function trace_stat流程</h4><p>trace_stat&#x2F;function0相关代码流程如下：</p><p>ftrace_init_debugfs()-&gt;ftrace_profile_debugfs()-&gt;register_stat_tracer()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations ftrace_profile_fops = &#123;</span><br><span class="line">    .open        = tracing_open_generic,</span><br><span class="line">    .read        = ftrace_profile_read,</span><br><span class="line">    .write        = ftrace_profile_write,</span><br><span class="line">    .llseek        = default_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* used to initialize the real stat files */</span><br><span class="line">static struct tracer_stat function_stats __initdata = &#123;</span><br><span class="line">    .name        = &quot;functions&quot;,</span><br><span class="line">    .stat_start    = function_stat_start,</span><br><span class="line">    .stat_next    = function_stat_next,</span><br><span class="line">    .stat_cmp    = function_stat_cmp,</span><br><span class="line">    .stat_headers    = function_stat_headers,</span><br><span class="line">    .stat_show    = function_stat_show</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static __init void ftrace_profile_debugfs(struct dentry *d_tracer)</span><br><span class="line">&#123;</span><br><span class="line">    struct ftrace_profile_stat *stat;</span><br><span class="line">    struct dentry *entry;</span><br><span class="line">    char *name;</span><br><span class="line">    int ret;</span><br><span class="line">    int cpu;</span><br><span class="line"></span><br><span class="line">    for_each_possible_cpu(cpu) &#123;</span><br><span class="line">        stat = &amp;per_cpu(ftrace_profile_stats, cpu);</span><br><span class="line"></span><br><span class="line">        /* allocate enough for function name + cpu number */</span><br><span class="line">        name = kmalloc(32, GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line">        stat-&gt;stat = function_stats;</span><br><span class="line">        snprintf(name, 32, &quot;function%d&quot;, cpu);----------------------会在trace_stat目录下创建function0节点，0表示CPU序号。</span><br><span class="line">        stat-&gt;stat.name = name;</span><br><span class="line">        ret = register_stat_tracer(&amp;stat-&gt;stat);--------------------注册function_stats</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entry = debugfs_create_file(&quot;function_profile_enabled&quot;, 0644,</span><br><span class="line">                    d_tracer, NULL, &amp;ftrace_profile_fops);----------创建function_profile_enabled节点，函数集为ftrace_profile_fops</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写function_profile_enabled触发代码流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t</span><br><span class="line">ftrace_profile_write(struct file *filp, const char __user *ubuf,</span><br><span class="line">             size_t cnt, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long val;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    ret = kstrtoul_from_user(ubuf, cnt, 10, &amp;val);</span><br><span class="line">    if (ret)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    val = !!val;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;ftrace_profile_lock);</span><br><span class="line">    if (ftrace_profile_enabled ^ val) &#123;</span><br><span class="line">        if (val) &#123;</span><br><span class="line">            ret = ftrace_profile_init();</span><br><span class="line">            if (ret &lt; 0) &#123;</span><br><span class="line">                cnt = ret;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = register_ftrace_profiler();</span><br><span class="line">            if (ret &lt; 0) &#123;</span><br><span class="line">                cnt = ret;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line">            ftrace_profile_enabled = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ftrace_profile_enabled = 0;</span><br><span class="line">            /*</span><br><span class="line">             * unregister_ftrace_profiler calls stop_machine</span><br><span class="line">             * so this acts like an synchronize_sched.</span><br><span class="line">             */</span><br><span class="line">            unregister_ftrace_profiler();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> out:</span><br><span class="line">    mutex_unlock(&amp;ftrace_profile_lock);</span><br><span class="line"></span><br><span class="line">    *ppos += cnt;</span><br><span class="line"></span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int register_ftrace_profiler(void)</span><br><span class="line">&#123;</span><br><span class="line">    return register_ftrace_graph(&amp;profile_graph_return,</span><br><span class="line">                     &amp;profile_graph_entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void unregister_ftrace_profiler(void)</span><br><span class="line">&#123;</span><br><span class="line">    unregister_ftrace_graph();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示profile结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static int function_stat_show(struct seq_file *m, void *v)</span><br><span class="line">&#123;</span><br><span class="line">    struct ftrace_profile *rec = v;</span><br><span class="line">    char str[KSYM_SYMBOL_LEN];</span><br><span class="line">    int ret = 0;</span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">    static struct trace_seq s;</span><br><span class="line">    unsigned long long avg;</span><br><span class="line">    unsigned long long stddev;</span><br><span class="line">#endif</span><br><span class="line">    mutex_lock(&amp;ftrace_profile_lock);</span><br><span class="line"></span><br><span class="line">    /* we raced with function_profile_reset() */</span><br><span class="line">    if (unlikely(rec-&gt;counter == 0)) &#123;</span><br><span class="line">        ret = -EBUSY;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kallsyms_lookup(rec-&gt;ip, NULL, NULL, NULL, str);</span><br><span class="line">    seq_printf(m, &quot;  %-30.30s  %10lu&quot;, str, rec-&gt;counter);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">    seq_printf(m, &quot;    &quot;);</span><br><span class="line">    avg = rec-&gt;time;</span><br><span class="line">    do_div(avg, rec-&gt;counter);</span><br><span class="line"></span><br><span class="line">    /* Sample standard deviation (s^2) */</span><br><span class="line">    if (rec-&gt;counter &lt;= 1)</span><br><span class="line">        stddev = 0;</span><br><span class="line">    else &#123;</span><br><span class="line">        stddev = rec-&gt;time_squared - rec-&gt;counter * avg * avg;</span><br><span class="line">        /*</span><br><span class="line">         * Divide only 1000 for ns^2 -&gt; us^2 conversion.</span><br><span class="line">         * trace_print_graph_duration will divide 1000 again.</span><br><span class="line">         */</span><br><span class="line">        do_div(stddev, (rec-&gt;counter - 1) * 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_seq_init(&amp;s);</span><br><span class="line">    trace_print_graph_duration(rec-&gt;time, &amp;s);</span><br><span class="line">    trace_seq_puts(&amp;s, &quot;    &quot;);</span><br><span class="line">    trace_print_graph_duration(avg, &amp;s);</span><br><span class="line">    trace_seq_puts(&amp;s, &quot;    &quot;);</span><br><span class="line">    trace_print_graph_duration(stddev, &amp;s);</span><br><span class="line">    trace_print_seq(m, &amp;s);</span><br><span class="line">#endif</span><br><span class="line">    seq_putc(m, &#x27;\n&#x27;);</span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;ftrace_profile_lock);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-function跟踪器的过滤器"><a href="#4-3-3-function跟踪器的过滤器" class="headerlink" title="4.3.3 function跟踪器的过滤器"></a>4.3.3 function跟踪器的过滤器</h3><p>在打开CONFIG_DYNAMIC_FTRACE的情况下，增加一些动态跟踪功能，比如available_filter_functions、set_ftrace_filter、set_ftrace_notrace。</p><h4 id="4-3-3-1-set-ftrace-filter跟踪某些函数"><a href="#4-3-3-1-set-ftrace-filter跟踪某些函数" class="headerlink" title="4.3.3.1 set_ftrace_filter跟踪某些函数"></a>4.3.3.1 set_ftrace_filter跟踪某些函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 默认情况下set_ftrace_filter是全部函数都开的。</span><br><span class="line">   cat set_ftrace_filter如下：</span><br><span class="line">   #### all functions enabled ####</span><br><span class="line"></span><br><span class="line">2. 如果想只监控某些函数，通过echo mod_timer add_timer &gt; set_ftrace_filter即可。</span><br><span class="line">   cat set_ftrace_filter如下：</span><br><span class="line">   mod_timer</span><br><span class="line">   add_timer   如果要附加function，通过echo xxx &gt;&gt; set_ftrace_filter即可。3. 使用通配符*　　echo &quot;sched*&quot; &gt; set_ftrace_filter----------------选择所有以sched开头的函数　　echo &quot;*sched*&quot; &gt; set_ftrace_filter---------------选择所有包含sched的函数　　echo &quot;*sched&quot; &gt; set_ftrace_filter----------------选择所有以sched结尾的函数</span><br><span class="line">4. 如果想恢复全开，只需要echo &gt; set_ftrace_filter，即清空filter。</span><br></pre></td></tr></table></figure><h4 id="4-3-3-2-set-ftrace-notrace指定不跟踪哪个函数"><a href="#4-3-3-2-set-ftrace-notrace指定不跟踪哪个函数" class="headerlink" title="4.3.3.2 set_ftrace_notrace指定不跟踪哪个函数"></a>4.3.3.2 set_ftrace_notrace指定不跟踪哪个函数</h4><p>echo xxx &gt; set_ftrace_notrace</p><h4 id="4-3-3-3-set-ftrace-pid只跟踪某一个进程"><a href="#4-3-3-3-set-ftrace-pid只跟踪某一个进程" class="headerlink" title="4.3.3.3 set_ftrace_pid只跟踪某一个进程"></a>4.3.3.3 set_ftrace_pid只跟踪某一个进程</h4><p>echo xxx &gt; set_ftrace_pid</p><p>通过cat trace可以得到结果，只提供了trace函数的调用者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 5/5   #P:1</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">            adbd-1243  [000] d...  7436.183990: mod_timer &lt;-DWC_TIMER_SCHEDULE</span><br><span class="line">          &lt;idle&gt;-0     [000] ..s.  7437.264984: mod_timer &lt;-br_hello_timer_expired</span><br><span class="line">            adbd-1243  [000] d...  7438.000336: mod_timer &lt;-DWC_TIMER_SCHEDULE</span><br><span class="line">            adbd-1243  [000] d...  7438.000549: mod_timer &lt;-DWC_TIMER_SCHEDULE</span><br><span class="line">            adbd-1243  [000] d...  7438.003876: mod_timer &lt;-DWC_TIMER_SCHEDULE</span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="4-3-4-都有哪些函数可以跟踪-available-filter-functions"><a href="#4-3-4-都有哪些函数可以跟踪-available-filter-functions" class="headerlink" title="4.3.4 都有哪些函数可以跟踪(available_filter_functions)?"></a>4.3.4 都有哪些函数可以跟踪(available_filter_functions)?</h3><p>ftrace_init初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">extern unsigned long __start_mcount_loc[];</span><br><span class="line">extern unsigned long __stop_mcount_loc[];</span><br><span class="line"></span><br><span class="line">void __init ftrace_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long count, addr, flags;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    /* Keep the ftrace pointer to the stub */</span><br><span class="line">    addr = (unsigned long)ftrace_stub;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    ftrace_dyn_arch_init(&amp;addr);</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">    /* ftrace_dyn_arch_init places the return code in addr */</span><br><span class="line">    if (addr)</span><br><span class="line">        goto failed;</span><br><span class="line"></span><br><span class="line">    count = __stop_mcount_loc - __start_mcount_loc;</span><br><span class="line"></span><br><span class="line">    ret = ftrace_dyn_table_alloc(count);</span><br><span class="line">    if (ret)</span><br><span class="line">        goto failed;</span><br><span class="line"></span><br><span class="line">    last_ftrace_enabled = ftrace_enabled = 1;</span><br><span class="line"></span><br><span class="line">    ret = ftrace_process_locs(NULL,</span><br><span class="line">                  __start_mcount_loc,</span><br><span class="line">                  __stop_mcount_loc);</span><br><span class="line"></span><br><span class="line">    ret = register_module_notifier(&amp;ftrace_module_exit_nb);</span><br><span class="line">    if (ret)</span><br><span class="line">        pr_warning(&quot;Failed to register trace ftrace module exit notifier\n&quot;);</span><br><span class="line"></span><br><span class="line">    set_ftrace_early_filters();</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"> failed:</span><br><span class="line">    ftrace_disabled = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int ftrace_process_locs(struct module *mod,</span><br><span class="line">                   unsigned long *start,</span><br><span class="line">                   unsigned long *end)</span><br><span class="line">&#123;</span><br><span class="line">    struct ftrace_page *pg;</span><br><span class="line">    unsigned long count;</span><br><span class="line">    unsigned long *p;</span><br><span class="line">    unsigned long addr;</span><br><span class="line">    unsigned long flags = 0; /* Shut up gcc */</span><br><span class="line">    int ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    count = end - start;</span><br><span class="line"></span><br><span class="line">    if (!count)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    pg = ftrace_allocate_pages(count);</span><br><span class="line">    if (!pg)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Core and each module needs their own pages, as</span><br><span class="line">     * modules will free them when they are removed.</span><br><span class="line">     * Force a new page to be allocated for modules.</span><br><span class="line">     */</span><br><span class="line">    if (!mod) &#123;</span><br><span class="line">        WARN_ON(ftrace_pages || ftrace_pages_start);</span><br><span class="line">        /* First initialization */</span><br><span class="line">        ftrace_pages = ftrace_pages_start = pg;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!ftrace_pages)</span><br><span class="line">            goto out;</span><br><span class="line"></span><br><span class="line">        if (WARN_ON(ftrace_pages-&gt;next)) &#123;</span><br><span class="line">            /* Hmm, we have free pages? */</span><br><span class="line">            while (ftrace_pages-&gt;next)</span><br><span class="line">                ftrace_pages = ftrace_pages-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ftrace_pages-&gt;next = pg;</span><br><span class="line">        ftrace_pages = pg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = start;</span><br><span class="line">    while (p &lt; end) &#123;</span><br><span class="line">        addr = ftrace_call_adjust(*p++);</span><br><span class="line">        /*</span><br><span class="line">         * Some architecture linkers will pad between</span><br><span class="line">         * the different mcount_loc sections of different</span><br><span class="line">         * object files to satisfy alignments.</span><br><span class="line">         * Skip any NULL pointers.</span><br><span class="line">         */</span><br><span class="line">        if (!addr)</span><br><span class="line">            continue;</span><br><span class="line">        if (!ftrace_record_ip(addr))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* These new locations need to be initialized */</span><br><span class="line">    ftrace_new_pgs = pg;</span><br><span class="line"></span><br><span class="line">    /* Make each individual set of pages sorted by ips */</span><br><span class="line">    for (; pg; pg = pg-&gt;next)</span><br><span class="line">        sort(pg-&gt;records, pg-&gt;index, sizeof(struct dyn_ftrace),</span><br><span class="line">             ftrace_cmp_recs, ftrace_swap_recs);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We only need to disable interrupts on start up</span><br><span class="line">     * because we are modifying code that an interrupt</span><br><span class="line">     * may execute, and the modification is not atomic.</span><br><span class="line">     * But for modules, nothing runs the code we modify</span><br><span class="line">     * until we are finished with it, and there&#x27;s no</span><br><span class="line">     * reason to cause large interrupt latencies while we do it.</span><br><span class="line">     */</span><br><span class="line">    if (!mod)</span><br><span class="line">        local_irq_save(flags);</span><br><span class="line">    ftrace_update_code(mod);</span><br><span class="line">    if (!mod)</span><br><span class="line">        local_irq_restore(flags);</span><br><span class="line">    ret = 0;</span><br><span class="line"> out:</span><br><span class="line">    mutex_unlock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static __init int ftrace_init_dyn_debugfs(struct dentry *d_tracer)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    trace_create_file(&quot;available_filter_functions&quot;, 0444,</span><br><span class="line">            d_tracer, NULL, &amp;ftrace_avail_fops);</span><br><span class="line"></span><br><span class="line">    trace_create_file(&quot;enabled_functions&quot;, 0444,</span><br><span class="line">            d_tracer, NULL, &amp;ftrace_enabled_fops);</span><br><span class="line"></span><br><span class="line">    trace_create_file(&quot;set_ftrace_filter&quot;, 0644, d_tracer,</span><br><span class="line">            NULL, &amp;ftrace_filter_fops);</span><br><span class="line"></span><br><span class="line">    trace_create_file(&quot;set_ftrace_notrace&quot;, 0644, d_tracer,</span><br><span class="line">                    NULL, &amp;ftrace_notrace_fops);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">    trace_create_file(&quot;set_graph_function&quot;, 0444, d_tracer,</span><br><span class="line">                    NULL,</span><br><span class="line">                    &amp;ftrace_graph_fops);</span><br><span class="line">#endif /* CONFIG_FUNCTION_GRAPH_TRACER */</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct file_operations ftrace_avail_fops = &#123;</span><br><span class="line">    .open = ftrace_avail_open,</span><br><span class="line">    .read = seq_read,</span><br><span class="line">    .llseek = seq_lseek,</span><br><span class="line">    .release = seq_release_private,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">ftrace_avail_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    struct ftrace_iterator *iter;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    if (unlikely(ftrace_disabled))</span><br><span class="line">        return -ENODEV;</span><br><span class="line"></span><br><span class="line">    iter = kzalloc(sizeof(*iter), GFP_KERNEL);</span><br><span class="line">    if (!iter)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    iter-&gt;pg = ftrace_pages_start;</span><br><span class="line">    iter-&gt;ops = &amp;global_ops;</span><br><span class="line"></span><br><span class="line">    ret = seq_open(file, &amp;show_ftrace_seq_ops);</span><br><span class="line">    if (!ret) &#123;</span><br><span class="line">        struct seq_file *m = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">        m-&gt;private = iter;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        kfree(iter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-function-graph跟踪器"><a href="#4-4-function-graph跟踪器" class="headerlink" title="4.4 function_graph跟踪器"></a>4.4 function_graph跟踪器</h2><p>function_graph和function类似，但是function跟踪器只在函数入口点探测，而function_graph在函数入口和退出都进行探测。</p><p>function_graph提供了类似C语言函数调用关系图，并且记录了函数执行耗时。</p><blockquote><p>echo function_graph &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;current_tracer。</p></blockquote><p>function_graph没有设置pid，但是可以设置跟踪哪些函数，不跟踪那些函数：</p><blockquote><p>echo xxx &gt; set_graph_function</p><p>echo xxx &gt; set_graph_notrace</p></blockquote><p>设置function_graph嵌套层数：</p><blockquote><p>echo 10 &gt; max_graph_depth</p></blockquote><p>获得的Trace如下，细节以及调用关系更明确。同时可以获得函数耗时，这对于性能优化非常重要，可以轻松找出热点区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0)               |  SyS_futex() &#123;</span><br><span class="line"> 0)               |    do_futex() &#123;</span><br><span class="line"> 0)               |      futex_wake() &#123;</span><br><span class="line"> 0)               |        get_futex_key() &#123;</span><br><span class="line"> 0)   0.045 us    |          get_futex_key_refs.isra.13();</span><br><span class="line"> 0)   0.337 us    |        &#125;</span><br><span class="line"> 0)   0.040 us    |        hash_futex();</span><br><span class="line"> 0)   0.051 us    |        _raw_spin_lock();</span><br><span class="line"> 0)               |        mark_wake_futex() &#123;</span><br><span class="line"> 0)   0.061 us    |          wake_q_add();</span><br><span class="line"> 0)   0.082 us    |          __unqueue_futex();</span><br><span class="line"> 0)   0.674 us    |        &#125;</span><br><span class="line"> 0)               |        wake_up_q() &#123;</span><br><span class="line">...</span><br><span class="line"> 0) + 14.680 us   |        &#125;</span><br><span class="line"> 0)   0.033 us    |        drop_futex_key_refs.isra.14();</span><br><span class="line"> 0) + 17.200 us   |      &#125;</span><br><span class="line"> 0) + 17.495 us   |    &#125;</span><br><span class="line"> 0) + 17.752 us   |  &#125;</span><br></pre></td></tr></table></figure><p>抓取数据之后，可以通过Python脚本进行简单的转换放到SourceInsight查看更方便。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">output_file = &#x27;output.c&#x27;</span><br><span class="line"></span><br><span class="line">input_file = &#x27;trace.txt&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input = open(input_file, &#x27;rb&#x27;)</span><br><span class="line">output = open(output_file, &#x27;wb&#x27;)</span><br><span class="line"></span><br><span class="line">for line in input:</span><br><span class="line">    m = re.match(&#x27;^ (?P&lt;cpu&gt;[0-9]).&#123;3&#125;(?P&lt;duration&gt;.*) *\| (?P&lt;message&gt;.*)&#x27;, line)</span><br><span class="line">    if(not m):</span><br><span class="line">        continue</span><br><span class="line">    #print m.group(&#x27;cpu&#x27;), m.group(&#x27;duration&#x27;), m.group(&#x27;message&#x27;)</span><br><span class="line">    output.write(m.group(&#x27;message&#x27;) + &quot;//&quot; + m.group(&#x27;duration&#x27;) + &quot;\n&quot;)</span><br></pre></td></tr></table></figure><h2 id="4-5-irqsoff-x2F-preemptoff-x2F-preemptirqsoff跟踪器"><a href="#4-5-irqsoff-x2F-preemptoff-x2F-preemptirqsoff跟踪器" class="headerlink" title="4.5 irqsoff&#x2F;preemptoff&#x2F;preemptirqsoff跟踪器"></a>4.5 irqsoff&#x2F;preemptoff&#x2F;preemptirqsoff跟踪器</h2><h3 id="4-5-1-中断屏蔽和强占禁止带来的危害"><a href="#4-5-1-中断屏蔽和强占禁止带来的危害" class="headerlink" title="4.5.1 中断屏蔽和强占禁止带来的危害"></a>4.5.1 中断屏蔽和强占禁止带来的危害</h3><p>中断屏蔽和强占禁止非常影响系统性能，所以对中断屏蔽和强占禁止进行统计监控，发现异常点很有必要。</p><p>当中断被屏蔽后，CPU无法响应外部事件(除了不可屏蔽中断NMI和系统管理中断SMI)。这就会阻止比如系统Tick中断或者键盘中断，导致响应时间变长。</p><p>同样强占禁止，我们还可以收到中断，但是任务强占被禁止导致更高优先级的任务得不到调度，直到强占被再次允许。</p><h3 id="4-5-2-设置跟踪器"><a href="#4-5-2-设置跟踪器" class="headerlink" title="4.5.2 设置跟踪器"></a>4.5.2 设置跟踪器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; options/function-trace</span><br><span class="line">echo irqsoff &gt; current_tracer</span><br><span class="line">echo 1 &gt; tracing_on</span><br><span class="line">echo 0 &gt; tracing_max_latency</span><br><span class="line"> [...]</span><br><span class="line">echo 0 &gt; tracing_on</span><br><span class="line">cat trace</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># tracer: irqsoff</span><br><span class="line">#</span><br><span class="line"># irqsoff latency trace v1.1.5 on 4.0.0+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 11658 us, #4/4, CPU#2 | (M:server VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: swapper/2-0 (uid:0 nice:0 policy:0 rt_prio:0)</span><br><span class="line">#    -----------------</span><br><span class="line">#  =&gt; started at: rcu_idle_enter</span><br><span class="line">#  =&gt; ended at:   arch_cpu_idle---------------------记录禁止中断时间最长的开始和结束函数</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#            </span><br><span class="line">#                 / _-----=&gt; irqs-off----------------d表示中断被disabled，&#x27;.&#x27;表示中断没有被关闭。</span><br><span class="line">#                | / _----=&gt; need-resched------------N-表示need_resched被设置；&#x27;.&#x27;-表示need_resched没有被设置，中断返回不会进行进程切换。</span><br><span class="line">#                || / _---=&gt; hardirq/softirq---------H-表示softirq中发生了硬件中断；h-硬件中断；s-softirq；&#x27;.&#x27;-不在中断上下文中。</span><br><span class="line">#                ||| / _--=&gt; preempt-depth-----------当抢占中断势能后，该域代表preempt_disabled的级别。</span><br><span class="line">#                |||| /     delay            </span><br><span class="line">#  cmd     pid   ||||| time  |   caller      ---------cmd-进程名，pid-进程id，time-表示trace从开始到当前的相对时间，delay-突出显示那些有高延迟的地方以便引起注意。！表示需要引起注意。</span><br><span class="line">#     \   /      |||||  \    |   /         </span><br><span class="line">  &lt;idle&gt;-0       2d...    3us#: rcu_idle_enter</span><br><span class="line">  &lt;idle&gt;-0       2d... 11645us+: arch_cpu_idle</span><br><span class="line">  &lt;idle&gt;-0       2d... 11665us+: trace_hardirqs_on &lt;-arch_cpu_idle</span><br><span class="line">  &lt;idle&gt;-0       2d... 11753us : &lt;stack trace&gt;</span><br><span class="line"> =&gt; cpu_startup_entry</span><br><span class="line"> =&gt; secondary_start_kernel</span><br></pre></td></tr></table></figure><p>察看禁止中断最长函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void cpuidle_idle_call(void)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    rcu_idle_enter();------------------屏蔽中断</span><br><span class="line">...</span><br><span class="line">    if (current_clr_polling_and_test())</span><br><span class="line">        local_irq_enable();</span><br><span class="line">    else</span><br><span class="line">        arch_cpu_idle();---------------开中断</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-wakeup-x2F-wakeup-rt-x2F-wakeup-dl跟踪器"><a href="#4-6-wakeup-x2F-wakeup-rt-x2F-wakeup-dl跟踪器" class="headerlink" title="4.6 wakeup&#x2F;wakeup_rt&#x2F;wakeup_dl跟踪器"></a>4.6 wakeup&#x2F;wakeup_rt&#x2F;wakeup_dl跟踪器</h2><p>wakeup类调度器记录调度延时，也即从系统被唤醒到被调度到的延时。显示的结果类似irqsoff跟踪器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; options/function-trace</span><br><span class="line">echo wakeup &gt; current_tracer</span><br><span class="line">echo 1 &gt; tracing_on</span><br><span class="line">echo 0 &gt; tracing_max_latency</span><br><span class="line">chrt -f 5 sleep 1</span><br><span class="line">echo 0 &gt; tracing_on</span><br><span class="line">cat trace</span><br></pre></td></tr></table></figure><p>wakeup：显示进程从woken到wake up的延时，包括所有进程。</p><p>wakeup_dl：显示SCHED_DEADLINE类型调度延时。</p><p>wakeup_rt：显示实时进程的调度延时。</p><h2 id="4-7-stack跟踪器"><a href="#4-7-stack跟踪器" class="headerlink" title="4.7 stack跟踪器"></a>4.7 stack跟踪器</h2><p>stack跟踪器用于追踪内核栈的使用情况，它记录了每个内核对栈的使用情况。</p><p>stack跟踪器比较特殊，它的使能不在tracing目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       Depth    Size   Location    (-1 entries)</span><br><span class="line">        -----    ----   --------</span><br><span class="line">#</span><br><span class="line">#  Stack tracer disabled</span><br><span class="line">#</span><br><span class="line"># To enable the stack tracer, either add &#x27;stacktrace&#x27; to the</span><br><span class="line"># kernel command line</span><br><span class="line"># or &#x27;echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled&#x27;</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p> 然后通过&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;stack_trace可以查看堆栈轨迹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       Depth    Size   Location    (13 entries)</span><br><span class="line">       -----    ----   --------</span><br><span class="line"> 0)     1952       4   msecs_to_jiffies+0x14/0x34-----------------------一共1952个字节</span><br><span class="line"> 1)     1948      76   update_group_capacity+0x2c/0x2b4</span><br><span class="line"> 2)     1872     256   find_busiest_group+0x10c/0x904</span><br><span class="line"> 3)     1616     168   load_balance+0x170/0x7b0</span><br><span class="line"> 4)     1448     104   pick_next_task_fair+0x1a8/0x500</span><br><span class="line"> 5)     1344      28   __schedule+0x100/0x5b8</span><br><span class="line"> 6)     1316      68   schedule+0x4c/0xa4</span><br><span class="line"> 7)     1248     104   schedule_hrtimeout_range_clock+0x154/0x15c</span><br><span class="line"> 8)     1144      16   schedule_hrtimeout_range+0x1c/0x20</span><br><span class="line"> 9)     1128      24   poll_schedule_timeout+0x48/0x74</span><br><span class="line">10)     1104     968   do_sys_poll+0x3fc/0x4b8-------------------------使用了最大的栈空间</span><br><span class="line">11)      136      40   SyS_poll+0xc4/0x108</span><br><span class="line">12)       96      96   ret_fast_syscall+0x0/0x4c</span><br></pre></td></tr></table></figure><h2 id="4-8-其他Tracer"><a href="#4-8-其他Tracer" class="headerlink" title="4.8 其他Tracer"></a>4.8 其他Tracer</h2><p>mmiotrace：Memory mapped IO</p><p>blk：</p><h2 id="4-9-开机使用ftrace"><a href="#4-9-开机使用ftrace" class="headerlink" title="4.9 开机使用ftrace"></a>4.9 开机使用ftrace</h2><p>存在某些情况，需要尽量早的启动ftrace功能。</p><p>这时候就需要修改command line，在其中打开ftrace相关设置。</p><p>具体的设置有trace_event、trace_buf_size、ftrace、ftrace_notrace、ftrace_filter、ftrace_graph_filter、stacktrace、ftraceftrace_dump_on_oops、tracing_thresh。</p><p>ftrace用于设置tracer，trace_buf_size设置ring buffer大小，trace_event设置跟踪哪些events，ftrace_notrace&#x2F;ftrace_filter&#x2F;ftrace_graph_filter都是设置过滤器。</p><h3 id="4-9-1-trace-event设置trace-events"><a href="#4-9-1-trace-event设置trace-events" class="headerlink" title="4.9.1 trace_event设置trace events"></a>4.9.1 trace_event设置trace events</h3><p>在开机的时候设置需要跟踪的trace events，将内容放入bootup_event_buf。</p><p>通常格式如下，以逗号作为分隔符：</p><blockquote><p>trace_event&#x3D;sched:sched_process_fork,irq:,thermal</p></blockquote><p>然后在event_trace_init()中根据bootup_event_buf进行设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static __init int setup_trace_event(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    strlcpy(bootup_event_buf, str, COMMAND_LINE_SIZE);</span><br><span class="line">    ring_buffer_expanded = 1;</span><br><span class="line">    tracing_selftest_disabled = 1;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">__setup(&quot;trace_event=&quot;, setup_trace_event);</span><br><span class="line"></span><br><span class="line">static __init int event_trace_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct ftrace_event_call **call;</span><br><span class="line">    struct dentry *d_tracer;</span><br><span class="line">    struct dentry *entry;</span><br><span class="line">    struct dentry *d_events;</span><br><span class="line">    int ret;</span><br><span class="line">    char *buf = bootup_event_buf;</span><br><span class="line">    char *token;</span><br><span class="line">...</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        token = strsep(&amp;buf, &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">        if (!token)</span><br><span class="line">            break;</span><br><span class="line">        if (!*token)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        ret = ftrace_set_clr_event(token, 1);</span><br><span class="line">        if (ret)</span><br><span class="line">            pr_warning(&quot;Failed to enable trace event: %s\n&quot;, token);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-2-ftrace相关设置"><a href="#4-9-2-ftrace相关设置" class="headerlink" title="4.9.2 ftrace相关设置"></a>4.9.2 ftrace相关设置</h3><p>在command line中设置ftrace可以在开机时启动指定tracer。</p><p>指定tracer在register_tracer()中进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static char bootup_tracer_buf[MAX_TRACER_SIZE] __initdata;</span><br><span class="line">static char *default_bootup_tracer;</span><br><span class="line"></span><br><span class="line">static int __init set_cmdline_ftrace(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    strncpy(bootup_tracer_buf, str, MAX_TRACER_SIZE);</span><br><span class="line">    default_bootup_tracer = bootup_tracer_buf;------------------------------------------指定tracer的名称</span><br><span class="line">    /* We are using ftrace early, expand it */</span><br><span class="line">    ring_buffer_expanded = 1;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">__setup(&quot;ftrace=&quot;, set_cmdline_ftrace);</span><br><span class="line"></span><br><span class="line">int register_tracer(struct tracer *type)</span><br><span class="line">__releases(kernel_lock)</span><br><span class="line">__acquires(kernel_lock)</span><br><span class="line">&#123;</span><br><span class="line">    struct tracer *t;</span><br><span class="line">    int ret = 0;</span><br><span class="line">...</span><br><span class="line"> out:</span><br><span class="line">    tracing_selftest_running = false;</span><br><span class="line">    mutex_unlock(&amp;trace_types_lock);</span><br><span class="line"></span><br><span class="line">    if (ret || !default_bootup_tracer)</span><br><span class="line">        goto out_unlock;</span><br><span class="line"></span><br><span class="line">    if (strncmp(default_bootup_tracer, type-&gt;name, MAX_TRACER_SIZE))--------------------比较当前注册的tracer是否和ftrace设置的。</span><br><span class="line">        goto out_unlock;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO &quot;Starting tracer &#x27;%s&#x27;\n&quot;, type-&gt;name);</span><br><span class="line">    /* Do we want this tracer to start on bootup? */</span><br><span class="line">    tracing_set_tracer(type-&gt;name);------------------------------------------------------在注册的时候就指定tracer。</span><br><span class="line">    default_bootup_tracer = NULL;</span><br><span class="line">    /* disable other selftests, since this will break it. */</span><br><span class="line">    tracing_selftest_disabled = 1;</span><br><span class="line">#ifdef CONFIG_FTRACE_STARTUP_TEST</span><br><span class="line">    printk(KERN_INFO &quot;Disabling FTRACE selftests due to running tracer &#x27;%s&#x27;\n&quot;,</span><br><span class="line">           type-&gt;name);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> out_unlock:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-ftrace相关工具"><a href="#5-ftrace相关工具" class="headerlink" title="5 ftrace相关工具"></a>5 ftrace相关工具</h1><h2 id="5-1-trace-cmd和kernelshark"><a href="#5-1-trace-cmd和kernelshark" class="headerlink" title="5.1 trace-cmd和kernelshark"></a>5.1 trace-cmd和kernelshark</h2><p>请参照：《<a href="https://www.cnblogs.com/arnoldlu/p/9014365.html">ftrace利器之trace-cmd和kernelshark</a>》。</p><h1 id="6-ftrace实现的原理"><a href="#6-ftrace实现的原理" class="headerlink" title="6 ftrace实现的原理"></a>6 ftrace实现的原理</h1><p>打开对function、function_graph的支持，导致在编译时插入的一段代码。</p><p>然后在echo function&#x2F;function_graph &gt; current_tracer，在运行时将代码进行替换的操作。</p><p>详细解释编译、动态开关等ftrace相关原理和流程。</p><p>《<a href="http://blog.chinaunix.net/uid-23141914-id-5603238.html">ftrace function_graph分析</a>》</p><h2 id="6-0-GCC-pg选项"><a href="#6-0-GCC-pg选项" class="headerlink" title="6.0 GCC -pg选项"></a>6.0 GCC -pg选项</h2><p>对比打开-pg和不打开汇编代码，查看区别，以cpu_down为例。分别查看不同选项下的反汇编。</p><table><thead><tr><th><strong>未开function&#x2F;function_graph tracer</strong></th><th><strong>仅开function tracer</strong></th><th><strong>开function&#x2F;function_graph tracer</strong></th></tr></thead><tbody><tr><td>0000038c <cpu_down>: 38c: e92d4010 push {r4, lr} 390: e1a04000 mov r4, r0 394: e3000000 movw r0, #0 398: e3400000 movt r0, #0 39c: ebfffffe bl 0 <mutex_lock> 3a0: e3003000 movw r3, #0 3a4: e3403000 movt r3, #0 3a8: e5931004 ldr r1, [r3, #4] 3ac: e3510000 cmp r1, #0 3b0: 1a000007 bne 3d4 &lt;cpu_down+0x48&gt; 3b4: e1a00004 mov r0, r4 3b8: ebffff43 bl cc &lt;_cpu_down&gt; 3bc: e1a04000 mov r4, r0 3c0: e3000000 movw r0, #0 3c4: e3400000 movt r0, #0 3c8: ebfffffe bl 0 <mutex_unlock> 3cc: e1a00004 mov r0, r4 3d0: e8bd8010 pop {r4, pc} 3d4: e3e0400f mvn r4, #15 3d8: eafffff8 b 3c0 &lt;cpu_down+0x34&gt;</td><td>000003c0 <cpu_down>: 3c0: e92d4010 push {r4, lr} 3c4: e52de004 push {lr} ; (str lr, [sp, #-4]!) 3c8: ebfffffe bl 0 &lt;__gnu_mcount_nc&gt; 3cc: e1a04000 mov r4, r0 3d0: e3000000 movw r0, #0 3d4: e3400000 movt r0, #0 3d8: ebfffffe bl 0 <mutex_lock> 3dc: e3003000 movw r3, #0 3e0: e3403000 movt r3, #0 3e4: e5931004 ldr r1, [r3, #4] 3e8: e3510000 cmp r1, #0 3ec: 1a000007 bne 410 &lt;cpu_down+0x50&gt; 3f0: e1a00004 mov r0, r4 3f4: ebffff3e bl f4 &lt;_cpu_down&gt; 3f8: e1a04000 mov r4, r0 3fc: e3000000 movw r0, #0 400: e3400000 movt r0, #0 404: ebfffffe bl 0 <mutex_unlock> 408: e1a00004 mov r0, r4 40c: e8bd8010 pop {r4, pc} 410: e3e0400f mvn r4, #15 414: eafffff8 b 3fc &lt;cpu_down+0x3c&gt;</td><td>00000400 <cpu_down>: 400: e1a0c00d mov ip, sp 404: e92dd830 push {r4, r5, fp, ip, lr, pc} 408: e24cb004 sub fp, ip, #4 40c: e52de004 push {lr} ; (str lr, [sp, #-4]!) 410: ebfffffe bl 0 &lt;__gnu_mcount_nc&gt; 414: e1a04000 mov r4, r0 418: e3000000 movw r0, #0 41c: e3400000 movt r0, #0 420: ebfffffe bl 0 <mutex_lock> 424: e3003000 movw r3, #0 428: e3403000 movt r3, #0 42c: e5931004 ldr r1, [r3, #4] 430: e3510000 cmp r1, #0 434: 1a000007 bne 458 &lt;cpu_down+0x58&gt; 438: e1a00004 mov r0, r4 43c: ebffff3a bl 12c &lt;_cpu_down&gt; 440: e1a04000 mov r4, r0 444: e3000000 movw r0, #0 448: e3400000 movt r0, #0 44c: ebfffffe bl 0 <mutex_unlock> 450: e1a00004 mov r0, r4 454: e89da830 ldm sp, {r4, r5, fp, sp, pc} 458: e3e0400f mvn r4, #15 45c: eafffff8 b 444 &lt;cpu_down+0x44&gt;</td></tr></tbody></table><p> __gnu_mcount_nc定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(__gnu_mcount_nc)</span><br><span class="line">#ifdef CONFIG_DYNAMIC_FTRACE</span><br><span class="line">    mov    ip, lr</span><br><span class="line">    ldmia    sp!, &#123;lr&#125;</span><br><span class="line">    mov    pc, ip</span><br><span class="line">#else</span><br><span class="line">    __mcount</span><br><span class="line">#endif</span><br><span class="line">ENDPROC(__gnu_mcount_nc)</span><br></pre></td></tr></table></figure><h2 id="6-1-打开哪些选项才能实现ftrace功能？"><a href="#6-1-打开哪些选项才能实现ftrace功能？" class="headerlink" title="6.1 打开哪些选项才能实现ftrace功能？"></a>6.1 打开哪些选项才能实现ftrace功能？</h2><p>可以看出在定义了CONFIG_FUNCTION_TRACER、CONFIG_DYNAMIC_FTRACE之后就具备了recordmcount的功能。</p><p>如果再定义CONFIG_HAVE_C_RECORDMCOUNT，那么就会使用recordmcount.c而不是recordmcount.pl来进行mcount处理。</p><p>.config中定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CONFIG_FUNCTION_TRACER=y</span><br><span class="line">CONFIG_HAVE_C_RECORDMCOUNT=y</span><br><span class="line">CONFIG_DYNAMIC_FTRACE=y</span><br><span class="line">CONFIG_FTRACE_MCOUNT_RECORD=y</span><br></pre></td></tr></table></figure><p> Makefile中定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ifdef CONFIG_FUNCTION_TRACER</span><br><span class="line">ifndef CC_FLAGS_FTRACE</span><br><span class="line">CC_FLAGS_FTRACE := -pg</span><br><span class="line">endif</span><br><span class="line">export CC_FLAGS_FTRACE</span><br><span class="line">ifdef CONFIG_HAVE_FENTRY</span><br><span class="line">CC_USING_FENTRY    := $(call cc-option, -mfentry -DCC_USING_FENTRY)</span><br><span class="line">endif</span><br><span class="line">KBUILD_CFLAGS    += $(CC_FLAGS_FTRACE) $(CC_USING_FENTRY)</span><br><span class="line">KBUILD_AFLAGS    += $(CC_USING_FENTRY)</span><br><span class="line">ifdef CONFIG_DYNAMIC_FTRACE</span><br><span class="line">    ifdef CONFIG_HAVE_C_RECORDMCOUNT</span><br><span class="line">        BUILD_C_RECORDMCOUNT := y</span><br><span class="line">        export BUILD_C_RECORDMCOUNT</span><br><span class="line">    endif</span><br><span class="line">endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p> Makefile.build中定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ifdef CONFIG_FTRACE_MCOUNT_RECORD</span><br><span class="line">ifdef BUILD_C_RECORDMCOUNT</span><br><span class="line">ifeq (&quot;$(origin RECORDMCOUNT_WARN)&quot;, &quot;command line&quot;)</span><br><span class="line">  RECORDMCOUNT_FLAGS = -w</span><br><span class="line">endif</span><br><span class="line"># Due to recursion, we must skip empty.o.</span><br><span class="line"># The empty.o file is created in the make process in order to determine</span><br><span class="line">#  the target endianness and word size. It is made before all other C</span><br><span class="line">#  files, including recordmcount.</span><br><span class="line">sub_cmd_record_mcount =                    \</span><br><span class="line">    if [ $(@) != &quot;scripts/mod/empty.o&quot; ]; then    \</span><br><span class="line">        $(objtree)/scripts/recordmcount $(RECORDMCOUNT_FLAGS) &quot;$(@)&quot;;    \</span><br><span class="line">    fi;</span><br><span class="line">recordmcount_source := $(srctree)/scripts/recordmcount.c \</span><br><span class="line">            $(srctree)/scripts/recordmcount.h</span><br><span class="line">else...</span><br><span class="line">endif</span><br><span class="line">...</span><br><span class="line"># Built-in and composite module parts</span><br><span class="line">$(obj)/%.o: $(src)/%.c $(recordmcount_source) FORCE</span><br><span class="line">    $(call cmd,force_checksrc)</span><br><span class="line">    $(call if_changed_rule,cc_o_c)</span><br><span class="line"></span><br><span class="line"># Single-part modules are special since we need to mark them in $(MODVERDIR)</span><br><span class="line"></span><br><span class="line">$(single-used-m): $(obj)/%.o: $(src)/%.c $(recordmcount_source) FORCE</span><br><span class="line">    $(call cmd,force_checksrc)</span><br><span class="line">    $(call if_changed_rule,cc_o_c)</span><br><span class="line">    @&#123; echo $(@:.o=.ko); echo $@; &#125; &gt; $(MODVERDIR)/$(@F:.o=.mod)</span><br></pre></td></tr></table></figure><h2 id="6-2-ftrace的mcount功能是如何实现的？"><a href="#6-2-ftrace的mcount功能是如何实现的？" class="headerlink" title="6.2 ftrace的mcount功能是如何实现的？"></a>6.2 ftrace的mcount功能是如何实现的？</h2><p>在Documentation&#x2F;trace&#x2F;ftrace.txt中有一段解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">If CONFIG_DYNAMIC_FTRACE is set, the system will run with virtually no overhead when function tracing is disabled.The way this works is the mcount function call (placed at the start of every kernel function, produced by the -pg switch in gcc),</span><br><span class="line">starts of pointing to a simple return. (Enabling FTRACE will include the -pg switch in the compiling of the kernel.)</span><br><span class="line"></span><br><span class="line">At compile time every C file object is run through the recordmcount program (located in the scripts directory).This program will parse the ELF headers in the C object to find all</span><br><span class="line">the locations in the .text section that call mcount.(Note, only white listed .text sections are processed, since processing other sections like .init.text may cause races due to those sections being freed unexpectedly).</span><br><span class="line"></span><br><span class="line">A new section called &quot;__mcount_loc&quot; is created that holds references to all the mcount call sites in the .text section.</span><br><span class="line">The recordmcount program re-links this section back into the original object.The final linking stage of the kernel will add all these references into a single table.</span><br></pre></td></tr></table></figure><p> 在c文件编译完之后，recordmcount增加一个__mcount_loc段。</p><p>在vmlinux.lds.h文件中对__mcount_loc段归集，在系统初始化的时候有两个参数很重要__start_mcount_loc和__stop_mcount_loc。</p><p>在available_function</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define MCOUNT_REC()    . = ALIGN(8);                \</span><br><span class="line">            VMLINUX_SYMBOL(__start_mcount_loc) = .; \</span><br><span class="line">            *(__mcount_loc)                \</span><br><span class="line">            VMLINUX_SYMBOL(__stop_mcount_loc) = .;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* init and exit section handling */</span><br><span class="line">#define INIT_DATA                            \</span><br><span class="line">    *(.init.data)                            \</span><br><span class="line">...</span><br><span class="line">    KERNEL_CTORS()                            \</span><br><span class="line">    *(.init.rodata)                            \</span><br><span class="line">    MCOUNT_REC()                            \</span><br><span class="line">...</span><br><span class="line">    KERNEL_DTB()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define INIT_DATA_SECTION(initsetup_align)                \</span><br><span class="line">    .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) &#123;        \</span><br><span class="line">        INIT_DATA                        \</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-引入ftrace对性能的影响有多大？"><a href="#6-3-引入ftrace对性能的影响有多大？" class="headerlink" title="6.3 引入ftrace对性能的影响有多大？"></a>6.3 引入ftrace对性能的影响有多大？</h2><p> 在不使用的时候在入口点插入nop，在使用的时候才会替换成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">On boot up, before SMP is initialized, the dynamic ftrace code scans this table and updates all the locations into nops.It also records the locations, which are added to the available_filter_functions list.在启动阶段，SMP初始化之前，ftrace扫描__mcount_loc段，将所有入口地址mcount使用nop替代。这样只要不打开，开销非常小，基本上不产生性能影响。Modules are processed as they are loaded and before they are executed.When a module is unloaded, it also removes its functions from the ftrace function list.This is automatic in the module unload code, and the module author does not need to worry about it.</span><br><span class="line"></span><br><span class="line">When tracing is enabled, the process of modifying the function tracepoints is dependent on architecture....</span><br><span class="line">The new method of modifying the function tracepoints is to place a breakpoint at the location to be modified,sync all CPUs, modify the rest of the instruction not covered by the breakpoint.Sync all CPUs again, and then remove the breakpoint with the finished version to the ftrace call site.</span><br></pre></td></tr></table></figure><p>在内核初始化的初期，ftrace 查询 __mcount_loc 段，得到每个函数的入口地址，并将 mcount 替换为 nop 指令。这样在默认情况下，ftrace 不会对内核性能产生影响。</p><p>当用户打开 ftrace 功能时，ftrace 将这些 nop 指令动态替换为 ftrace_caller，该函数将调用用户注册的 trace 函数。</p><h2 id="6-4-核心函数ftrace-caller-x2F-ftrace-graph-caller"><a href="#6-4-核心函数ftrace-caller-x2F-ftrace-graph-caller" class="headerlink" title="6.4 核心函数ftrace_caller&#x2F;ftrace_graph_caller"></a>6.4 核心函数ftrace_caller&#x2F;ftrace_graph_caller</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_DYNAMIC_FTRACE</span><br><span class="line">ENTRY(ftrace_caller)</span><br><span class="line">UNWIND(.fnstart)</span><br><span class="line">    __ftrace_caller</span><br><span class="line">UNWIND(.fnend)</span><br><span class="line">ENDPROC(ftrace_caller)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.macro __ftrace_caller suffix</span><br><span class="line">    mcount_enter------------------------------------宏mcount_enter</span><br><span class="line"></span><br><span class="line">    mcount_get_lr    r1            @ lr of instrumented func</span><br><span class="line">    mcount_adjust_addr    r0, lr        @ instrumented function</span><br><span class="line"></span><br><span class="line">    .globl ftrace_call\suffix</span><br><span class="line">ftrace_call\suffix:</span><br><span class="line">    bl    ftrace_stub</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">    .globl ftrace_graph_call\suffix</span><br><span class="line">ftrace_graph_call\suffix:</span><br><span class="line">    mov    r0, r0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    mcount_exit------------------------------------宏mcount_exit</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p>.macro mcount_enter———————————-mcount_enter定义<br>stmdb sp!, {r0-r3, lr}<br>.endm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>.macro mcount_get_lr reg<br>ldr \reg, [fp, #-4]<br>.endm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>.macro mcount_exit———————————mcount_exit定义<br>ldr lr, [fp, #-4]<br>ldmia sp!, {r0-r3, pc}<br>.endm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>function_graph：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">ENTRY(ftrace_graph_caller)</span><br><span class="line">UNWIND(.fnstart)</span><br><span class="line">    __ftrace_graph_caller</span><br><span class="line">UNWIND(.fnend)</span><br><span class="line">ENDPROC(ftrace_graph_caller)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">.macro __ftrace_graph_caller</span><br><span class="line">    sub    r0, fp, #4        @ &amp;lr of instrumented routine (&amp;parent)</span><br><span class="line">#ifdef CONFIG_DYNAMIC_FTRACE</span><br><span class="line">    @ called from __ftrace_caller, saved in mcount_enter</span><br><span class="line">    ldr    r1, [sp, #16]        @ instrumented routine (func)</span><br><span class="line">    mcount_adjust_addr    r1, r1</span><br><span class="line">#else</span><br><span class="line">    @ called from __mcount, untouched in lr</span><br><span class="line">    mcount_adjust_addr    r1, lr    @ instrumented routine (func)</span><br><span class="line">#endif</span><br><span class="line">    mov    r2, fp            @ frame pointer</span><br><span class="line">    bl    prepare_ftrace_return</span><br><span class="line">    mcount_exit</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p>参考文档：</p><ol><li><p><a href="https://www.kernel.org/doc/html/latest/core-api/tracepoint.html">The Linux Kernel Tracepoint API</a></p></li><li><p><a href="http://blog.chinaunix.net/uid-20543183-id-1930846.html">Linux内核跟踪之trace框架分析</a></p></li><li><p><a href="http://blog.csdn.net/u011013137/article/details/9093823">linux ftrace追踪一（基本技术结构粗略剖析）</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace1/">使用 ftrace 调试 Linux 内核，第 1 部分</a> &amp; <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace2/">使用 ftrace 调试 Linux 内核，第 2 部分</a> &amp; <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace3/">使用 ftrace 调试 Linux 内核，第 3 部分</a></p></li><li><p><a href="http://elixir.free-electrons.com/linux/v3.4.110/source/Documentation/trace">Linux Tracepoint内核文档</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html">ftrace简介</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux指令后的数字代表什么</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/man_class/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/man_class/</url>
      
        <content type="html"><![CDATA[<p>小括号里的数字，就是一个man的分类号</p><p>Sections of the manual pages</p><pre><code>  The manual Sections are traditionally defined as follows:       </code></pre><p>1 User commands (Programs)</p><pre><code>         Commands that can be executed by the user from within a shell.       </code></pre><p>2 System calls</p><pre><code>         Functions which wrap operations performed by the kernel.      </code></pre><p> 3 Library calls</p><pre><code>         All library functions excluding the system call wrappers (Most of the libc functions).       </code></pre><p>4 Special files (devices)</p><pre><code>         Files found in /dev which allow to access to devices through the kernel.       </code></pre><p>5 File formats and configuration files</p><pre><code>         Describes various human-readable file formats and configuration files.       </code></pre><p>6 Games</p><pre><code>         Games and funny little programs available on the system.       </code></pre><p>7 Overview, conventions, and miscellaneous</p><pre><code>         Overviews or descriptions of various topics, conventions, and protocols, character set standards, the standard filesystem layout, and miscellaneous other things.       </code></pre><p>8 System management commands</p><pre><code>         Commands like mount(8), many of which only root can  execute.   </code></pre><p>1是普通的命令</p><p>2是系统调用,如open,write之类的</p><p>3是库函数,如printf,fread</p><p>4是特殊文件,也就是&#x2F;dev下的各种设备文件</p><p>5是指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义</p><p>6是给游戏留的,由各个游戏自己定义</p><p>7是附件还有一些变量,比如向environ这种全局变量在这里就有说明</p><p>8是系统管理用的命令,这些命令只能由root使用,如ifconfig</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mpstat-Multiprocessor Statistics</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/mpstat/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/mpstat/</url>
      
        <content type="html"><![CDATA[<p>mpstat是Multiprocessor Statistics的缩写，是实时监控工具，报告与cpu的一些统计信息这些信息都存在&#x2F;proc&#x2F;stat文件中，在多CPU系统里，其不但能查看所有的CPU的平均状况的信息，而且能够有查看特定的cpu信息，mpstat最大的特点是:可以查看多核心的cpu中每个计算核心的统计数据；而且类似工具vmstat只能查看系统的整体cpu情况。</p><p>mpstat的语法如下</p><p>mpstat [-P {cpu|ALL}] [internal [count]]<br>其中，各参数含义如下：</p><p>参数<br>    含义<br>-P {cpu l ALL}表示监控哪个CPU， cpu在[0,cpu个数-1]中取值<br>internal相邻的两次采样的间隔时间<br>count采样的次数，count只能和delay一起使用<br>字段的含义</p><p>%user      在internal时间段里，用户态的CPU时间(%)，不包含nice值为负进程  (usr&#x2F;total)*100</p><p>%nice      在internal时间段里，nice值为负进程的CPU时间(%)   (nice&#x2F;total)*100</p><p>%sys       在internal时间段里，内核时间(%)       (system&#x2F;total)*100</p><p>%iowait    在internal时间段里，硬盘IO等待时间(%) (iowait&#x2F;total)*100</p><p>%irq         在internal时间段里，硬中断时间(%)     (irq&#x2F;total)*100</p><p>%soft       在internal时间段里，软中断时间(%)     (softirq&#x2F;total)*100</p><p>%idle       在internal时间段里，CPU除去等待磁盘IO操作外的因为任何原因而空闲的时间闲置时间(%) (idle&#x2F;total)*100</p><p>Note：</p><p>1.vmstat和mpstat 命令的差别：mpstat 可以显示每个处理器的统计，而 vmstat 显示所有处理器的统计。因此，编写糟糕的应用程序（不使用多线程体系结构）可能会运行在一个多处理器机器上，而不使用所有处理器。从而导致一个 CPU 过载，而其他 CPU 却很空闲。通过 mpstat 可以轻松诊断这些类型的问题。</p><p>2.vmstat中所有关于CPU的总结都适合mpstat。当您看到较低的 %idle 数字时，您知道出现了 CPU 不足的问题。当您看到较高的 %iowait 数字时，您知道在当前负载下 I&#x2F;O 子系统出现了某些问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pidstat</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/pidstat/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/pidstat/</url>
      
        <content type="html"><![CDATA[<p><a href="https://man7.org/linux/man-pages/man1/pidstat.1.html">https://man7.org/linux/man-pages/man1/pidstat.1.html</a><br>pidstat是sysstat工具的一个命令，用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况。pidstat首次运行时显示自系统启动开始的各项统计信息，之后运行pidstat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。</p><p>pidstat 的用法：</p><p>pidstat [ 选项 ] [ &lt;时间间隔&gt; ] [ &lt;次数&gt; ]<br>常用的参数：</p><p>-u：默认的参数，显示各个进程的cpu使用统计</p><p>-r：显示各个进程的内存使用统计</p><p>-d：显示各个进程的IO使用情况</p><p>-p：指定进程号</p><p>-w：显示每个进程的上下文切换情况</p><p>-t：显示选择任务的线程的统计信息外的额外信息</p><p>-T { TASK | CHILD | ALL }</p><p>这个选项指定了pidstat监控的。TASK表示报告独立的task，CHILD关键字表示报告进程下所有线程统计信息。ALL表示报告独立的task和task下面的所有线程。</p><p>注意：task和子线程的全局的统计信息和pidstat选项无关。这些统计信息不会对应到当前的统计间隔，这些统计信息只有在子线程kill或者完成的时候才会被收集。</p><p>-V：版本号</p><p>-h：在一行上显示了所有活动，这样其他程序可以容易解析。</p><p>-I：在SMP环境，表示任务的CPU使用率&#x2F;内核数量</p><p>-l：显示命令名和所有参数</p><p>-C comm :只显示那些包含字符串（可是正则表达式）comm的命令的名字</p><p>-s#堆栈的使用</p><p>字段的含义</p><p>PID：进程ID</p><p>%usr：进程在用户空间占用cpu的百分比</p><p>%system：进程在内核空间占用cpu的百分比</p><p>%guest：进程在虚拟机占用cpu的百分比</p><p>%CPU：进程占用cpu的百分比</p><p>CPU：处理进程的cpu编号</p><p>Minflt&#x2F;s:任务每秒发生的次要错误，不需要从磁盘中加载页</p><p>Majflt&#x2F;s:任务每秒发生的主要错误，需要从磁盘中加载页</p><p>VSZ：虚拟地址大小，虚拟内存的使用KB</p><p>RSS：常驻集合大小，非交换区五里内存使用KB</p><p>kB_rd&#x2F;s：每秒从磁盘读取的KB</p><p>kB_wr&#x2F;s：每秒写入磁盘KB</p><p>kB_ccwr&#x2F;s：任务取消的写入磁盘的KB。当任务截断脏的pagecache的时候会发生。</p><p>Cswch&#x2F;s:每秒主动任务上下文切换数量</p><p>Nvcswch&#x2F;s:每秒被动任务上下文切换数量</p><p>Command：当前进程对应的命令</p><p>TGID:主线程的表示</p><p>TID:线程id</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中使用 Pushd 和 Popd 命令来进行高效的目录导航</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/pushd/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/pushd/</url>
      
        <content type="html"><![CDATA[<h1 id="在-Linux-中使用-pushd-和-popd-命令来进行高效的目录导航"><a href="#在-Linux-中使用-pushd-和-popd-命令来进行高效的目录导航" class="headerlink" title="在 Linux 中使用 pushd 和 popd 命令来进行高效的目录导航"></a>在 Linux 中使用 pushd 和 popd 命令来进行高效的目录导航</h1><p>有时候，通过命令来在 Linux 文件系统导航是一件非常痛苦的事情，特别是对于一些新手。通常情况下，我们主要使用 <a href="https://www.tecmint.com/cd-command-in-linux/">cd（改变目录）命令</a>在 Linux 文件系统之间移动。</p><p>在之前的文章中，我们回顾了一个非常简单但很有用的 Linux 上的 CLI 工具，文章叫做 <a href="https://linux.cn/article-8491-1.html">bd：快速返回某级父目录而不用冗余地输入 “cd ..&#x2F;..&#x2F;..”</a></p><p>在这个教程中，我们将讨论两个相关的命令：<code>pushd</code> 和 <code>popd</code> ，使用它们可以高效的浏览 Linux 目录结构。这两个命令在大多数 shell ，比如 bash、tcsh 中都存在。</p><p><strong>推荐阅读：</strong><a href="https://linux.cn/article-5983-1.html">Autojump：快速浏览 Linux 文件系统的一个高级 <code>cd</code> 命令</a></p><h3 id="pushd-和-popd-命令在-Linux-系统中如何工作"><a href="#pushd-和-popd-命令在-Linux-系统中如何工作" class="headerlink" title="pushd 和 popd 命令在 Linux 系统中如何工作"></a>pushd 和 popd 命令在 Linux 系统中如何工作</h3><p><code>pushd</code> 和 <code>popd</code> 命令根据 ‘LIFO’（后进先出）原则工作。在这个原则之下，只有两个操作是允许的：把一个目录压入栈，以及把一个目录弹出栈。</p><p><code>pushd</code> 命令会增加一个目录到栈顶，而 <code>popd</code> 命令会从栈顶移除一个目录。</p><p>为了显示目录栈中（或历史）的目录，我们可以使用下面展示的 <code>dirs</code> 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dirs或$ dirs -v</span><br></pre></td></tr></table></figure><img src="./151608a7o7ofmiyii77it7.png"><p><em><code>dirs</code> - 显示位于目录栈中的目录</em></p><p><code>pushd</code> 命令：将一个目录路径添加到／放入目录栈（历史）中，之后，你可以浏览位于目录栈（历史）中的任意目录。当把一个新的目录入栈时，会打印出当前位于栈中的所有目录。</p><p>下面这些命令会展示这个命令是如何工作的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pushd  /var/www/html/$ pushd ~/Documents/$ pushd ~/Desktop/$ pushd /var/log/</span><br></pre></td></tr></table></figure><img src="./151609lubuzhh8dhd48sf1.png"><p><em><code>pushd</code> - 添加新目录入栈</em></p><p>根据上面输出的目录栈可知（目录索引按倒序排列）：</p><ul><li><code>/var/log</code> 是目录栈中的第五个目录，索引为 0</li><li><code>~/Desktop/</code> 是第四个，索引为 1</li><li><code>~/Document/</code> 是第三个，索引为 2</li><li><code>/var/www/html</code> 是第二个，索引为 3</li><li><code>~</code> 是第一个，索引为 4</li></ul><p>另外，我们也可以使用目录索引的形式 <code>pushd +#</code> 或 <code>pushd -#</code> 来添加目录入栈。为了进入目录 <code>~/Documents</code> ，我们可以输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pushd +2</span><br></pre></td></tr></table></figure><img src="./151609dgghr6jj9wf7jwt2.png"><p><em><code>pushd</code> －通过数字浏览目录</em></p><p>注意，经过上一步操作以后，栈的内容便发生了改变。所以，要从上面的例子中进入目录 <code>/var/www/html</code> ，我们应该使用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pushd +1</span><br></pre></td></tr></table></figure><img src="./151609h3c8nsfo6rgyrtwo.png"><p><em><code>pushd</code> －通过数字浏览目录</em></p><p><code>popd</code> 命令－从栈顶或历史中移除一个目录。为了列出目录栈中的所有目录，只需输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ popd</span><br></pre></td></tr></table></figure><p>为了从目录栈中移除一个目录，我们可以使用 <code>popd +#</code> 或 <code>popd -#</code> 命令，在这时，我们需要输入下面的命令来移除目录 <code>~/Documents</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ popd +1</span><br></pre></td></tr></table></figure><img src="./151610o6fhfm7kde47dzl4.png"><p><em><code>popd</code>－从栈中以移除目录</em></p><p>在这篇文章中，我们阐述了 <code>pushd</code> 和 <code>popd</code> 命令，使用它们可以高效的访问目录结构。你可以通过下面的反馈表和我们分享你关于这篇文章的想法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sadc(8) — Linux Manual Page</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sadc/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sadc/</url>
      
        <content type="html"><![CDATA[<h1 id="sadc-8-—-Linux-manual-page"><a href="#sadc-8-—-Linux-manual-page" class="headerlink" title="sadc(8) — Linux manual page"></a>sadc(8) — Linux manual page</h1><table><thead><tr><th><a href="https://man7.org/linux/man-pages/man8/sadc.8.html#NAME">NAME</a> | <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#SYNOPSIS">SYNOPSIS</a> | <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#DESCRIPTION">DESCRIPTION</a> | <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#OPTIONS">OPTIONS</a> | <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#ENVIRONMENT">ENVIRONMENT</a> | <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#EXAMPLES">EXAMPLES</a> | <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#BUGS">BUGS</a> | <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#FILES">FILES</a> | <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#AUTHOR">AUTHOR</a> | <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#SEE_ALSO">SEE ALSO</a> | <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#COLOPHON">COLOPHON</a></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADC(8)                    Linux User&#x27;s Manual                   SADC(8)</span><br></pre></td></tr></table></figure><h2 id="NAME-top"><a href="#NAME-top" class="headerlink" title="NAME     top"></a>NAME     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadc - System activity data collector.</span><br></pre></td></tr></table></figure><h2 id="SYNOPSIS-top"><a href="#SYNOPSIS-top" class="headerlink" title="SYNOPSIS     top"></a>SYNOPSIS     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib64/sa/sadc [ -C comment ] [ -D ] [ -F ] [ -f ] [ -L</span><br><span class="line">] [ -V ] [ -S &#123; keyword[,...] | ALL | XALL &#125; ] [ interval [ count</span><br><span class="line">] ] [ outfile ]</span><br></pre></td></tr></table></figure><h2 id="DESCRIPTION-top"><a href="#DESCRIPTION-top" class="headerlink" title="DESCRIPTION     top"></a>DESCRIPTION     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">The sadc command samples system data a specified number of times</span><br><span class="line">(count) at a specified interval measured in seconds (interval).</span><br><span class="line">It writes in binary format to the specified outfile or to</span><br><span class="line">standard output. If outfile is set to -, then sadc uses the</span><br><span class="line">standard system activity daily data file (see below).  In this</span><br><span class="line">case, if the file already exists, sadc will overwrite it if it is</span><br><span class="line">from a previous month. By default sadc collects most of the data</span><br><span class="line">available from the kernel.  But there are also optional metrics,</span><br><span class="line">for which the relevant options must be explicitly passed to sadc</span><br><span class="line">to be collected (see option -S below).</span><br><span class="line"></span><br><span class="line">The standard system activity daily data file is named saDD unless</span><br><span class="line">option -D is used, in which case its name is saYYYYMMDD, where</span><br><span class="line">YYYY stands for the current year, MM for the current month and DD</span><br><span class="line">for the current day. By default it is located in the /var/log/sa</span><br><span class="line">directory. Yet it is possible to specify an alternate location</span><br><span class="line">for it: If outfile is a directory (instead of a plain file) then</span><br><span class="line">it will be considered as the directory where the standard system</span><br><span class="line">activity daily data file will be saved.</span><br><span class="line"></span><br><span class="line">When the count parameter is not specified, sadc writes its data</span><br><span class="line">endlessly. When both interval and count are not specified, and</span><br><span class="line">option -C is not used, a dummy record, which is used at system</span><br><span class="line">startup to mark the time when the counter restarts from 0, will</span><br><span class="line">be written.  For example, one of the system startup script may</span><br><span class="line">write the restart mark to the daily data file by the command</span><br><span class="line">entry:</span><br><span class="line"></span><br><span class="line">/usr/local/lib64/sa/sadc -</span><br><span class="line"></span><br><span class="line">The sadc command is intended to be used as a backend to the sar</span><br><span class="line">command.</span><br><span class="line"></span><br><span class="line">Note: The sadc command only reports on local activities.</span><br></pre></td></tr></table></figure><h2 id="OPTIONS-top"><a href="#OPTIONS-top" class="headerlink" title="OPTIONS     top"></a>OPTIONS     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">-C comment</span><br><span class="line">       When neither the interval nor the count parameters are</span><br><span class="line">       specified, this option tells sadc to write a dummy record</span><br><span class="line">       containing the specified comment string. This comment can</span><br><span class="line">       then be displayed with option -C of sar.</span><br><span class="line"></span><br><span class="line">-D     Use saYYYYMMDD instead of saDD as the standard system</span><br><span class="line">       activity daily data file name.</span><br><span class="line"></span><br><span class="line">-F     The creation of outfile will be forced. If the file</span><br><span class="line">       already exists and has a format unknown to sadc then it</span><br><span class="line">       will be truncated. This may be useful for daily data files</span><br><span class="line">       created by an older version of sadc and whose format is no</span><br><span class="line">       longer compatible with current one.</span><br><span class="line"></span><br><span class="line">-f     fdatasync() will be used to ensure data is written to</span><br><span class="line">       disk. This differs from the normal operation in that a</span><br><span class="line">       sudden system reset is less likely to result in the saDD</span><br><span class="line">       datafiles being corrupted. However, this is at the expense</span><br><span class="line">       of performance within the sadc process as forward progress</span><br><span class="line">       will be blocked while data is written to underlying disk</span><br><span class="line">       instead of just to cache.</span><br><span class="line"></span><br><span class="line">-L     sadc will try to get an exclusive lock on the outfile</span><br><span class="line">       before writing to it or truncating it. Failure to get the</span><br><span class="line">       lock is fatal, except in the case of trying to write a</span><br><span class="line">       normal (i.e. not a dummy and not a header) record to an</span><br><span class="line">       existing file, in which case sadc will try again at the</span><br><span class="line">       next interval. Usually, the only reason a lock would fail</span><br><span class="line">       would be if another sadc process were also writing to the</span><br><span class="line">       file. This can happen when cron is used to launch sadc. If</span><br><span class="line">       the system is under heavy load, an old sadc might still be</span><br><span class="line">       running when cron starts a new one. Without locking, this</span><br><span class="line">       situation can result in a corrupted system activity file.</span><br><span class="line"></span><br><span class="line">-S &#123; keyword[,...] | ALL | XALL &#125;</span><br><span class="line">       Possible keywords are DISK, INT, IPV6, POWER, SNMP, XDISK,</span><br><span class="line">       ALL and XALL.</span><br><span class="line">       Specify which optional activities should be collected by</span><br><span class="line">       sadc.  Some activities are optional to prevent data files</span><br><span class="line">       from growing too large. The DISK keyword indicates that</span><br><span class="line">       sadc should collect data for block devices. The INT</span><br><span class="line">       keyword indicates that sadc should collect data for system</span><br><span class="line">       interrupts. The IPV6 keyword indicates that IPv6</span><br><span class="line">       statistics should be collected by sadc. The POWER keyword</span><br><span class="line">       indicates that sadc should collect power management</span><br><span class="line">       statistics. The SNMP keyword indicates that SNMP</span><br><span class="line">       statistics should be collected by sadc. The ALL keyword is</span><br><span class="line">       equivalent to specifying all the keywords above and</span><br><span class="line">       therefore all previous activities are collected.</span><br><span class="line"></span><br><span class="line">       The XDISK keyword is an extension to the DISK one and</span><br><span class="line">       indicates that partitions and filesystems statistics</span><br><span class="line">       should be collected by sadc in addition to disk</span><br><span class="line">       statistics. This option works only with kernels 2.6.25 and</span><br><span class="line">       later. The XALL keyword is equivalent to specifying all</span><br><span class="line">       the keywords above (including keyword extensions) and</span><br><span class="line">       therefore all possible activities are collected.</span><br><span class="line"></span><br><span class="line">       Important note: The activities (including optional ones)</span><br><span class="line">       saved in an existing data file prevail over those selected</span><br><span class="line">       with option -S.  As a consequence, appending data to an</span><br><span class="line">       existing data file will result in option -S being ignored.</span><br><span class="line"></span><br><span class="line">-V     Print version number then exit.</span><br></pre></td></tr></table></figure><h2 id="ENVIRONMENT-top"><a href="#ENVIRONMENT-top" class="headerlink" title="ENVIRONMENT     top"></a>ENVIRONMENT     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The sadc command takes into account the following environment</span><br><span class="line">variable:</span><br><span class="line"></span><br><span class="line">S_TIME_DEF_TIME</span><br><span class="line">       If this variable exists and its value is UTC then sadc</span><br><span class="line">       will save its data in UTC time.  sadc will also use UTC</span><br><span class="line">       time instead of local time to determine the current daily</span><br><span class="line">       data file located in the /var/log/sa directory.</span><br></pre></td></tr></table></figure><h2 id="EXAMPLES-top"><a href="#EXAMPLES-top" class="headerlink" title="EXAMPLES     top"></a>EXAMPLES     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib64/sa/sadc 1 10 /tmp/datafile</span><br><span class="line">       Write 10 records of one second intervals to the</span><br><span class="line">       /tmp/datafile binary file.</span><br><span class="line"></span><br><span class="line">/usr/local/lib64/sa/sadc -C &quot;Backup Start&quot; /tmp/datafile</span><br><span class="line">       Insert the comment &quot;Backup Start&quot; into the file</span><br><span class="line">       /tmp/datafile.</span><br></pre></td></tr></table></figure><h2 id="BUGS-top"><a href="#BUGS-top" class="headerlink" title="BUGS     top"></a>BUGS     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The /proc filesystem must be mounted for the sadc command to</span><br><span class="line">work.</span><br><span class="line"></span><br><span class="line">All the statistics are not necessarily available, depending on</span><br><span class="line">the kernel version used.  sadc assumes that you are using at</span><br><span class="line">least a 2.6 kernel.</span><br></pre></td></tr></table></figure><h2 id="FILES-top"><a href="#FILES-top" class="headerlink" title="FILES     top"></a>FILES     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/var/log/sa/saDD</span><br><span class="line">/var/log/sa/saYYYYMMDD</span><br><span class="line">       The standard system activity daily data files and their</span><br><span class="line">       default location.  YYYY stands for the current year, MM</span><br><span class="line">       for the current month and DD for the current day.</span><br><span class="line">/proc and /sys contain various files with system statistics.</span><br></pre></td></tr></table></figure><h2 id="AUTHOR-top"><a href="#AUTHOR-top" class="headerlink" title="AUTHOR     top"></a>AUTHOR     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sebastien Godard (sysstat &lt;at&gt; orange.fr)</span><br></pre></td></tr></table></figure><h2 id="SEE-ALSO-top"><a href="#SEE-ALSO-top" class="headerlink" title="SEE ALSO     top"></a>SEE ALSO     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sar(1), sa1(8), sa2(8), sadf(1), sysstat(5)</span><br><span class="line"></span><br><span class="line">https://github.com/sysstat/sysstat</span><br><span class="line">http://pagesperso-orange.fr/sebastien.godard/</span><br></pre></td></tr></table></figure><h2 id="COLOPHON-top"><a href="#COLOPHON-top" class="headerlink" title="COLOPHON     top"></a>COLOPHON     <a href="https://man7.org/linux/man-pages/man8/sadc.8.html#top_of_page">top</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">This page is part of the sysstat (sysstat performance monitoring</span><br><span class="line">tools) project.  Information about the project can be found at</span><br><span class="line">⟨http://sebastien.godard.pagesperso-orange.fr/⟩.  If you have a</span><br><span class="line">bug report for this manual page, send it to sysstat-AT-orange.fr.</span><br><span class="line">This page was obtained from the project&#x27;s upstream Git repository</span><br><span class="line">⟨https://github.com/sysstat/sysstat.git⟩ on 2021-08-27.  (At that</span><br><span class="line">time, the date of the most recent commit that was found in the</span><br><span class="line">repository was 2021-07-17.)  If you discover any rendering</span><br><span class="line">problems in this HTML version of the page, or you believe there</span><br><span class="line">is a better or more up-to-date source for the page, or you have</span><br><span class="line">corrections or improvements to the information in this COLOPHON</span><br><span class="line">(which is not part of the original manual page), send a mail to</span><br><span class="line">man-pages@man7.org</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Strace</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/strace/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/strace/</url>
      
        <content type="html"><![CDATA[<p>   strace是个功能强大的Linux调试分析诊断工具，可用于跟踪程序执行时进程系统调用(system call)和所接收的信号，尤其是针对源码不可读或源码无法再编译的程序。</p><p>   在Linux系统中，用户程序运行在一个沙箱(sandbox)里，用户进程不能直接访问计算机硬件设备。当进程需要访问硬件设备(如读取磁盘文件或接收网络数据等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可跟踪进程产生的系统调用，包括参数、返回值和执行所消耗的时间。若strace没有任何输出，并不代表此时进程发生阻塞；也可能程序进程正在自己的沙箱里执行某些不需要与系统其它部分发生通信的事情。strace从内核接收信息，且无需以任何特殊方式来构建内核。</p><p>   strace命令格式如下：</p><p><code>strace [-dffhiqrtttTvVxx] [-a column] [-e expr] [-o file] [-p pid] [-s strsize] [-u username] [-E var=val] [command [arg ...]]</code></p><p>或<code>strace -c [-e expr] [-O overhead] [-S sortby] [-E var=val] [command [arg ...]]</code></p><p>   通过不同的选项开关，strace提供非常丰富的跟踪功能。最简单的应用是，跟踪可执行程序运行时的整个生命周期，将所调用的系统调用的名称、参数和返回值输出到标准错误输出stderr(即屏幕)或-o选项所指定的文件。注意，命令(command)必须位于选项列表之后。</p><p>   详细的strace命令选项列举如下：</p><p>详细的strace命令选项列举如下：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-c</td><td>统计和报告每个系统调用所执行的时间、调用次数和出错次数等</td></tr><tr><td>-d</td><td>输出strace关于标准错误的调试信息</td></tr><tr><td>-f</td><td>跟踪当前进程及其通过fork系统调用所创建的子进程</td></tr><tr><td>-ff</td><td>常与-o选项联合使用，不同进程(子进程)的跟踪结果分别输出到相应的filename. pid文件中，pid是各个进程号</td></tr><tr><td>-F</td><td>尝试跟踪vfork系统调用。否则即使打开-f选项，vfork也不会被跟踪</td></tr><tr><td>-h</td><td>显示帮助信息</td></tr><tr><td>-i</td><td>显示发生系统调用时的指令指针(IP)寄存器值</td></tr><tr><td>-q</td><td>抑制(禁止输出)关于结合(attaching)、脱离(detaching)的消息。当输出重定向到一个文件时，自动抑制此类消息</td></tr><tr><td>-r</td><td>显示每个系统调用发生时的相对时间戳，即连续的系统调用起点之间的时间差</td></tr><tr><td>-t-tt-ttt</td><td>-t在每行输出前添加绝对时间戳(当前时钟)信息，精确到秒级-tt在每行输出前添加绝对时间戳信息，精确到微秒级-ttt在每行输出前添加相对时间信息，格式为”自纪元时间起经历的秒数.微秒数”</td></tr><tr><td>-T</td><td>显示每个系统调用所耗费的时间，其时间开销在输出行最右侧的尖括号内</td></tr><tr><td>-V</td><td>显示strace的版本信息</td></tr><tr><td>-v</td><td>冗余显示模式：显示系统调用中argv[]、envp[]、stat、termio(s)等数组&#x2F;结构体参数所有的元素&#x2F;成员内容。这些数组&#x2F;结构体因使用频繁，默认仅显示其元素&#x2F;成员的合理子集</td></tr><tr><td>-x</td><td>以16进制形式显示非标准(non-ascii)字符串，如”&#x2F;x08”。默认为8进制，如”&#x2F;10”</td></tr><tr><td>-xx</td><td>以16进制形式显示所有字符串</td></tr><tr><td>-a column</td><td>设置显示系统调用返回值的列位置，默认为40(从0开始)，即”&#x3D;”出现在第40列</td></tr><tr><td>-e expr</td><td>指定一个表达式，用于限定跟踪哪些事件及如何跟踪。其格式为[qualifier&#x3D;][!]all或[qualifier&#x3D;][!]value1[,value2]…。qualifier取值为trace(默认)、abbrev、verbose、raw、signal、read或write。value是用于限定的符号(包括all和none)或数字。感叹号为否定符号，如-eopen等价于-e trace&#x3D;open，表示只跟踪open系统调用；而-e trace&#x3D;!open表示跟踪除open外的其他系统调用。注意某些shell用!表示执行历史记录里的命令，此时可能借助引号、转义符号(&#x2F;)。-e trace&#x3D;set：跟踪指定的系统调用列表，如-e trace&#x3D;open,close,read,write表示只跟踪这四种系统调用。默认为set&#x3D;all。-e trace&#x3D;file：跟踪以指定文件名做参数的所有系统调用。-e trace&#x3D;process：跟踪涉及进程管理的所有系统调用，可用于观察进程的fork、wait和exec阶段。-e trace&#x3D;network：跟踪网络相关的所有系统调用。-e strace&#x3D;signal：跟踪所有与系统信号相关的系统调用。-e trace&#x3D;ipc：跟踪所有与进程间通信有关的系统调用。-e abbrev&#x3D;set：指定哪些系统调用中的大型数组或结构体内容缩减显示，如strace -e abbrev&#x3D;execve .&#x2F;test仅显示execve调用中argv[]和envp[]的部分内容。默认为abbrev&#x3D;all， abbrev&#x3D;none等价于-v选项。-e verbose&#x3D;set：指定哪些系统调用中的大型数组或结构体内容完整显示，集合外的调用其数组或结构体显示为地址。默认为verbose&#x3D;all。-e raw&#x3D;set：指定哪些系统调用中的参数以原始未解码的形式(即16进制)显示。当用户不信任strace解码或需要了解参数实际数值时有用。-e signal&#x3D;set：跟踪指定的信号列表，默认为signal&#x3D;all。如signal&#x3D;!SIGIO(或signal&#x3D;!io)表示不跟踪SIGIO信号。-e read&#x3D;set：以16进制和ASCII码对照形式显示从指定文件描述符中读出的所有数据，如-e read&#x3D;3,5可观察文件描述符3和5上的输入动作。该选项独立于系统调用read的常规跟踪(由-e trace&#x3D;read选项控制)。-e write&#x3D;set：以16进制和ASCII码对照形式显示写入指定文件描述符的所有数据。</td></tr><tr><td>-o file</td><td>strace输出信息默认显示到标准错误输出，该选项将输出信息写入文件file中。以下两条命令等效：strace -c -o test.txt .&#x2F;teststrace -c .&#x2F;test 2&gt;test.txt</td></tr><tr><td>-O overhead</td><td>Set the overhead for tracing system calls to overhead microseconds. This is useful for overriding the default heuristic for guessing how much time is spent in mere measuring when timing system calls using the -c option. The acuracy of the heuristic can be gauged by timing a given program run without tracing (使用time命令) and comparing the accumulated system call time to the total produced using -c.</td></tr><tr><td>-p pid</td><td>指定待跟踪的进程号(pid)，可用Ctrl-C终止跟踪而被跟踪进程继续运行。可指定多达32个(-p pid)选项以同时跟踪多个进程。该选项常用于调试后台进程</td></tr><tr><td>-s strsize</td><td>限制每行输出中字符串(如read参数)的最大显示长度，默认32字节。但文件名总是完整显示</td></tr><tr><td>-S sortby</td><td>按指定规则对-c选项的输出直方图进行排序。sortby取值可为time、calls、name和nothing(默认time)</td></tr><tr><td>-u username</td><td>用指定用户的UID和&#x2F;或GID身份运行待跟踪程序</td></tr><tr><td>-E var&#x3D;val</td><td>将var&#x3D;val放入命令的环境变量列表</td></tr><tr><td>-E var</td><td>从命令的环境变量列表中移除var</td></tr></tbody></table><p>   例如，命令strace -o out.txt -T -tt -e trace&#x3D;all -p 2899表示跟踪2899进程的所有系统调用，并统计系统调用的时间开销，以及调用起始时间(以可视化的时分秒格式显示)，最后将记录结果存入out.txt文件。</p><p>为便于说明，使用strace跟踪ls -l命令执行过程(<em>strace ls -l</em>)，前几行输出如下：</p><img src="./CjYTEWIpvtKAGSoOAABlhqhcv6Y927.jpg"><p>   strace记录程序所产生的每次系统调用，并以类似C的格式(无论创建该程序时使用何种编程语言)各自显示为单独的一行。每行起始为系统调用的函数名，括号内为参数，该调用的返回值则显示在等号右侧。当参数为数组或结构体时，显示其元素(方括号)或成员(花括号)内容，见execve和fstat64。当参数为bit时，使用方括号并用空格隔开每项参数，如sigprocmask(SIG_BLOCK,[CHLD TTOU],[]) &#x3D; 0，第二个参数代表信号SIGCHLD和SIGTTOU；若bit型参数全部置位，则输出如sigprocmask(SIG_UNBLOCK,~[],NULL) &#x3D; 0，此处第二个参数全部置位。</p><p>   通过使用-c选项，strace可统计分析进程所有的系统调用(<em>strace -c .&#x2F;ChangeSysTime</em>)，如：</p><img src="./CjYTEWIpvtGADnt_AADsdWmSOW0380.jpg"><p>   可看到程序调用哪些系统函数，调用次数、所耗时间及出错次数等信息，有助于分析程序运行速度瓶颈。同时注意到，settimeofday调用出错两次，而该函数在ChangeSysTime程序中被显式调用两次，亦即这两次调用均出错！但ChangeSysTime程序中并未对settimeofday调用作出错处理，故在运行中没有输出任何错误提示。假定程序源码不可修改，则此时就可借助strace找出错误所在(<em>strace -e trace&#x3D;settimeofday .&#x2F;ChangeSysTime</em>)：</p><p><em><img src="./CjYTEWIpvtGAapoaAABcI71Ftyg915.jpg"></em></p><p>   真相大白，原来调用settimeofday函数时因操作权限不够而被拒绝(需要root权限)！注意，第2、3和5行输出为ChangeSysTime程序打印输出。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tee</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/tee/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/tee/</url>
      
        <content type="html"><![CDATA[<p>Linux tee命令用于读取标准输入的数据，并将其内容输出成文件。</p><p>tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee [-ai][--help][--version][文件...]</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>-a或–append 　附加到既有文件的后面，而非覆盖它．</li><li>-i或–ignore-interrupts 　忽略中断信号。</li><li>–help 　在线帮助。</li><li>–version 　显示版本信息。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用指令”tee”将用户输入的数据同时保存到文件”file1”和”file2”中，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tee file1 file2                   #在两个文件中复制内容</span><br></pre></td></tr></table></figure><p>以上命令执行后，将提示用户输入需要保存到文件的数据，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My Linux                        #提示用户输入数据  </span><br><span class="line">My Linux                        #输出数据，进行输出反馈  </span><br></pre></td></tr></table></figure><p>此时，可以分别打开文件”file1”和”file2”，查看其内容是否均是”My Linux”即可判断指令”tee”是否执行成功。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vmstat-Report Virtual Memory Statistics</title>
      <link href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/vmstat/"/>
      <url>/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/vmstat/</url>
      
        <content type="html"><![CDATA[<p><a href="https://man7.org/linux/man-pages/man8/vmstat.8.html">https://man7.org/linux/man-pages/man8/vmstat.8.html</a><br>vmstat命令是最常见的Linux&#x2F;Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux&#x2F;Unix最喜爱的命令，一个是Linux&#x2F;Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Synopsis</span><br><span class="line"></span><br><span class="line">vmstat [-a] [-n] [-t] [-S unit] [delay [ count]]</span><br><span class="line">vmstat [-s] [-n] [-S unit]</span><br><span class="line">vmstat [-m] [-n] [delay [ count]]</span><br><span class="line">vmstat [-d] [-n] [delay [ count]]</span><br><span class="line">vmstat [-p disk partition] [-n] [delay [ count]]</span><br><span class="line">vmstat [-f]</span><br><span class="line">vmstat [-V]</span><br></pre></td></tr></table></figure><p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数</p><p>选项参数:</p><pre><code>  1) -d:　　　　　　　　显示磁盘相关统计信息。  2) -a：　　　　　　    显示活跃和非活跃内存  3) -f：　　　　　　　  显示从系统启动至今的fork数量。  4) -p：　　　　　　    显示指定磁盘分区统计信息  5) -s：　　　　　　    显示内存相关统计信息及多种系统活动数量。  6) -m：　　　　　　  显示slabinfo</code></pre><p>字段的含义</p><p>r 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。</p><p>b 表示阻塞的进程</p><p>swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。</p><p>free   空闲的物理内存的大小</p><p>buff   Linux&#x2F;Unix系统是用来存储，目录里面有什么内容，权限等的缓存</p><p>cache cache直接用来记忆我们打开的文件,给文件做缓冲</p><p>si  每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。</p><p>so  每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上</p><p>bi  块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte</p><p>bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。</p><p>in 每秒CPU的中断次数，包括时间中断</p><p>cs 每秒上下文切换次数</p><p>us 用户CPU时间</p><p>sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。</p><p>id  空闲 CPU时间</p><p>wa 等待IO CPU时间。IO等待时间百分比 wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）</p><p>st:来自于一个虚拟机偷取的CPU时间的百分比</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PERF EVENT 硬件篇续篇</title>
      <link href="/2022/10/13/01%20OS/Linux/Perf/perf_hardware2/"/>
      <url>/2022/10/13/01%20OS/Linux/Perf/perf_hardware2/</url>
      
        <content type="html"><![CDATA[<h1 id="PERF-EVENT-硬件篇续-–-core-x2F-offcore-x2F-uncore"><a href="#PERF-EVENT-硬件篇续-–-core-x2F-offcore-x2F-uncore" class="headerlink" title="PERF EVENT 硬件篇续 – core&#x2F;offcore&#x2F;uncore"></a>PERF EVENT 硬件篇续 – core&#x2F;offcore&#x2F;uncore</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上篇中，我们简单介绍 PERF EVENT 如何在硬件层面给予测量性能的能力，在这篇中我们继续针对硬件性能事件的类型做进一步介绍以理清我们日常在沟通中会遇到的一些概念。</p><p>在上篇介绍中我们介绍了三种事件捕捉实现</p><ul><li>通用事件 PMCx &amp; PERFEVETSELx</li><li>专用事件 FIXED_CTRx &amp; FIXED_CTR_CTRL</li><li>RDT<br>本片主要针对通用事件进行进一步描述</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>cpu 内部元件是分层次构成的，所以性能事件根据此来进行划分成 core&#x2F;offcore&#x2F;uncore 事件</p><h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><p>core 即是在系统中查看 &#x2F;proc&#x2F;cpuinfo 看到的最小核（逻辑核）</p><p>core 事件是最好理解的，即是跟逻辑核完全绑定的事件，如该核运行的 cycle 和 instruction 次数</p><h3 id="offcore"><a href="#offcore" class="headerlink" title="offcore"></a>offcore</h3><p>在 cpu 硬件实现上又分逻辑核和物理核，逻辑核即是物理核上进行超线程技术虚拟出来的两个核，实际上他们有一部分资源是共享的，而这部分资源被划分到 offcore</p><p>offcore 事件稍微抽象点，它是由两个（或者多个兄弟逻辑核）共享的一些事件，比如访问内存，因为在硬件上它们走的是同一个通道。本质上，它是一个 core 事件，但需要额外配置。</p><h3 id="uncore"><a href="#uncore" class="headerlink" title="uncore"></a>uncore</h3><p>在物理核的层面上又有一部分资源是物理核共享的（同时也就是 cpu socket 的概念），比如 LLC 是一个 socket 共享，这部分资源被划分为 uncore。</p><p>uncore 较为复杂，它不在是以 core 为视角采集性能事件，而是通过在共享资源如 LLC 的视角对接每个 core 设备时提供各式各样的 Box。再拿 LLC 举例子，LLC 提供若干 CBox 为每个 core 提供服务。因此 uncore 事件要建立在 CBox 元件上。如下图所示</p><p>从图中，我们可以看出 CBox 作为独立于 Core 存在的元件，是可以被所有 core 可以访问到的，基于 uncore 事件的采集因此而被全局共享。这也造成了对 uncore 事件采集的复杂度（需要单独指定 CBox）。</p><h2 id="offcore性能事件采集"><a href="#offcore性能事件采集" class="headerlink" title="offcore性能事件采集"></a>offcore性能事件采集</h2><p>了解概念后，我们如何去采集 offcore 事件呢？Intel 是否为 offcore 准备单独的计数寄存器和事件配置寄存器来处理 offcore 事件？</p><p>实际上，offcore 事件仍然复用通用事件寄存器 PMCx &amp; PERFEVETSELx，但会有一些限制（文章后会提及）。在这个基础上 Intel 在 offcore 上增加了几个（一般是两个，各个架构不同，地址也不同）名为 MSR_OFFCORE_RSPx 的寄存器，它被用来配置你需要采集的 offcore 事件。而在原有的通用事件寄存器中 PERFEVETSELx 永远配置的是相同的 event 和 umask（这两者原本用来指向 core 事件，现在被用来指向 MSR_OFFCORE_RSPx ），因为 MSR_OFFCORE_RSPx 已经帮你定义了你需要采集的事件类型。可能这样说有点不直观，我们来对比下流程</p><p>core 事件通用事件寄存器配置流程</p><ol><li>选取空闲事件寄存器id （0-3任意），选择0</li><li>配置对应的 PERFEVETSEL0，选择 core 事件 L2_RQSTS.ALL_PF，查表找到对应事件的配置，将 event 字段配置成 0x24 umask 字段配置成 0xF8</li><li>此时 PMC0 已经开始记录 L2_RQSTS.ALL_PF 事件的次数</li></ol><p>offcore 事件通用事件寄存器配置流程</p><ol><li>选取空闲事件寄存器id （0-3任意），选择0</li><li>选择空闲 MSR_OFFCORE_RSPx 来配置 offcore 事件 （0-1），选择0，其对应的 event 为 0xB7 umask 为 0x01，msr offset 为 0x1a6 （以上信息均查 Intel 手册得到）</li><li>配置对应的 PERFEVETSEL0，将 event 字段配置成 0xB7 umask 0x01</li><li>将 2 步选择的 MSR_OFFCORE_RSP0 进行配置 （之前只是选择后，配置到 PERFEVETSEL0，并未写入offcore 事件选择 ），配置 OFFCORE_RESPONSE.DEMAND_DATA_RD.L3_MISS.ANY_RESPONSE 事件，查表后得到需要将 0x3fffc00001 写入地址为 0x1a6 的 msr</li><li>此时 PMC0 已经开始记录 OFFCORE_RESPONSE.DEMAND_DATA_RD.L3_MISS.ANY_RESPONSE 事件的次数</li></ol><p>翻译成 perf 命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf stat -e cpu/event=0xB7,umask=0x01,offcore_rsp=0x3fffc00001/ /bin/ls</span><br></pre></td></tr></table></figure><p>发现该命令行与描述上存在的问题没？</p><p>它并没有指定 MSR_OFFCORE_RSP0 的 msr 地址， 经过笔者测试 event &amp; umask 作为选择子 linux 内核会发现 MSR_OFFCORE_RSP 对应 msr 地址，并且很神奇地复用有限的 MSR_OFFCORE_RSPx（上述命令指定 event&#x3D;0xBB 效果完全一致）。</p><h2 id="offcore-与-core-使用上的差异"><a href="#offcore-与-core-使用上的差异" class="headerlink" title="offcore 与 core 使用上的差异"></a>offcore 与 core 使用上的差异</h2><p>offcore 因为需要额外的配置寄存器，一般的 cpu 型号上只有两个，所以在一个物理核上一旦采集超过2个不同的事件，就会发生分时复用。</p><h2 id="uncore性能事件采集"><a href="#uncore性能事件采集" class="headerlink" title="uncore性能事件采集"></a>uncore性能事件采集</h2><p>uncore 事件采集的硬件实现与通用实现类似，都是通过一对对事件选择寄存器和事件计数寄存器来实现的。具体细节可查看 Intel 手册，这里不再赘述。</p><p>在内核接口上，uncore 性能事件已经不是原本 core 上的 pmu 设备了，所以原有的 perf 接口并不知道用户采集哪个 CBox 上的性能数据，所以 perf_event 在原有的基础上在 type 参数上进行扩展接口（换句话说 uncore 事件都是需要单独的内核驱动的）。</p><p>好在内核在 &#x2F;sys&#x2F;devices&#x2F;uncore_*&#x2F;type 文件直接暴露了该参数，在接口和工具的使用过程中，可以直接读取该文件的值，其余使用方法与 core 事件一致，下面是一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf stat -e &quot;uncore_imc_1/cas_count_read/&quot;  -a ls</span><br></pre></td></tr></table></figure><p>翻译成 perf_event_open 参数就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type=15,event=0x04,umask=0x03</span><br></pre></td></tr></table></figure><p>另外，因为 uncore 的独立性也就是所谓 per-socket 事件，采集 uncore 事件要避免相同数据重复采集</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇补全了 cpu 硬件性能事件捕捉机制的在各个层次上的事件类型，实际上本文描述的事件类型外，随着 cpu 架构的发展，Intel 又引入了 RDT 事件类型，虽然他们在软件层面都实现了 perf_event 的接口，但是在硬件层面上截然不同，从硬件实现上去了解各个事件的实现机制可以有效的理解和使用 perf 系统，以掌控系统性能的采集能力。阿里云系统组在性能采集的工作中开发了相关工具，其有效利用内核软件和硬件性能采集机制来为各个业务方提供系统性能数据，同时，降低用户使用 perf 子系统的门槛。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>PERF_EVENT 系列文章</p><p><a href="./perf_api.md">PERF EVENT API篇</a><br><a href="./perf_hardware.md">PERF EVENT 硬件篇</a><br><a href="./perf_kernel.md">PERF EVENT 内核篇</a><br><a href="./perf_hardware2.md">PERF EVENT 硬件篇续</a></p><p>参考资料<br><a href="https://web.eece.maine.edu/~vweaver/projects/perf_events/uncore/offcore_uncore.pdf">https://web.eece.maine.edu/~vweaver/projects/perf_events/uncore/offcore_uncore.pdf</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PERF EVENT 硬件篇</title>
      <link href="/2022/10/13/01%20OS/Linux/Perf/perf_hardware/"/>
      <url>/2022/10/13/01%20OS/Linux/Perf/perf_hardware/</url>
      
        <content type="html"><![CDATA[<h1 id="PERF-EVENT-硬件篇"><a href="#PERF-EVENT-硬件篇" class="headerlink" title="PERF EVENT 硬件篇"></a>PERF EVENT 硬件篇</h1><p>简介： 简介 本文将通过以 X86 为例子介绍硬件 PMU 如何为 linux kernel perf_event 子系统提供硬件性能采集功能 理解硬件 MSR （Model Specify Register） 可以理解为CPU硬件的专用寄存器，下述的所有寄存器都是这个类型 汇编指令 rdmsr&#x2F;wrm.</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文将通过以 X86 为例子介绍硬件 PMU 如何为 linux kernel perf_event 子系统提供硬件性能采集功能</p><h2 id="理解硬件"><a href="#理解硬件" class="headerlink" title="理解硬件"></a>理解硬件</h2><p>MSR （Model Specify Register）</p><p>可以理解为CPU硬件的专用寄存器，下述的所有寄存器都是这个类型</p><p>汇编指令 rdmsr&#x2F;wrmsr</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrmsr 0x38d 1234 # addr value</span><br></pre></td></tr></table></figure><p>如果是 pmc 还可以用 rdpmc 指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdpmc [0~7] # input ECX output EDX:EAX</span><br></pre></td></tr></table></figure><p>在硬件 pmu 的操作过程中大多类似以下模式</p><ol><li>写入 pmc 对应的状态 msr，决定要打开哪个硬件事件</li><li>通过读取 pmc 获取之前定义的硬件事件数值</li></ol><h3 id="PMCx-与-PERFEVTSELx"><a href="#PMCx-与-PERFEVTSELx" class="headerlink" title="PMCx 与 PERFEVTSELx"></a>PMCx 与 PERFEVTSELx</h3><p>通用事件寄存器，成对出现，由 PERFEVTSEL 配置事件，PMC 读取事件数值。在现代 x86 产品中被称之为通用 pmu 设备，一般为4个，如果关闭虚拟化可以使用8个</p><h3 id="FIXED-CTRx-与-FIXED-CTR-CTRL"><a href="#FIXED-CTRx-与-FIXED-CTR-CTRL" class="headerlink" title="FIXED_CTRx 与 FIXED_CTR_CTRL"></a>FIXED_CTRx 与 FIXED_CTR_CTRL</h3><p>专用寄存器，通过唯一的 FIXED_CTR_CTRL 来开启对应的 FIXED_CTRx。无事件控制，每个 FIXED_CTRx 只能记录对应的硬件事件</p><p>RDT （Resource Direct Tech） 是一种全新的性能采集方式，有点与上述两种寄存器有所不同，但是在软件接口上会更简洁。支持 L3 cache 相关资源使用计数</p><p>它的操作过程不用定义事件类型，只要以下步骤</p><ol><li>通过 PQR_ASSOC msr寄存器写入 rmid 就已经开始统计相关事件的计数</li><li>通过QM_EVTSEL 输入要读取的事件 id 和 rmid</li><li>最后通过 QM_CTR 即可获得数据<br>可以看出它不再以单独的CPU为维度，用户可以自定义 rmid，可以用 task，也可以用 cpuid，甚至多者混合</li></ol><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>linux 系统提供了 msr 内核模块，允许用户可以在用户态直接操作 msr</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/cpu/0/msr</span><br></pre></td></tr></table></figure><p>msr 都是 per-cpu 的设备，所以需要指定具体 cpu。 通过 lseek 来定位 msr，通过 write&#x2F;read 来读写</p><p>通过这种方式来获取 cpu 性能是 bypass 内核，同样无法利用到 perf_event 子系统提供的一系列功能，比如关联某个 task， cgroup，也无法在有限的 pmu 个数中产生分时复用</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>硬件 PMU 的实现就是提供了一系列的可操作 MSR， 通过 MSR 操作可以灵活定义要监控的内容，但是 linux kernel 中通过实现 perf_event 子系统对用户态提供了一套简洁通用的操作界面</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>PERF_EVENT 系列文章</p><p><a href="./perf_api.md">PERF EVENT API篇</a><br><a href="./perf_hardware.md">PERF EVENT 硬件篇</a><br><a href="./perf_kernel.md">PERF EVENT 内核篇</a><br><a href="./perf_hardware2.md">PERF EVENT 硬件篇续</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
