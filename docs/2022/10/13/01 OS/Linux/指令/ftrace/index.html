<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	  
<script src="/js/search.js"></script>

	<!-- title -->
	
	<title>
	
		Ftrace |
	
	LeahGe
	</title>

	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "leahge.github.io";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>


	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.4.14/dist/Valine.min.js"></script>

	
	
	<script type="text/javascript">

		var search_path = "/search.xml";
		if (search_path.length == 0) {
			search_path = "search.xml";
		}
		var path = search_path;
		searchFunc(path, 'local-search-input', 'local-search-result');
	</script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">LeahGe</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	

	

		<li class="menu-item">
			<a href="https://github.com/leahge" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
		<li class="menu-item">
			<form class="">
				<button class="btn text-muted fa fa-search d-none d-md-block d-lg-block" style="background-color: transparent;"
					disabled></button>
				<input id="local-search-input" class="form-control me-2 pe-4" type="search" aria-label="Search">
				<div id="local-search-result"
					style="position:absolute; padding-top: 8px; max-height: 960px; width: 480px;overflow-y: scroll; z-index: 1050;">
				</div>
			</form>
		</li>
	</ul>


</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 OS
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Linux
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Kernel
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/Kernel/kallsyms/">
                     
										    Kallsyms
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/31/01%20OS/Linux/Kernel/kernel_config/">
                     
										    Linux Kernel 编译选项
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Perf
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf-report/">
                     
										    Perf-Report(1) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf-script/">
                     
										    Perf-Script(1) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf-stat/">
                     
										    Perf-Stat(1)
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/28/01%20OS/Linux/Perf/perf_event/">
                     
										    PMU计数器
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_hardware/">
                     
										    PERF EVENT 硬件篇
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_hardware2/">
                     
										    PERF EVENT 硬件篇续篇
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_ipc/">
                     
										    Perf IPC以及CPU利用率
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_kernel/">
                     
										    PERF EVENT 内核篇
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/Perf/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">
                     
										    参考资料
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Shell
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Shell/ctrlc/">
                     
										    Linux Shell中捕获CTRL+C
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/Shell/stringcut/">
                     
										    Shell字符串截取
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										network
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/31/01%20OS/Linux/network/gro/">
                     
										    Linux Kernel 网络协议栈之GRO
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/network/irq/">
                     
										    网卡多队列配置和中断绑定
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/31/01%20OS/Linux/network/napi/">
                     
										    Linux协议栈--NAPI机制
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/systemd/">
                     
										    Systemd
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										指令
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/df/">
                     
										    Df(1)
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/du/">
                     
										    Du(1)
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ftrace/">
                     
										    Ftrace
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ltrace/">
                     
										    Ltrace(1) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/man_class/">
                     
										    Linux指令后的数字代表什么
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/mpstat/">
                     
										    Mpstat-Multiprocessor Statistics
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/pidstat/">
                     
										    Pidstat
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/pushd/">
                     
										    Linux 中使用 Pushd 和 Popd 命令来进行高效的目录导航
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sadc/">
                     
										    Sadc(8) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sar/">
                     
										    Sar
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sed/">
                     
										    Sed
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/strace/">
                     
										    Strace
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/tee/">
                     
										    Tee
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/vmstat/">
                     
										    Vmstat-Report Virtual Memory Statistics
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										系统调用
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/brk/">
                     
										    Brk
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/exec/">
                     
										    Exec
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/futex/">
                     
										    Futex
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/getcpu/">
                     
										    Getcpu系统调用
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/gettimeofday/">
                     
										    Gettimeofday
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/ioctl/">
                     
										    Ioctl
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/mmap/">
                     
										    Mmap
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										编译、链接和装载
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/DSO/">
                     
										    DSO(dynamic Shared Object)动态共享对象的原理
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/compile_Link/">
                     
										    Linux下编译、链接和装载
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/elf/">
                     
										    Elf文件格式
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/elfremovesymbol/">
                     
										    剥离与导回符号表及调试信息
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/">
                     
										    编译、链接和装载
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										进程
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/28/01%20OS/Linux/%E8%BF%9B%E7%A8%8B/status/">
                     
										    Linux进程状态：S 和D状态
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/%E6%9C%8D%E5%8A%A1%E5%99%A8BMC%E4%B8%8EIPMI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                     
										    服务器BMC与IPMI基础知识
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 CPU
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/14/02%20CPU/SocketNodeDieCoreProcessor/">
                     
										    Socket/Node/Die/Core/Processor/Package
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/02%20CPU/%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95/">
                     
										    技术发展
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										12 Python
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/14/12%20Python/Gunicorn_manual/">
                     
										    Gunicorn的使用手册
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										50 soft
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Nodejs
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/14/50%20soft/Nodejs/npm/">
                     
										    Npm
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										99 Other
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/99%20Other/%E5%9B%BE%E7%81%B5%E6%9C%BA%E4%B8%8E%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/">
                     
										    图灵机与图灵完备
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/ebook/">
                     
										    99 Ebook
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										优化
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 CPU
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-1%20%E4%B8%BB%E9%A2%91/">
                     
										    03-1 主频
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-2%20%E9%A2%84%E5%8F%96/">
                     
										    03-2 预取
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-3%20%E4%BA%B2%E5%92%8C%E6%80%A7/">
                     
										    03-3 亲和性
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-4%20%E7%8B%AC%E5%8D%A0/">
                     
										    03-4 独占
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-5%20Time%20Tick%E4%B8%AD%E6%96%AD/">
                     
										    03-5 Time Tick中断
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-6%20RCB/">
                     
										    03-6 RCB
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-7%20%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7/">
                     
										    03-7 调度优先级
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-8%20%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">
                     
										    03-8 中断负载均衡
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 内存
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/01%20%E5%8E%9F%E7%90%86/">
                     
										    01 原理
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/02%20%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/">
                     
										    02 监控工具
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-1%E5%86%85%E5%AD%98%E6%9D%A1%E9%80%89%E6%8B%A9/">
                     
										    03-1内存条选择
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-2%E5%86%85%E6%A0%B8%E5%8F%AF%E8%B0%83%E5%8F%82%E6%95%B0/">
                     
										    03-2内核可调参数
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-3%20%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F/">
                     
										    03-3 页面大小
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-4%20%E9%81%BF%E5%85%8D%E8%B7%A8numa%E8%AE%BF%E5%AD%98/">
                     
										    03-4 避免跨numa访存
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>
	<!-- 引入正文 -->
	<div id="content">
		<div id="local-search-result"></div>
		<h1 id="article-title">
	Ftrace
</h1>
<div class="article-meta">
	
	<span>Leah Ge</span>
	<span>2022-10-13 20:18:51</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<h2 id="Linux-ftrace框架介绍及运用"><a href="#Linux-ftrace框架介绍及运用" class="headerlink" title="Linux ftrace框架介绍及运用"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/7211249.html">Linux ftrace框架介绍及运用</a></h2><p>目录：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/7211249.html#ftrace_background">1. ftrace背景</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/7211249.html#ftrace_framework">2. 框架介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/7211249.html#ftrace_code_analyze">3. 主要代码分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/7211249.html#ftrace_setting">4. ftrace的配置和使用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/7211249.html#ftrace_tools">5. ftrace相关工具</a></p>
<p>在日常工作中，经常会需要对内核进行Debug、或者进行优化工作。一些简单的问题，可以通过dmesg&#x2F;printk查看，优化借助一些工具进行。</p>
<p>但是当问题逻辑复杂，优化面宽泛的时候，往往无从下手。</p>
<p>需要从上到下、模块到模块之间分析，这时候就不得不借助于Linux提供的静态(Trace Event)动态(各种Tracer)进行分析。</p>
<p>同时还不得不借助工具、或者编写脚本进行分析，以缩小问题范围、发现问题。</p>
<p>简单的使用Tracepoint已经不能满足需求，因此就花点精力进行梳理。</p>
<h1 id="1-ftrace背景"><a href="#1-ftrace背景" class="headerlink" title="1. ftrace背景"></a>1. ftrace背景</h1><p>ftrace是Function Trace的意思，最开始主要用于记录内核函数运行轨迹；随着功能的逐渐增加，演变成一个跟踪框架。</p>
<p>包含了静态tracepoint，针对不同subsystem提供一个目录进行开关；还包括不同的动态跟踪器，function、function_graph、wakeup等等。</p>
<p>ftrace的帮助文档在<a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.4.110/source/Documentation/trace">Documentation&#x2F;trace</a>，ftrace代码主要在<a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.4.110/source/kernel/trace">kernel&#x2F;trace</a>，ftrace相关头文件在<a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.4.110/source/include/trace">include&#x2F;trace</a>中。</p>
<p>WiKiPedia有关于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ftrace">ftrace</a>的简单介绍。</p>
<p>ftrace的作者在LinuxCon 2010有一篇关于**<a target="_blank" rel="noopener" href="https://events.static.linuxfound.org/slides/2010/linuxcon_japan/linuxcon_jp2010_rostedt.pdf">Ftrace Linux Kernel Tracing</a>**的slides值得一读。</p>
<h1 id="2-ftrace框架介绍"><a href="#2-ftrace框架介绍" class="headerlink" title="2. ftrace框架介绍"></a>2. ftrace框架介绍</h1><p>整个ftrace框架可以分为几部分：ftrace核心框架，RingBuffer，debugfs，Tracepoint，各种Tracer。</p>
<p>ftrace框架是整个ftrace功能的纽带，包括对内和的修改，Tracer的注册，RingBuffer的控制等等。</p>
<p>RingBuffer是静态动态ftrace的载体。</p>
<p>debugfs则提供了用户空间对ftrace设置接口。</p>
<p>Tracepoint是静态trace，他需要提前编译进内核;可以定制打印内容，自由添加;并且内核对主要subsystem提供了Tracepoint。</p>
<p>Tracer有很多种，主要几大类：</p>
<blockquote>
<p>函数类：function， function_graph， stack</p>
<p>延时类：irqsoff， preemptoff， preemptirqsoff， wakeup， wakeup_rt， waktup_dl</p>
<p>其他类：nop， mmiotrace， blk</p>
</blockquote>
<p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/image001.jpg" alt="ftrace 组成"></p>
<h2 id="2-1-ftrace核心初始化"><a href="#2-1-ftrace核心初始化" class="headerlink" title="2.1 ftrace核心初始化"></a>2.1 ftrace核心初始化</h2><p> trace.c是ftrace的核心，包括三个initcall：tracer_alloc_buffers、trace_init_debugfs、clear_boot_tracer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">start_kernel--&gt;</span><br><span class="line">    trace_init--&gt;</span><br><span class="line">        tracer_alloc_buffers--------------------分配ftrace需要的RingBuffer</span><br><span class="line">            register_tracer(&amp;nop_trace)---------默认nop跟踪器</span><br><span class="line">        trace_event_init------------------------创建静态Trace Event，进行初始化。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs_initcall(tracer_init_debugfs);--&gt;</span><br><span class="line">    tracing_init_dentry--------------------------在sys/kernel/debug下，创建tracing目录</span><br><span class="line">    init_tracer_debugfs--------------------------</span><br><span class="line">        ftrace_create_function_files-------------创建主要的tracing目录下节点</span><br><span class="line">            allocate_ftrace_ops------------------function_trace_call</span><br><span class="line">            ftrace_create_filter_files-----------创建function tracer相关的节点set_ftrace_filter/set_ftrace_notrace</span><br><span class="line">    trace_create_file----------------------------创建saved_cmdlines等</span><br><span class="line">    create_trace_instances-----------------------创建tracing/instances/目录</span><br><span class="line">    create_trace_options_dir---------------------创建tracing/optoins/目录</span><br><span class="line">    tracing_init_debugfs_percpu------------------创建per_cpu目录</span><br><span class="line">late_initcall(clear_boot_tracer);</span><br></pre></td></tr></table></figure>



<p> tracer_alloc_buffers主要申请一个最小1KB的RingBuffer，然后注册一些Notifier和初始化一些列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">__init static int tracer_alloc_buffers(void)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    /* To save memory, keep the ring buffer size to its minimum */</span><br><span class="line">    if (ring_buffer_expanded)----------------------------------------------在初始化的时候，分配一个最小量</span><br><span class="line">        ring_buf_size = trace_buf_size;</span><br><span class="line">    else</span><br><span class="line">        ring_buf_size = 1;</span><br><span class="line">...</span><br><span class="line">    /* TODO: make the number of buffers hot pluggable with CPUS */</span><br><span class="line">    if (allocate_trace_buffers(&amp;global_trace, ring_buf_size) &lt; 0) &#123;--------分配RingBuffer内存</span><br><span class="line">        printk(KERN_ERR &quot;tracer: failed to allocate ring buffer!\n&quot;);</span><br><span class="line">        WARN_ON(1);</span><br><span class="line">        goto out_free_savedcmd;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    /*</span><br><span class="line">     * register_tracer() might reference current_trace, so it</span><br><span class="line">     * needs to be set before we register anything. This is</span><br><span class="line">     * just a bootstrap of current_trace anyway.</span><br><span class="line">     */</span><br><span class="line">    global_trace.current_trace = &amp;nop_trace;----------------------------默认nop跟踪器</span><br><span class="line"></span><br><span class="line">    global_trace.max_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;</span><br><span class="line"></span><br><span class="line">    ftrace_init_global_array_ops(&amp;global_trace);</span><br><span class="line"></span><br><span class="line">    register_tracer(&amp;nop_trace);----------------------------------------注册nop跟踪器</span><br><span class="line"></span><br><span class="line">    /* All seems OK, enable tracing */</span><br><span class="line">    tracing_disabled = 0;</span><br><span class="line"></span><br><span class="line">    atomic_notifier_chain_register(&amp;panic_notifier_list,</span><br><span class="line">                       &amp;trace_panic_notifier);</span><br><span class="line"></span><br><span class="line">    register_die_notifier(&amp;trace_die_notifier);</span><br><span class="line"></span><br><span class="line">    global_trace.flags = TRACE_ARRAY_FL_GLOBAL;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;global_trace.systems);</span><br><span class="line">    INIT_LIST_HEAD(&amp;global_trace.events);</span><br><span class="line">    list_add(&amp;global_trace.list, &amp;ftrace_trace_arrays);</span><br><span class="line"></span><br><span class="line">    while (trace_boot_options) &#123;</span><br><span class="line">        char *option;</span><br><span class="line"></span><br><span class="line">        option = strsep(&amp;trace_boot_options, &quot;,&quot;);</span><br><span class="line">        trace_set_options(&amp;global_trace, option);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    register_snapshot_cmd();------------------------------------------创建snapshot节点</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-2-trace-event"><a href="#2-2-trace-event" class="headerlink" title="2.2 trace event"></a>2.2 trace event</h2><p> 在trace_init–&gt;trace_event_init–&gt;event_trace_enable中，已经创建了tracing&#x2F;events下的节点，并且做好了准备工作。</p>
<p>event_trace_enable被初次调用的地方很靠前，甚至在pid 1之前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void __init trace_event_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    event_trace_memsetup();------------------------------------------创建field_cachep、file_cachep高速缓存</span><br><span class="line">    init_ftrace_syscalls();------------------------------------------对所有系统调用如后保存在syscalls_metadata</span><br><span class="line">    event_trace_enable();--------------------------------------------在系统启动阶段初始化Trace Event，在debug创建后在附着到上面</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static __init int event_trace_enable(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct trace_array *tr = top_trace_array();</span><br><span class="line">    struct ftrace_event_call **iter, *call;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    if (!tr)</span><br><span class="line">        return -ENODEV;</span><br><span class="line"></span><br><span class="line">    for_each_event(iter, __start_ftrace_events, __stop_ftrace_events) &#123;----------遍历所有的Events，放入ftrace_events链表</span><br><span class="line"></span><br><span class="line">        call = *iter;</span><br><span class="line">        ret = event_init(call);</span><br><span class="line">        if (!ret)</span><br><span class="line">            list_add(&amp;call-&gt;list, &amp;ftrace_events);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We need the top trace array to have a working set of trace</span><br><span class="line">     * points at early init, before the debug files and directories</span><br><span class="line">     * are created. Create the file entries now, and attach them</span><br><span class="line">     * to the actual file dentries later.</span><br><span class="line">     */</span><br><span class="line">    __trace_early_add_events(tr);</span><br><span class="line"></span><br><span class="line">    early_enable_events(tr, false);</span><br><span class="line"></span><br><span class="line">    trace_printk_start_comm();</span><br><span class="line"></span><br><span class="line">    register_event_cmds();--------------------------------------------------------注册enable_event、disable_event两个命令</span><br><span class="line"></span><br><span class="line">    register_trigger_cmds();------------------------------------------------------注册traceon、traceoff、snapshot等命令</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>其他Events相关初始化如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">early_initcall(event_trace_enable_again);----------在trace_event_init已经调用过early_enable_events，这里在early_initcall再次使能。</span><br><span class="line"></span><br><span class="line">fs_initcall(event_trace_init);---------------------创建available_events节点</span><br></pre></td></tr></table></figure>


<h2 id="2-3-function跟踪器"><a href="#2-3-function跟踪器" class="headerlink" title="2.3 function跟踪器"></a>2.3 function跟踪器</h2><p>function tracer的初始化通过init_function_trace建立。</p>
<p><code>core_initcall(init_function_trace);</code></p>
<p>init_function_trace在init_func_cmd_traceon中，创建了一系列命令：traceon&#x2F;traceoff&#x2F;stacktrace&#x2F;dump&#x2F;cpudump。然后是注册function_trace这个tracer。</p>
<p>Tracer结构体如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static struct tracer function_trace __tracer_data =</span><br><span class="line">&#123;</span><br><span class="line">    .name        = &quot;function&quot;,</span><br><span class="line">    .init        = function_trace_init,--------------通过echo function &gt; current_tracer触发</span><br><span class="line">    .reset        = function_trace_reset,------------通过echo 1 &gt;tracing_on触发</span><br><span class="line">    .start        = function_trace_start,------------通过echo 0 &gt;tracing_off触发</span><br><span class="line">    .flags        = &amp;func_flags,</span><br><span class="line">    .set_flag    = func_set_flag,</span><br><span class="line">    .allow_instances = true,</span><br><span class="line">#ifdef CONFIG_FTRACE_SELFTEST</span><br><span class="line">    .selftest    = trace_selftest_startup_function,</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> function_trace_init进行function tracer相关设置。</p>
<h2 id="2-4-function-graph跟踪器"><a href="#2-4-function-graph跟踪器" class="headerlink" title="2.4 function_graph跟踪器"></a>2.4 function_graph跟踪器</h2><p>注册function_graph跟踪器，创建max_graph_depth节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static struct tracer graph_trace __tracer_data = &#123;</span><br><span class="line">    .name        = &quot;function_graph&quot;,</span><br><span class="line">    .update_thresh    = graph_trace_update_thresh,</span><br><span class="line">    .open        = graph_trace_open,</span><br><span class="line">    .pipe_open    = graph_trace_open,</span><br><span class="line">    .close        = graph_trace_close,</span><br><span class="line">    .pipe_close    = graph_trace_close,</span><br><span class="line">    .init        = graph_trace_init,</span><br><span class="line">    .reset        = graph_trace_reset,</span><br><span class="line">    .print_line    = print_graph_function,</span><br><span class="line">    .print_header    = print_graph_headers,</span><br><span class="line">    .flags        = &amp;tracer_flags,</span><br><span class="line">    .set_flag    = func_graph_set_flag,</span><br><span class="line">#ifdef CONFIG_FTRACE_SELFTEST</span><br><span class="line">    .selftest    = trace_selftest_startup_function_graph,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct file_operations graph_depth_fops = &#123;</span><br><span class="line">    .open        = tracing_open_generic,</span><br><span class="line">    .write        = graph_depth_write,</span><br><span class="line">    .read        = graph_depth_read,</span><br><span class="line">    .llseek        = generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static __init int init_graph_debugfs(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct dentry *d_tracer;</span><br><span class="line"></span><br><span class="line">    d_tracer = tracing_init_dentry();</span><br><span class="line">    if (IS_ERR(d_tracer))</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    trace_create_file(&quot;max_graph_depth&quot;, 0644, d_tracer,</span><br><span class="line">              NULL, &amp;graph_depth_fops);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(init_graph_debugfs);</span><br><span class="line"></span><br><span class="line">static __init int init_graph_trace(void)</span><br><span class="line">&#123;</span><br><span class="line">    max_bytes_for_cpu = snprintf(NULL, 0, &quot;%d&quot;, nr_cpu_ids - 1);</span><br><span class="line"></span><br><span class="line">    if (!register_ftrace_event(&amp;graph_trace_entry_event)) &#123;</span><br><span class="line">        pr_warning(&quot;Warning: could not register graph trace events\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!register_ftrace_event(&amp;graph_trace_ret_event)) &#123;</span><br><span class="line">        pr_warning(&quot;Warning: could not register graph trace events\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return register_tracer(&amp;graph_trace);--------------------------------------注册function_graph跟踪器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">core_initcall(init_graph_trace);</span><br></pre></td></tr></table></figure>





<h2 id="2-5-irqoff-x2F-preemptoff-x2F-preemptirqoff跟踪器"><a href="#2-5-irqoff-x2F-preemptoff-x2F-preemptirqoff跟踪器" class="headerlink" title="2.5 irqoff&#x2F;preemptoff&#x2F;preemptirqoff跟踪器"></a>2.5 irqoff&#x2F;preemptoff&#x2F;preemptirqoff跟踪器</h2><p>irqoff&#x2F;preemptoff&#x2F;preemptirqoff：注册irqsoff、preemptoff、preemptirqsoff三个跟踪器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core_initcall(init_irqsoff_tracer);</span><br></pre></td></tr></table></figure>

<h2 id="2-6-wakeup跟踪器"><a href="#2-6-wakeup跟踪器" class="headerlink" title="2.6 wakeup跟踪器"></a>2.6 wakeup跟踪器</h2><p>注册wakeup、wakeup_rt、wakeup_dl三个跟踪器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core_initcall(init_wakeup_tracer);</span><br></pre></td></tr></table></figure>

<h2 id="2-7-mmiotrace跟踪器"><a href="#2-7-mmiotrace跟踪器" class="headerlink" title="2.7 mmiotrace跟踪器"></a>2.7 mmiotrace跟踪器</h2><p>mmiotrace：注册mmiotrace跟踪器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(init_mmio_trace);</span><br></pre></td></tr></table></figure>

<h2 id="2-8-branch跟踪器"><a href="#2-8-branch跟踪器" class="headerlink" title="2.8 branch跟踪器"></a>2.8 branch跟踪器</h2><p>branch：注册branch跟踪器，和branch_annotated、branch_all两个统计信息跟踪器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">core_initcall(init_branch_tracer);</span><br><span class="line">fs_initcall(init_annotated_branch_stats);</span><br><span class="line">fs_initcall(all_annotated_branch_stats);</span><br></pre></td></tr></table></figure>

<h2 id="2-9-blk跟踪器"><a href="#2-9-blk跟踪器" class="headerlink" title="2.9 blk跟踪器"></a>2.9 blk跟踪器</h2><p>blk：注册blk跟踪器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(init_blk_tracer);</span><br></pre></td></tr></table></figure>



<p> trace_printk：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs_initcall(init_trace_printk_function_export);</span><br><span class="line">early_initcall(init_trace_printk);</span><br></pre></td></tr></table></figure>





<p> stack_trace：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(stack_trace_init);</span><br></pre></td></tr></table></figure>



<p>kprobe&#x2F;upbobe：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs_initcall(init_kprobe_trace);</span><br><span class="line">fs_initcall(init_uprobe_trace);</span><br></pre></td></tr></table></figure>



<h1 id="3-主要代码分析"><a href="#3-主要代码分析" class="headerlink" title="3. 主要代码分析"></a>3. 主要代码分析</h1><h2 id="3-1-内核模块初始化顺序"><a href="#3-1-内核模块初始化顺序" class="headerlink" title="3.1 内核模块初始化顺序"></a>3.1 内核模块初始化顺序</h2><p>内核中不同功能需要有序初始化，但是相同等级的顺序是没有保证的。</p>
<p>Linux ftrace相关的模块众多，使用了不同等级的initcall。</p>
<p>从下面的定义可以看出他们在内核启动时的调用顺序，模块等级在include&#x2F;linux&#x2F;init.h中定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#define __define_initcall(level,fn,id) \</span><br><span class="line">    static initcall_t __initcall_##fn##id __used \</span><br><span class="line">    __attribute__((__section__(&quot;.initcall&quot; level &quot;.init&quot;))) = fn</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Early initcalls run before initializing SMP.</span><br><span class="line"> *</span><br><span class="line"> * Only for built-in code, not modules.</span><br><span class="line"> */</span><br><span class="line">#define early_initcall(fn)        __define_initcall(&quot;early&quot;,fn,early)--------------------所谓的early就是在初始化SMP之前调用</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * A &quot;pure&quot; initcall has no dependencies on anything else, and purely</span><br><span class="line"> * initializes variables that couldn&#x27;t be statically initialized.</span><br><span class="line"> *</span><br><span class="line"> * This only exists for built-in code, not for modules.</span><br><span class="line"> */</span><br><span class="line">#define pure_initcall(fn)        __define_initcall(&quot;0&quot;,fn,0)</span><br><span class="line"></span><br><span class="line">#define core_initcall(fn)        __define_initcall(&quot;1&quot;,fn,1)</span><br><span class="line">#define core_initcall_sync(fn)        __define_initcall(&quot;1s&quot;,fn,1s)</span><br><span class="line">#define postcore_initcall(fn)        __define_initcall(&quot;2&quot;,fn,2)</span><br><span class="line">#define postcore_initcall_sync(fn)    __define_initcall(&quot;2s&quot;,fn,2s)</span><br><span class="line">#define arch_initcall(fn)        __define_initcall(&quot;3&quot;,fn,3)</span><br><span class="line">#define arch_initcall_sync(fn)        __define_initcall(&quot;3s&quot;,fn,3s)</span><br><span class="line">#define subsys_initcall(fn)        __define_initcall(&quot;4&quot;,fn,4)</span><br><span class="line">#define subsys_initcall_sync(fn)    __define_initcall(&quot;4s&quot;,fn,4s)</span><br><span class="line">#define fs_initcall(fn)            __define_initcall(&quot;5&quot;,fn,5)</span><br><span class="line">#define fs_initcall_sync(fn)        __define_initcall(&quot;5s&quot;,fn,5s)</span><br><span class="line">#define rootfs_initcall(fn)        __define_initcall(&quot;rootfs&quot;,fn,rootfs)</span><br><span class="line">#define device_initcall(fn)        __define_initcall(&quot;6&quot;,fn,6)----------------------------对应module_init</span><br><span class="line">#define device_initcall_sync(fn)    __define_initcall(&quot;6s&quot;,fn,6s)</span><br><span class="line">#define late_initcall(fn)        __define_initcall(&quot;7&quot;,fn,7)</span><br><span class="line">#define late_initcall_sync(fn)        __define_initcall(&quot;7s&quot;,fn,7s)</span><br></pre></td></tr></table></figure>





<h2 id="3-2-ftrace初始化"><a href="#3-2-ftrace初始化" class="headerlink" title="3.2 ftrace初始化"></a>3.2 ftrace初始化</h2><h2 id="3-3-RingBuffer"><a href="#3-3-RingBuffer" class="headerlink" title="3.3 RingBuffer"></a>3.3 RingBuffer</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="4-ftrace的配置和使用"><a href="#4-ftrace的配置和使用" class="headerlink" title="4. ftrace的配置和使用"></a>4. ftrace的配置和使用</h1><p>&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing目录下提供了ftrace的设置和属性接口，对ftrace的配置可以通过echo。了解每个文件的作用和如何设置对于理解整个ftrace框架很有作用。</p>
<p>下面是Ubuntu 16.04+Kernel 4.10.0-42-generic的&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">README------------------------一个简单的关于Tracepoing的HOWTO，cat读取，echo设置。</span><br><span class="line"></span><br><span class="line">通用配置：</span><br><span class="line">available_tracers-------------当前编译及内核的跟踪器列表，current_tracer必须是这里面支持的跟踪器。</span><br><span class="line">current_tracer----------------用于设置或者显示当前使用的跟踪器列表。系统启动缺省值为nop，使用echo将跟踪器名字写入即可打开。可以通过写入nop重置跟踪器。</span><br><span class="line">buffer_size_kb----------------用于设置单个CPU所使用的跟踪缓存的大小。跟踪缓存为RingBuffer形式，如果跟踪太多，旧的信息会被新的跟踪信息覆盖掉。需要先将current_trace设置为nop才可以。</span><br><span class="line">buffer_total_size_kb----------显示所有的跟踪缓存大小，不同之处在于buffer_size_kb是单个CPU的，buffer_total_size_kb是所有CPU的和。</span><br><span class="line"></span><br><span class="line">free_buffer-------------------此文件用于在一个进程被关闭后，同时释放RingBuffer内存，并将调整大小到最小值。</span><br><span class="line">hwlat_detector/</span><br><span class="line">instances/--------------------创建不同的trace buffer实例，可以在不同的trace buffers中分开记录。</span><br><span class="line">tracing_cpumask---------------可以通过此文件设置允许跟踪特定CPU，二进制格式。</span><br><span class="line">per_cpu-----------------------CPU相关的trace信息，包括stats、trace、trace_pipe和trace_pipe_raw。</span><br><span class="line">　　　　　　　　　　　　　　　　　　stats：当前CPU的trace统计信息</span><br><span class="line">　　　　　　　　　　　　　　　　　　trace：当前CPU的trace文件。</span><br><span class="line">　　　　　　　　　　　　　　　　　　trace_pipe：当前CPU的trace_pipe文件。</span><br><span class="line">printk_formats----------------提供给工具读取原始格式trace的文件。</span><br><span class="line">saved_cmdlines----------------存放pid对应的comm名称作为ftrace的cache，这样ftrace中不光能显示pid还能显示comm。</span><br><span class="line">saved_cmdlines_size-----------saved_cmdlines的数目</span><br><span class="line">snapshot----------------------是对trace的snapshot。</span><br><span class="line">                              echo 0清空缓存，并释放对应内存。</span><br><span class="line">                              echo 1进行对当前trace进行snapshot，如没有内存则分配。</span><br><span class="line">                              echo 2清空缓存，不释放也不分配内存。</span><br><span class="line">trace-------------------------查看获取到的跟踪信息的接口，echo &gt; trace可以清空当前RingBuffer。</span><br><span class="line">trace_pipe--------------------输出和trace一样的内容，但是此文件输出Trace同时将RingBuffer中的内容删除，这样就避免了RingBuffer的溢出。可以通过cat trace_pipe &gt; trace.txt &amp;保存文件。</span><br><span class="line">trace_clock-------------------显示当前Trace的timestamp所基于的时钟，默认使用local时钟。local：默认时钟；可能无法在不同CPU间同步；global：不同CUP间同步，但是可能比local慢；counter：这是一个跨CPU计数器，需要分析不同CPU间event顺序比较有效。</span><br><span class="line">trace_marker------------------从用户空间写入标记到trace中，用于用户空间行为和内核时间同步。</span><br><span class="line">trace_marker_raw--------------以二进制格式写入到trace中。</span><br><span class="line">trace_options-----------------控制Trace打印内容或者操作跟踪器，可以通过trace_options添加很多附加信息。</span><br><span class="line">options-----------------------trace选项的一系列文件，和trace_options对应。</span><br><span class="line">trace_stat/-------------------每个CPU的Trace统计信息</span><br><span class="line">tracing_max_latency-----------记录Tracer的最大延时，</span><br><span class="line">tracing_on--------------------用于控制跟踪打开或停止，0停止跟踪，1继续跟踪。</span><br><span class="line">tracing_thresh----------------延时记录Trace的阈值，当延时超过此值时才开始记录Trace。单位是ms，只有非0才起作用。</span><br><span class="line"></span><br><span class="line">Events配置：</span><br><span class="line">available_events--------------列出系统中所有可用的Trace events，分两个层级，用冒号隔开。</span><br><span class="line">events/-----------------------系统Trace events目录，在每个events下面都有enable、filter和fotmat。enable是开关；format是events的格式，然后根据格式设置 filter。</span><br><span class="line">set_event---------------------将Trace events名称直接写入set_event就可以打开。</span><br><span class="line">set_event_pid-----------------指定追踪特定进程的events。</span><br><span class="line"></span><br><span class="line">Function配置：</span><br><span class="line">available_filter_functions----记录了当前可以跟踪的内核函数，不在该文件中列出的函数，无法跟踪其活动。</span><br><span class="line">dyn_ftrace_total_info---------显示available_filter_functins中跟中函数的数目，两者一致。</span><br><span class="line">enabled_functions-------------显示有回调附着的函数名称。</span><br><span class="line">function_profile_enabled------打开此选项，在trace_stat中就会显示function的统计信息。</span><br><span class="line">set_ftrace_filter-------------用于显示指定要跟踪的函数</span><br><span class="line">set_ftrace_notrace------------用于指定不跟踪的函数，缺省为空。</span><br><span class="line">set_ftrace_pid----------------用于指定要追踪特定进程的函数。</span><br><span class="line"></span><br><span class="line">Function graph配置：</span><br><span class="line">max_graph_depth---------------函数嵌套的最大深度。</span><br><span class="line">set_graph_function------------设置要清晰显示调用关系的函数，在使用function_graph跟踪器是使用，缺省对所有函数都生成调用关系。</span><br><span class="line">set_graph_notrace-------------不跟踪特定的函数嵌套调用。</span><br><span class="line"></span><br><span class="line">Stack trace设置：</span><br><span class="line">stack_max_size----------------当使用stack跟踪器时，记录产生过的最大stack size</span><br><span class="line">stack_trace-------------------显示stack的back trace</span><br><span class="line">stack_trace_filter------------设置stack tracer不检查的函数名称</span><br><span class="line"></span><br><span class="line">Kernel dynamic events:</span><br><span class="line">kprobe_events</span><br><span class="line">kprobe_profile</span><br><span class="line"></span><br><span class="line">Userspace dynamic events:</span><br><span class="line">uprobe_events</span><br><span class="line">uprobe_profile</span><br></pre></td></tr></table></figure>







<h2 id="4-1-通用配置"><a href="#4-1-通用配置" class="headerlink" title="4.1 通用配置"></a>4.1 通用配置</h2><h3 id="使能和配置大小"><a href="#使能和配置大小" class="headerlink" title="使能和配置大小"></a>使能和配置大小</h3><p>常用的配置有对Trace的开关(tracing_on)</p>
<blockquote>
<p>echo 0&#x2F;1 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;tracing_on</p>
</blockquote>
<p>设置RingBuffer大小(buffer_size_kb),同时buffer_total_size_kb就变成NR_CPUS的倍数。</p>
<h3 id="trace、trace-pipe和snapshot的区别？"><a href="#trace、trace-pipe和snapshot的区别？" class="headerlink" title="trace、trace_pipe和snapshot的区别？"></a><strong>trace、trace_pipe和snapshot的区别？</strong></h3><p>trace是从RingBuffer中取出内容，trace_pipe会一直读取Buffer流。</p>
<p>snapshot是trace的一个瞬间快照：</p>
<blockquote>
<p>echo 0 &gt; snapshot : Clears and frees snapshot buffer<br>echo 1 &gt; snapshot : Allocates snapshot buffer, if not already allocated.<br>           Takes a snapshot of the main buffer.<br>echo 2 &gt; snapshot : Clears snapshot buffer (but does not allocate or free)<br>           (Doesn’t have to be ‘2’ works with any number that<br>            is not a ‘0’ or ‘1’)</p>
</blockquote>
<h3 id="Tracer"><a href="#Tracer" class="headerlink" title="Tracer"></a><strong>Tracer</strong></h3><p>从available_tracers可以获取系统支持的Tracer,current_tracer是当前使用中的Tracer。</p>
<p>Events只有在nop tracer下才会起作用，同时多个tracer不能共享。同一时候只能一个Tracer在生效。</p>
<blockquote>
<p>cat available_tracers</p>
<p><em>hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function nop</em></p>
<p>echo function &gt; current_tracer</p>
</blockquote>
<h3 id="instances"><a href="#instances" class="headerlink" title="instances"></a><strong>instances</strong></h3><p>在instances目录下，可以通过mkdir创建instance，rmdir删除instance。</p>
<p>新目录下，有很多类似tracing下的文件，可以对其进行配置。然后读取专有的trace&#x2F;trace_pipe。</p>
<blockquote>
<p>mkdir foo</p>
<p>ls foo</p>
<p><em>available_tracers   options       set_ftrace_pid  trace_options<br>buffer_size_kb    per_cpu       snapshot     trace_pipe<br>buffer_total_size_kb set_event      trace       tracing_cpumask<br>current_tracer    set_event_pid    trace_clock    tracing_max_latency<br>events        set_ftrace_filter  trace_marker   tracing_on<br>free_buffer      set_ftrace_notrace trace_marker_raw</em></p>
<p>rmdir foo</p>
</blockquote>
<h3 id="特定CPU信息"><a href="#特定CPU信息" class="headerlink" title="特定CPU信息"></a>特定CPU信息</h3><p>抓取特定CPU信息0~3：</p>
<blockquote>
<p>echo f &gt; tracing_cpumask</p>
</blockquote>
<p>查看特定CPU信息：</p>
<blockquote>
<p>cat per_cpu&#x2F;cpu3&#x2F;trace</p>
</blockquote>
<h3 id="用户空间插入Trace标记"><a href="#用户空间插入Trace标记" class="headerlink" title="用户空间插入Trace标记"></a>用户空间插入Trace标记</h3><p>有时候需要往Trace中插入标记，trace_marker&#x2F;trace_marker_raw提供了这样功能。</p>
<blockquote>
<p>echo CAPTURE_START &gt; trace_marker</p>
<p>echo CAPTURE_START &gt; trace_marker_raw</p>
</blockquote>
<h3 id="Trace选项设置"><a href="#Trace选项设置" class="headerlink" title="Trace选项设置"></a>Trace选项设置</h3><p>通过options内容设置，对Trace的输出进行定制，控制输出大小。</p>
<p>trace_option是options设置的结果，可以看出开了哪些选项，关闭了哪些选项。</p>
<blockquote>
<p>echo 0&#x2F;1 &gt; options&#x2F;irq-info</p>
</blockquote>
<h2 id="4-2-Tracepoint"><a href="#4-2-Tracepoint" class="headerlink" title="4.2 Tracepoint"></a>4.2 Tracepoint</h2><p>可以对系统特定事件进行跟踪，在available_events可以找到所有事件。然后将需要的时间通过echo xxx &gt;&gt; set_event写入。也可以通过events目录来打开。</p>
<h3 id="4-2-1-Trace-Events生效条件"><a href="#4-2-1-Trace-Events生效条件" class="headerlink" title="4.2.1 Trace Events生效条件"></a>4.2.1 Trace Events生效条件</h3><p>在current_tracer为nop，然后设置tracing&#x2F;events下面的enable，即可通过tracing&#x2F;trace或者tracing&#x2F;trace_pipe查看内容。</p>
<h3 id="4-2-2-Trace-Events的过滤功能？"><a href="#4-2-2-Trace-Events的过滤功能？" class="headerlink" title="4.2.2 Trace Events的过滤功能？"></a>4.2.2 Trace Events的过滤功能？</h3><h4 id="对特定Events的过滤，只打开需要监控的Events。"><a href="#对特定Events的过滤，只打开需要监控的Events。" class="headerlink" title="对特定Events的过滤，只打开需要监控的Events。"></a>对特定Events的过滤，只打开需要监控的Events。</h4><p>如果要禁用某个时间在事件前加上！，如echo “!sys_enter_nic” &gt;&gt; set_event。</p>
<blockquote>
<p>echo net &gt;set_event——————————–打开所有net目录下的事件</p>
<p>echo skb &gt;&gt;set_event——————————附加设置skb到目录下</p>
</blockquote>
<p>过滤的表达式是：field-name relational-operator value，多表达式可以通过逻辑运算符&amp;&amp;或者||来组合。</p>
<p>数字可以通过&#x3D;&#x3D;、！&#x3D;、&gt;、&lt;、&amp;&amp;、||等等来组合filter，来过滤掉很多不需要信息。</p>
<p>文字可以通过&#x3D;&#x3D;、!&#x3D;、~l来组合filter。</p>
<p>如针对timer_start事件的Trace：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># tracer: nop</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 327/327   #P:4</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">            Xorg-1684  [000] d... 1140567.102754: timer_start: timer=ffff8800b20300f0 function=intel_uncore_fw_release_timer [i915] expires=4579967822 [timeout=1] flags=0x00000001</span><br><span class="line">      nxnode.bin-11900 [000] d.s. 1140567.105061: timer_start: timer=ffff8803aa293508 function=intel_pstate_timer_func expires=4579967825 [timeout=3] flags=0x00100000</span><br><span class="line">          &lt;idle&gt;-0     [000] dNs. 1140567.108404: timer_start: timer=ffff8802cf845698 function=tcp_delack_timer expires=4579967832 [timeout=10] flags=0x00000000</span><br></pre></td></tr></table></figure>



<p>在events目录下，有很多子目录。这些目录里面可以使用filter，过滤很多不需要的信息。</p>
<p>通过format可以知道，timer_start这个时间的field名称，然后在filter进行设置。</p>
<h4 id="针对某一pid进行过滤。"><a href="#针对某一pid进行过滤。" class="headerlink" title="针对某一pid进行过滤。"></a>针对某一pid进行过滤。</h4><p>将对应pid写入set_event_pid，就可达到只监控某个进程的Events。</p>
<h4 id="清空跟踪器"><a href="#清空跟踪器" class="headerlink" title="清空跟踪器"></a>清空跟踪器</h4><p>对子系统的filter写入0，即可清空整个子系统的filter</p>
<p>echo 0 &gt; filter</p>
<h3 id="4-2-3-Events的trigger功能"><a href="#4-2-3-Events的trigger功能" class="headerlink" title="4.2.3 Events的trigger功能"></a>4.2.3 Events的trigger功能</h3><p>enable_event&#x2F;disable_event</p>
<p>stacktrace</p>
<p>snapshot</p>
<p>traceon&#x2F;traceoff</p>
<h2 id="4-3-如何在Linux-command-line启动Events"><a href="#4-3-如何在Linux-command-line启动Events" class="headerlink" title="4.3 如何在Linux command line启动Events"></a>4.3 如何在Linux command line启动Events</h2><h2 id="4-3-function跟踪器及动态ftrace"><a href="#4-3-function跟踪器及动态ftrace" class="headerlink" title="4.3 function跟踪器及动态ftrace"></a>4.3 function跟踪器及动态ftrace</h2><p>function跟踪器可以用于跟踪内核函数的调用情况，用于调试分析bug或者了解内核运行过程。</p>
<h3 id="4-3-1-打开Function跟踪器"><a href="#4-3-1-打开Function跟踪器" class="headerlink" title="4.3.1 打开Function跟踪器"></a>4.3.1 打开Function跟踪器</h3><blockquote>
<p>echo function &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;current_tracer</p>
</blockquote>
<h3 id="4-3-2-在trace-stat中显示function的统计信息"><a href="#4-3-2-在trace-stat中显示function的统计信息" class="headerlink" title="4.3.2 在trace_stat中显示function的统计信息"></a>4.3.2 在trace_stat中显示function的统计信息</h3><h4 id="4-3-2-1-trace-stat的使用"><a href="#4-3-2-1-trace-stat的使用" class="headerlink" title="4.3.2.1 trace_stat的使用"></a>4.3.2.1 trace_stat的使用</h4><p>trace_stat&#x2F;function0在系统初始化就创建，通过function_profile_enabled进行开关。</p>
<p>统计的函数在set_ftrace_filter和set_ftrace_notrace中设置。</p>
<blockquote>
<p>echo 0&#x2F;1 &gt; function_profile_enabled</p>
</blockquote>
<p>在使能function优化功能之后，可以查看不同CPU下每个函数执行时间统计信息。</p>
<p>每列表示的内容分别是：函数名称、调用次数、总耗时、平均耗时、耗时均方差。</p>
<blockquote>
<p>cat trace_stat&#x2F;function0</p>
<p>*Function                Hit  Time      Avg       s^2</p>
<hr>
<p>  schedule               65154  1721953948 us   26428.98 us   940990.8 us<br>  schedule_hrtimeout_range       9655  920051856 us   95292.78 us   1284647 us<br>  schedule_hrtimeout_range_clock    9655  920046552 us   95292.23 us   1139416 us<br>  poll_schedule_timeout         5562  768940036 us   138248.8 us   13748771 us<br>  do_sys_poll              9188  485558063 us   52846.98 us   6242561 us<br>  SyS_poll               8419  469986128 us   55824.45 us   6183267 us<br>  core_sys_select            1853  283704721 us   153105.6 us   2109401 us<br>  do_select               1853  283689546 us   153097.4 us   3187699 us<br>  SyS_futex              40313  260910692 us   6472.122 us   8796046 us<br>  do_futex               40313  260888660 us   6471.576 us   8397810 us<br>  futex_wait              18824  260325650 us   13829.45 us   4756645 us*</p>
</blockquote>
<h4 id="4-3-2-2-通用tracer-stat注册register-stat-tracer"><a href="#4-3-2-2-通用tracer-stat注册register-stat-tracer" class="headerlink" title="4.3.2.2 通用tracer_stat注册register_stat_tracer()"></a>4.3.2.2 通用tracer_stat注册register_stat_tracer()</h4><p>register_stat_tracer()-&gt;init_stat_file()-&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations tracing_stat_fops = &#123;</span><br><span class="line">    .open        = tracing_stat_open,</span><br><span class="line">    .read        = seq_read,</span><br><span class="line">    .llseek        = seq_lseek,</span><br><span class="line">    .release    = tracing_stat_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int init_stat_file(struct stat_session *session)</span><br><span class="line">&#123;</span><br><span class="line">    if (!stat_dir &amp;&amp; tracing_stat_init())</span><br><span class="line">        return -ENODEV;</span><br><span class="line"></span><br><span class="line">    session-&gt;file = debugfs_create_file(session-&gt;ts-&gt;name, 0644,</span><br><span class="line">                        stat_dir,</span><br><span class="line">                        session, &amp;tracing_stat_fops);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int tracing_stat_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    ret = stat_seq_init(session);</span><br><span class="line">    if (ret)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    ret = seq_open(file, &amp;trace_stat_seq_ops);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct seq_operations trace_stat_seq_ops = &#123;</span><br><span class="line">    .start        = stat_seq_start,</span><br><span class="line">    .next        = stat_seq_next,</span><br><span class="line">    .stop        = stat_seq_stop,</span><br><span class="line">    .show        = stat_seq_show</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int stat_seq_show(struct seq_file *s, void *v)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    return session-&gt;ts-&gt;stat_show(s, l-&gt;stat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="4-3-2-3-function-trace-stat流程"><a href="#4-3-2-3-function-trace-stat流程" class="headerlink" title="4.3.2.3 function trace_stat流程"></a>4.3.2.3 function trace_stat流程</h4><p>trace_stat&#x2F;function0相关代码流程如下：</p>
<p>ftrace_init_debugfs()-&gt;ftrace_profile_debugfs()-&gt;register_stat_tracer()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations ftrace_profile_fops = &#123;</span><br><span class="line">    .open        = tracing_open_generic,</span><br><span class="line">    .read        = ftrace_profile_read,</span><br><span class="line">    .write        = ftrace_profile_write,</span><br><span class="line">    .llseek        = default_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* used to initialize the real stat files */</span><br><span class="line">static struct tracer_stat function_stats __initdata = &#123;</span><br><span class="line">    .name        = &quot;functions&quot;,</span><br><span class="line">    .stat_start    = function_stat_start,</span><br><span class="line">    .stat_next    = function_stat_next,</span><br><span class="line">    .stat_cmp    = function_stat_cmp,</span><br><span class="line">    .stat_headers    = function_stat_headers,</span><br><span class="line">    .stat_show    = function_stat_show</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static __init void ftrace_profile_debugfs(struct dentry *d_tracer)</span><br><span class="line">&#123;</span><br><span class="line">    struct ftrace_profile_stat *stat;</span><br><span class="line">    struct dentry *entry;</span><br><span class="line">    char *name;</span><br><span class="line">    int ret;</span><br><span class="line">    int cpu;</span><br><span class="line"></span><br><span class="line">    for_each_possible_cpu(cpu) &#123;</span><br><span class="line">        stat = &amp;per_cpu(ftrace_profile_stats, cpu);</span><br><span class="line"></span><br><span class="line">        /* allocate enough for function name + cpu number */</span><br><span class="line">        name = kmalloc(32, GFP_KERNEL);</span><br><span class="line">...</span><br><span class="line">        stat-&gt;stat = function_stats;</span><br><span class="line">        snprintf(name, 32, &quot;function%d&quot;, cpu);----------------------会在trace_stat目录下创建function0节点，0表示CPU序号。</span><br><span class="line">        stat-&gt;stat.name = name;</span><br><span class="line">        ret = register_stat_tracer(&amp;stat-&gt;stat);--------------------注册function_stats</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entry = debugfs_create_file(&quot;function_profile_enabled&quot;, 0644,</span><br><span class="line">                    d_tracer, NULL, &amp;ftrace_profile_fops);----------创建function_profile_enabled节点，函数集为ftrace_profile_fops</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>写function_profile_enabled触发代码流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t</span><br><span class="line">ftrace_profile_write(struct file *filp, const char __user *ubuf,</span><br><span class="line">             size_t cnt, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long val;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    ret = kstrtoul_from_user(ubuf, cnt, 10, &amp;val);</span><br><span class="line">    if (ret)</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    val = !!val;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;ftrace_profile_lock);</span><br><span class="line">    if (ftrace_profile_enabled ^ val) &#123;</span><br><span class="line">        if (val) &#123;</span><br><span class="line">            ret = ftrace_profile_init();</span><br><span class="line">            if (ret &lt; 0) &#123;</span><br><span class="line">                cnt = ret;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = register_ftrace_profiler();</span><br><span class="line">            if (ret &lt; 0) &#123;</span><br><span class="line">                cnt = ret;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line">            ftrace_profile_enabled = 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ftrace_profile_enabled = 0;</span><br><span class="line">            /*</span><br><span class="line">             * unregister_ftrace_profiler calls stop_machine</span><br><span class="line">             * so this acts like an synchronize_sched.</span><br><span class="line">             */</span><br><span class="line">            unregister_ftrace_profiler();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> out:</span><br><span class="line">    mutex_unlock(&amp;ftrace_profile_lock);</span><br><span class="line"></span><br><span class="line">    *ppos += cnt;</span><br><span class="line"></span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int register_ftrace_profiler(void)</span><br><span class="line">&#123;</span><br><span class="line">    return register_ftrace_graph(&amp;profile_graph_return,</span><br><span class="line">                     &amp;profile_graph_entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void unregister_ftrace_profiler(void)</span><br><span class="line">&#123;</span><br><span class="line">    unregister_ftrace_graph();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p>显示profile结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static int function_stat_show(struct seq_file *m, void *v)</span><br><span class="line">&#123;</span><br><span class="line">    struct ftrace_profile *rec = v;</span><br><span class="line">    char str[KSYM_SYMBOL_LEN];</span><br><span class="line">    int ret = 0;</span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">    static struct trace_seq s;</span><br><span class="line">    unsigned long long avg;</span><br><span class="line">    unsigned long long stddev;</span><br><span class="line">#endif</span><br><span class="line">    mutex_lock(&amp;ftrace_profile_lock);</span><br><span class="line"></span><br><span class="line">    /* we raced with function_profile_reset() */</span><br><span class="line">    if (unlikely(rec-&gt;counter == 0)) &#123;</span><br><span class="line">        ret = -EBUSY;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kallsyms_lookup(rec-&gt;ip, NULL, NULL, NULL, str);</span><br><span class="line">    seq_printf(m, &quot;  %-30.30s  %10lu&quot;, str, rec-&gt;counter);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">    seq_printf(m, &quot;    &quot;);</span><br><span class="line">    avg = rec-&gt;time;</span><br><span class="line">    do_div(avg, rec-&gt;counter);</span><br><span class="line"></span><br><span class="line">    /* Sample standard deviation (s^2) */</span><br><span class="line">    if (rec-&gt;counter &lt;= 1)</span><br><span class="line">        stddev = 0;</span><br><span class="line">    else &#123;</span><br><span class="line">        stddev = rec-&gt;time_squared - rec-&gt;counter * avg * avg;</span><br><span class="line">        /*</span><br><span class="line">         * Divide only 1000 for ns^2 -&gt; us^2 conversion.</span><br><span class="line">         * trace_print_graph_duration will divide 1000 again.</span><br><span class="line">         */</span><br><span class="line">        do_div(stddev, (rec-&gt;counter - 1) * 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_seq_init(&amp;s);</span><br><span class="line">    trace_print_graph_duration(rec-&gt;time, &amp;s);</span><br><span class="line">    trace_seq_puts(&amp;s, &quot;    &quot;);</span><br><span class="line">    trace_print_graph_duration(avg, &amp;s);</span><br><span class="line">    trace_seq_puts(&amp;s, &quot;    &quot;);</span><br><span class="line">    trace_print_graph_duration(stddev, &amp;s);</span><br><span class="line">    trace_print_seq(m, &amp;s);</span><br><span class="line">#endif</span><br><span class="line">    seq_putc(m, &#x27;\n&#x27;);</span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;ftrace_profile_lock);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="4-3-3-function跟踪器的过滤器"><a href="#4-3-3-function跟踪器的过滤器" class="headerlink" title="4.3.3 function跟踪器的过滤器"></a>4.3.3 function跟踪器的过滤器</h3><p>在打开CONFIG_DYNAMIC_FTRACE的情况下，增加一些动态跟踪功能，比如available_filter_functions、set_ftrace_filter、set_ftrace_notrace。</p>
<h4 id="4-3-3-1-set-ftrace-filter跟踪某些函数"><a href="#4-3-3-1-set-ftrace-filter跟踪某些函数" class="headerlink" title="4.3.3.1 set_ftrace_filter跟踪某些函数"></a>4.3.3.1 set_ftrace_filter跟踪某些函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 默认情况下set_ftrace_filter是全部函数都开的。</span><br><span class="line">   cat set_ftrace_filter如下：</span><br><span class="line">   #### all functions enabled ####</span><br><span class="line"></span><br><span class="line">2. 如果想只监控某些函数，通过echo mod_timer add_timer &gt; set_ftrace_filter即可。</span><br><span class="line">   cat set_ftrace_filter如下：</span><br><span class="line">   mod_timer</span><br><span class="line">   add_timer   如果要附加function，通过echo xxx &gt;&gt; set_ftrace_filter即可。3. 使用通配符*　　echo &quot;sched*&quot; &gt; set_ftrace_filter----------------选择所有以sched开头的函数　　echo &quot;*sched*&quot; &gt; set_ftrace_filter---------------选择所有包含sched的函数　　echo &quot;*sched&quot; &gt; set_ftrace_filter----------------选择所有以sched结尾的函数</span><br><span class="line">4. 如果想恢复全开，只需要echo &gt; set_ftrace_filter，即清空filter。</span><br></pre></td></tr></table></figure>



<h4 id="4-3-3-2-set-ftrace-notrace指定不跟踪哪个函数"><a href="#4-3-3-2-set-ftrace-notrace指定不跟踪哪个函数" class="headerlink" title="4.3.3.2 set_ftrace_notrace指定不跟踪哪个函数"></a>4.3.3.2 set_ftrace_notrace指定不跟踪哪个函数</h4><p>echo xxx &gt; set_ftrace_notrace</p>
<h4 id="4-3-3-3-set-ftrace-pid只跟踪某一个进程"><a href="#4-3-3-3-set-ftrace-pid只跟踪某一个进程" class="headerlink" title="4.3.3.3 set_ftrace_pid只跟踪某一个进程"></a>4.3.3.3 set_ftrace_pid只跟踪某一个进程</h4><p>echo xxx &gt; set_ftrace_pid</p>
<p>通过cat trace可以得到结果，只提供了trace函数的调用者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># tracer: function</span><br><span class="line">#</span><br><span class="line"># entries-in-buffer/entries-written: 5/5   #P:1</span><br><span class="line">#</span><br><span class="line">#                              _-----=&gt; irqs-off</span><br><span class="line">#                             / _----=&gt; need-resched</span><br><span class="line">#                            | / _---=&gt; hardirq/softirq</span><br><span class="line">#                            || / _--=&gt; preempt-depth</span><br><span class="line">#                            ||| /     delay</span><br><span class="line">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line">#              | |       |   ||||       |         |</span><br><span class="line">            adbd-1243  [000] d...  7436.183990: mod_timer &lt;-DWC_TIMER_SCHEDULE</span><br><span class="line">          &lt;idle&gt;-0     [000] ..s.  7437.264984: mod_timer &lt;-br_hello_timer_expired</span><br><span class="line">            adbd-1243  [000] d...  7438.000336: mod_timer &lt;-DWC_TIMER_SCHEDULE</span><br><span class="line">            adbd-1243  [000] d...  7438.000549: mod_timer &lt;-DWC_TIMER_SCHEDULE</span><br><span class="line">            adbd-1243  [000] d...  7438.003876: mod_timer &lt;-DWC_TIMER_SCHEDULE</span><br></pre></td></tr></table></figure>



<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="4-3-4-都有哪些函数可以跟踪-available-filter-functions"><a href="#4-3-4-都有哪些函数可以跟踪-available-filter-functions" class="headerlink" title="4.3.4 都有哪些函数可以跟踪(available_filter_functions)?"></a>4.3.4 都有哪些函数可以跟踪(available_filter_functions)?</h3><p>ftrace_init初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">extern unsigned long __start_mcount_loc[];</span><br><span class="line">extern unsigned long __stop_mcount_loc[];</span><br><span class="line"></span><br><span class="line">void __init ftrace_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long count, addr, flags;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    /* Keep the ftrace pointer to the stub */</span><br><span class="line">    addr = (unsigned long)ftrace_stub;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    ftrace_dyn_arch_init(&amp;addr);</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">    /* ftrace_dyn_arch_init places the return code in addr */</span><br><span class="line">    if (addr)</span><br><span class="line">        goto failed;</span><br><span class="line"></span><br><span class="line">    count = __stop_mcount_loc - __start_mcount_loc;</span><br><span class="line"></span><br><span class="line">    ret = ftrace_dyn_table_alloc(count);</span><br><span class="line">    if (ret)</span><br><span class="line">        goto failed;</span><br><span class="line"></span><br><span class="line">    last_ftrace_enabled = ftrace_enabled = 1;</span><br><span class="line"></span><br><span class="line">    ret = ftrace_process_locs(NULL,</span><br><span class="line">                  __start_mcount_loc,</span><br><span class="line">                  __stop_mcount_loc);</span><br><span class="line"></span><br><span class="line">    ret = register_module_notifier(&amp;ftrace_module_exit_nb);</span><br><span class="line">    if (ret)</span><br><span class="line">        pr_warning(&quot;Failed to register trace ftrace module exit notifier\n&quot;);</span><br><span class="line"></span><br><span class="line">    set_ftrace_early_filters();</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"> failed:</span><br><span class="line">    ftrace_disabled = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int ftrace_process_locs(struct module *mod,</span><br><span class="line">                   unsigned long *start,</span><br><span class="line">                   unsigned long *end)</span><br><span class="line">&#123;</span><br><span class="line">    struct ftrace_page *pg;</span><br><span class="line">    unsigned long count;</span><br><span class="line">    unsigned long *p;</span><br><span class="line">    unsigned long addr;</span><br><span class="line">    unsigned long flags = 0; /* Shut up gcc */</span><br><span class="line">    int ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    count = end - start;</span><br><span class="line"></span><br><span class="line">    if (!count)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    pg = ftrace_allocate_pages(count);</span><br><span class="line">    if (!pg)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Core and each module needs their own pages, as</span><br><span class="line">     * modules will free them when they are removed.</span><br><span class="line">     * Force a new page to be allocated for modules.</span><br><span class="line">     */</span><br><span class="line">    if (!mod) &#123;</span><br><span class="line">        WARN_ON(ftrace_pages || ftrace_pages_start);</span><br><span class="line">        /* First initialization */</span><br><span class="line">        ftrace_pages = ftrace_pages_start = pg;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!ftrace_pages)</span><br><span class="line">            goto out;</span><br><span class="line"></span><br><span class="line">        if (WARN_ON(ftrace_pages-&gt;next)) &#123;</span><br><span class="line">            /* Hmm, we have free pages? */</span><br><span class="line">            while (ftrace_pages-&gt;next)</span><br><span class="line">                ftrace_pages = ftrace_pages-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ftrace_pages-&gt;next = pg;</span><br><span class="line">        ftrace_pages = pg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = start;</span><br><span class="line">    while (p &lt; end) &#123;</span><br><span class="line">        addr = ftrace_call_adjust(*p++);</span><br><span class="line">        /*</span><br><span class="line">         * Some architecture linkers will pad between</span><br><span class="line">         * the different mcount_loc sections of different</span><br><span class="line">         * object files to satisfy alignments.</span><br><span class="line">         * Skip any NULL pointers.</span><br><span class="line">         */</span><br><span class="line">        if (!addr)</span><br><span class="line">            continue;</span><br><span class="line">        if (!ftrace_record_ip(addr))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* These new locations need to be initialized */</span><br><span class="line">    ftrace_new_pgs = pg;</span><br><span class="line"></span><br><span class="line">    /* Make each individual set of pages sorted by ips */</span><br><span class="line">    for (; pg; pg = pg-&gt;next)</span><br><span class="line">        sort(pg-&gt;records, pg-&gt;index, sizeof(struct dyn_ftrace),</span><br><span class="line">             ftrace_cmp_recs, ftrace_swap_recs);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We only need to disable interrupts on start up</span><br><span class="line">     * because we are modifying code that an interrupt</span><br><span class="line">     * may execute, and the modification is not atomic.</span><br><span class="line">     * But for modules, nothing runs the code we modify</span><br><span class="line">     * until we are finished with it, and there&#x27;s no</span><br><span class="line">     * reason to cause large interrupt latencies while we do it.</span><br><span class="line">     */</span><br><span class="line">    if (!mod)</span><br><span class="line">        local_irq_save(flags);</span><br><span class="line">    ftrace_update_code(mod);</span><br><span class="line">    if (!mod)</span><br><span class="line">        local_irq_restore(flags);</span><br><span class="line">    ret = 0;</span><br><span class="line"> out:</span><br><span class="line">    mutex_unlock(&amp;ftrace_lock);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static __init int ftrace_init_dyn_debugfs(struct dentry *d_tracer)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    trace_create_file(&quot;available_filter_functions&quot;, 0444,</span><br><span class="line">            d_tracer, NULL, &amp;ftrace_avail_fops);</span><br><span class="line"></span><br><span class="line">    trace_create_file(&quot;enabled_functions&quot;, 0444,</span><br><span class="line">            d_tracer, NULL, &amp;ftrace_enabled_fops);</span><br><span class="line"></span><br><span class="line">    trace_create_file(&quot;set_ftrace_filter&quot;, 0644, d_tracer,</span><br><span class="line">            NULL, &amp;ftrace_filter_fops);</span><br><span class="line"></span><br><span class="line">    trace_create_file(&quot;set_ftrace_notrace&quot;, 0644, d_tracer,</span><br><span class="line">                    NULL, &amp;ftrace_notrace_fops);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">    trace_create_file(&quot;set_graph_function&quot;, 0444, d_tracer,</span><br><span class="line">                    NULL,</span><br><span class="line">                    &amp;ftrace_graph_fops);</span><br><span class="line">#endif /* CONFIG_FUNCTION_GRAPH_TRACER */</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct file_operations ftrace_avail_fops = &#123;</span><br><span class="line">    .open = ftrace_avail_open,</span><br><span class="line">    .read = seq_read,</span><br><span class="line">    .llseek = seq_lseek,</span><br><span class="line">    .release = seq_release_private,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">ftrace_avail_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    struct ftrace_iterator *iter;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    if (unlikely(ftrace_disabled))</span><br><span class="line">        return -ENODEV;</span><br><span class="line"></span><br><span class="line">    iter = kzalloc(sizeof(*iter), GFP_KERNEL);</span><br><span class="line">    if (!iter)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    iter-&gt;pg = ftrace_pages_start;</span><br><span class="line">    iter-&gt;ops = &amp;global_ops;</span><br><span class="line"></span><br><span class="line">    ret = seq_open(file, &amp;show_ftrace_seq_ops);</span><br><span class="line">    if (!ret) &#123;</span><br><span class="line">        struct seq_file *m = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">        m-&gt;private = iter;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        kfree(iter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="4-4-function-graph跟踪器"><a href="#4-4-function-graph跟踪器" class="headerlink" title="4.4 function_graph跟踪器"></a>4.4 function_graph跟踪器</h2><p>function_graph和function类似，但是function跟踪器只在函数入口点探测，而function_graph在函数入口和退出都进行探测。</p>
<p>function_graph提供了类似C语言函数调用关系图，并且记录了函数执行耗时。</p>
<blockquote>
<p>echo function_graph &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;current_tracer。</p>
</blockquote>
<p>function_graph没有设置pid，但是可以设置跟踪哪些函数，不跟踪那些函数：</p>
<blockquote>
<p>echo xxx &gt; set_graph_function</p>
<p>echo xxx &gt; set_graph_notrace</p>
</blockquote>
<p>设置function_graph嵌套层数：</p>
<blockquote>
<p>echo 10 &gt; max_graph_depth</p>
</blockquote>
<p>获得的Trace如下，细节以及调用关系更明确。同时可以获得函数耗时，这对于性能优化非常重要，可以轻松找出热点区域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0)               |  SyS_futex() &#123;</span><br><span class="line"> 0)               |    do_futex() &#123;</span><br><span class="line"> 0)               |      futex_wake() &#123;</span><br><span class="line"> 0)               |        get_futex_key() &#123;</span><br><span class="line"> 0)   0.045 us    |          get_futex_key_refs.isra.13();</span><br><span class="line"> 0)   0.337 us    |        &#125;</span><br><span class="line"> 0)   0.040 us    |        hash_futex();</span><br><span class="line"> 0)   0.051 us    |        _raw_spin_lock();</span><br><span class="line"> 0)               |        mark_wake_futex() &#123;</span><br><span class="line"> 0)   0.061 us    |          wake_q_add();</span><br><span class="line"> 0)   0.082 us    |          __unqueue_futex();</span><br><span class="line"> 0)   0.674 us    |        &#125;</span><br><span class="line"> 0)               |        wake_up_q() &#123;</span><br><span class="line">...</span><br><span class="line"> 0) + 14.680 us   |        &#125;</span><br><span class="line"> 0)   0.033 us    |        drop_futex_key_refs.isra.14();</span><br><span class="line"> 0) + 17.200 us   |      &#125;</span><br><span class="line"> 0) + 17.495 us   |    &#125;</span><br><span class="line"> 0) + 17.752 us   |  &#125;</span><br></pre></td></tr></table></figure>



<p>抓取数据之后，可以通过Python脚本进行简单的转换放到SourceInsight查看更方便。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">output_file = &#x27;output.c&#x27;</span><br><span class="line"></span><br><span class="line">input_file = &#x27;trace.txt&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input = open(input_file, &#x27;rb&#x27;)</span><br><span class="line">output = open(output_file, &#x27;wb&#x27;)</span><br><span class="line"></span><br><span class="line">for line in input:</span><br><span class="line">    m = re.match(&#x27;^ (?P&lt;cpu&gt;[0-9]).&#123;3&#125;(?P&lt;duration&gt;.*) *\| (?P&lt;message&gt;.*)&#x27;, line)</span><br><span class="line">    if(not m):</span><br><span class="line">        continue</span><br><span class="line">    #print m.group(&#x27;cpu&#x27;), m.group(&#x27;duration&#x27;), m.group(&#x27;message&#x27;)</span><br><span class="line">    output.write(m.group(&#x27;message&#x27;) + &quot;//&quot; + m.group(&#x27;duration&#x27;) + &quot;\n&quot;)</span><br></pre></td></tr></table></figure>





<h2 id="4-5-irqsoff-x2F-preemptoff-x2F-preemptirqsoff跟踪器"><a href="#4-5-irqsoff-x2F-preemptoff-x2F-preemptirqsoff跟踪器" class="headerlink" title="4.5 irqsoff&#x2F;preemptoff&#x2F;preemptirqsoff跟踪器"></a>4.5 irqsoff&#x2F;preemptoff&#x2F;preemptirqsoff跟踪器</h2><h3 id="4-5-1-中断屏蔽和强占禁止带来的危害"><a href="#4-5-1-中断屏蔽和强占禁止带来的危害" class="headerlink" title="4.5.1 中断屏蔽和强占禁止带来的危害"></a>4.5.1 中断屏蔽和强占禁止带来的危害</h3><p>中断屏蔽和强占禁止非常影响系统性能，所以对中断屏蔽和强占禁止进行统计监控，发现异常点很有必要。</p>
<p>当中断被屏蔽后，CPU无法响应外部事件(除了不可屏蔽中断NMI和系统管理中断SMI)。这就会阻止比如系统Tick中断或者键盘中断，导致响应时间变长。</p>
<p>同样强占禁止，我们还可以收到中断，但是任务强占被禁止导致更高优先级的任务得不到调度，直到强占被再次允许。</p>
<h3 id="4-5-2-设置跟踪器"><a href="#4-5-2-设置跟踪器" class="headerlink" title="4.5.2 设置跟踪器"></a>4.5.2 设置跟踪器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; options/function-trace</span><br><span class="line">echo irqsoff &gt; current_tracer</span><br><span class="line">echo 1 &gt; tracing_on</span><br><span class="line">echo 0 &gt; tracing_max_latency</span><br><span class="line"> [...]</span><br><span class="line">echo 0 &gt; tracing_on</span><br><span class="line">cat trace</span><br></pre></td></tr></table></figure>





<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># tracer: irqsoff</span><br><span class="line">#</span><br><span class="line"># irqsoff latency trace v1.1.5 on 4.0.0+</span><br><span class="line"># --------------------------------------------------------------------</span><br><span class="line"># latency: 11658 us, #4/4, CPU#2 | (M:server VP:0, KP:0, SP:0 HP:0 #P:4)</span><br><span class="line">#    -----------------</span><br><span class="line">#    | task: swapper/2-0 (uid:0 nice:0 policy:0 rt_prio:0)</span><br><span class="line">#    -----------------</span><br><span class="line">#  =&gt; started at: rcu_idle_enter</span><br><span class="line">#  =&gt; ended at:   arch_cpu_idle---------------------记录禁止中断时间最长的开始和结束函数</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#                  _------=&gt; CPU#            </span><br><span class="line">#                 / _-----=&gt; irqs-off----------------d表示中断被disabled，&#x27;.&#x27;表示中断没有被关闭。</span><br><span class="line">#                | / _----=&gt; need-resched------------N-表示need_resched被设置；&#x27;.&#x27;-表示need_resched没有被设置，中断返回不会进行进程切换。</span><br><span class="line">#                || / _---=&gt; hardirq/softirq---------H-表示softirq中发生了硬件中断；h-硬件中断；s-softirq；&#x27;.&#x27;-不在中断上下文中。</span><br><span class="line">#                ||| / _--=&gt; preempt-depth-----------当抢占中断势能后，该域代表preempt_disabled的级别。</span><br><span class="line">#                |||| /     delay            </span><br><span class="line">#  cmd     pid   ||||| time  |   caller      ---------cmd-进程名，pid-进程id，time-表示trace从开始到当前的相对时间，delay-突出显示那些有高延迟的地方以便引起注意。！表示需要引起注意。</span><br><span class="line">#     \   /      |||||  \    |   /         </span><br><span class="line">  &lt;idle&gt;-0       2d...    3us#: rcu_idle_enter</span><br><span class="line">  &lt;idle&gt;-0       2d... 11645us+: arch_cpu_idle</span><br><span class="line">  &lt;idle&gt;-0       2d... 11665us+: trace_hardirqs_on &lt;-arch_cpu_idle</span><br><span class="line">  &lt;idle&gt;-0       2d... 11753us : &lt;stack trace&gt;</span><br><span class="line"> =&gt; cpu_startup_entry</span><br><span class="line"> =&gt; secondary_start_kernel</span><br></pre></td></tr></table></figure>





<p>察看禁止中断最长函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void cpuidle_idle_call(void)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    rcu_idle_enter();------------------屏蔽中断</span><br><span class="line">...</span><br><span class="line">    if (current_clr_polling_and_test())</span><br><span class="line">        local_irq_enable();</span><br><span class="line">    else</span><br><span class="line">        arch_cpu_idle();---------------开中断</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4-6-wakeup-x2F-wakeup-rt-x2F-wakeup-dl跟踪器"><a href="#4-6-wakeup-x2F-wakeup-rt-x2F-wakeup-dl跟踪器" class="headerlink" title="4.6 wakeup&#x2F;wakeup_rt&#x2F;wakeup_dl跟踪器"></a>4.6 wakeup&#x2F;wakeup_rt&#x2F;wakeup_dl跟踪器</h2><p>wakeup类调度器记录调度延时，也即从系统被唤醒到被调度到的延时。显示的结果类似irqsoff跟踪器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; options/function-trace</span><br><span class="line">echo wakeup &gt; current_tracer</span><br><span class="line">echo 1 &gt; tracing_on</span><br><span class="line">echo 0 &gt; tracing_max_latency</span><br><span class="line">chrt -f 5 sleep 1</span><br><span class="line">echo 0 &gt; tracing_on</span><br><span class="line">cat trace</span><br></pre></td></tr></table></figure>







<p>wakeup：显示进程从woken到wake up的延时，包括所有进程。</p>
<p>wakeup_dl：显示SCHED_DEADLINE类型调度延时。</p>
<p>wakeup_rt：显示实时进程的调度延时。</p>
<h2 id="4-7-stack跟踪器"><a href="#4-7-stack跟踪器" class="headerlink" title="4.7 stack跟踪器"></a>4.7 stack跟踪器</h2><p>stack跟踪器用于追踪内核栈的使用情况，它记录了每个内核对栈的使用情况。</p>
<p>stack跟踪器比较特殊，它的使能不在tracing目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       Depth    Size   Location    (-1 entries)</span><br><span class="line">        -----    ----   --------</span><br><span class="line">#</span><br><span class="line">#  Stack tracer disabled</span><br><span class="line">#</span><br><span class="line"># To enable the stack tracer, either add &#x27;stacktrace&#x27; to the</span><br><span class="line"># kernel command line</span><br><span class="line"># or &#x27;echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled&#x27;</span><br><span class="line">#</span><br></pre></td></tr></table></figure>



<p> 然后通过&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;stack_trace可以查看堆栈轨迹。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       Depth    Size   Location    (13 entries)</span><br><span class="line">       -----    ----   --------</span><br><span class="line"> 0)     1952       4   msecs_to_jiffies+0x14/0x34-----------------------一共1952个字节</span><br><span class="line"> 1)     1948      76   update_group_capacity+0x2c/0x2b4</span><br><span class="line"> 2)     1872     256   find_busiest_group+0x10c/0x904</span><br><span class="line"> 3)     1616     168   load_balance+0x170/0x7b0</span><br><span class="line"> 4)     1448     104   pick_next_task_fair+0x1a8/0x500</span><br><span class="line"> 5)     1344      28   __schedule+0x100/0x5b8</span><br><span class="line"> 6)     1316      68   schedule+0x4c/0xa4</span><br><span class="line"> 7)     1248     104   schedule_hrtimeout_range_clock+0x154/0x15c</span><br><span class="line"> 8)     1144      16   schedule_hrtimeout_range+0x1c/0x20</span><br><span class="line"> 9)     1128      24   poll_schedule_timeout+0x48/0x74</span><br><span class="line">10)     1104     968   do_sys_poll+0x3fc/0x4b8-------------------------使用了最大的栈空间</span><br><span class="line">11)      136      40   SyS_poll+0xc4/0x108</span><br><span class="line">12)       96      96   ret_fast_syscall+0x0/0x4c</span><br></pre></td></tr></table></figure>









<h2 id="4-8-其他Tracer"><a href="#4-8-其他Tracer" class="headerlink" title="4.8 其他Tracer"></a>4.8 其他Tracer</h2><p>mmiotrace：Memory mapped IO</p>
<p>blk：</p>
<h2 id="4-9-开机使用ftrace"><a href="#4-9-开机使用ftrace" class="headerlink" title="4.9 开机使用ftrace"></a>4.9 开机使用ftrace</h2><p>存在某些情况，需要尽量早的启动ftrace功能。</p>
<p>这时候就需要修改command line，在其中打开ftrace相关设置。</p>
<p>具体的设置有trace_event、trace_buf_size、ftrace、ftrace_notrace、ftrace_filter、ftrace_graph_filter、stacktrace、ftraceftrace_dump_on_oops、tracing_thresh。</p>
<p>ftrace用于设置tracer，trace_buf_size设置ring buffer大小，trace_event设置跟踪哪些events，ftrace_notrace&#x2F;ftrace_filter&#x2F;ftrace_graph_filter都是设置过滤器。</p>
<h3 id="4-9-1-trace-event设置trace-events"><a href="#4-9-1-trace-event设置trace-events" class="headerlink" title="4.9.1 trace_event设置trace events"></a>4.9.1 trace_event设置trace events</h3><p>在开机的时候设置需要跟踪的trace events，将内容放入bootup_event_buf。</p>
<p>通常格式如下，以逗号作为分隔符：</p>
<blockquote>
<p>trace_event&#x3D;sched:sched_process_fork,irq:,thermal</p>
</blockquote>
<p>然后在event_trace_init()中根据bootup_event_buf进行设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static __init int setup_trace_event(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    strlcpy(bootup_event_buf, str, COMMAND_LINE_SIZE);</span><br><span class="line">    ring_buffer_expanded = 1;</span><br><span class="line">    tracing_selftest_disabled = 1;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">__setup(&quot;trace_event=&quot;, setup_trace_event);</span><br><span class="line"></span><br><span class="line">static __init int event_trace_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct ftrace_event_call **call;</span><br><span class="line">    struct dentry *d_tracer;</span><br><span class="line">    struct dentry *entry;</span><br><span class="line">    struct dentry *d_events;</span><br><span class="line">    int ret;</span><br><span class="line">    char *buf = bootup_event_buf;</span><br><span class="line">    char *token;</span><br><span class="line">...</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        token = strsep(&amp;buf, &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">        if (!token)</span><br><span class="line">            break;</span><br><span class="line">        if (!*token)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        ret = ftrace_set_clr_event(token, 1);</span><br><span class="line">        if (ret)</span><br><span class="line">            pr_warning(&quot;Failed to enable trace event: %s\n&quot;, token);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="4-9-2-ftrace相关设置"><a href="#4-9-2-ftrace相关设置" class="headerlink" title="4.9.2 ftrace相关设置"></a>4.9.2 ftrace相关设置</h3><p>在command line中设置ftrace可以在开机时启动指定tracer。</p>
<p>指定tracer在register_tracer()中进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static char bootup_tracer_buf[MAX_TRACER_SIZE] __initdata;</span><br><span class="line">static char *default_bootup_tracer;</span><br><span class="line"></span><br><span class="line">static int __init set_cmdline_ftrace(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    strncpy(bootup_tracer_buf, str, MAX_TRACER_SIZE);</span><br><span class="line">    default_bootup_tracer = bootup_tracer_buf;------------------------------------------指定tracer的名称</span><br><span class="line">    /* We are using ftrace early, expand it */</span><br><span class="line">    ring_buffer_expanded = 1;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">__setup(&quot;ftrace=&quot;, set_cmdline_ftrace);</span><br><span class="line"></span><br><span class="line">int register_tracer(struct tracer *type)</span><br><span class="line">__releases(kernel_lock)</span><br><span class="line">__acquires(kernel_lock)</span><br><span class="line">&#123;</span><br><span class="line">    struct tracer *t;</span><br><span class="line">    int ret = 0;</span><br><span class="line">...</span><br><span class="line"> out:</span><br><span class="line">    tracing_selftest_running = false;</span><br><span class="line">    mutex_unlock(&amp;trace_types_lock);</span><br><span class="line"></span><br><span class="line">    if (ret || !default_bootup_tracer)</span><br><span class="line">        goto out_unlock;</span><br><span class="line"></span><br><span class="line">    if (strncmp(default_bootup_tracer, type-&gt;name, MAX_TRACER_SIZE))--------------------比较当前注册的tracer是否和ftrace设置的。</span><br><span class="line">        goto out_unlock;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO &quot;Starting tracer &#x27;%s&#x27;\n&quot;, type-&gt;name);</span><br><span class="line">    /* Do we want this tracer to start on bootup? */</span><br><span class="line">    tracing_set_tracer(type-&gt;name);------------------------------------------------------在注册的时候就指定tracer。</span><br><span class="line">    default_bootup_tracer = NULL;</span><br><span class="line">    /* disable other selftests, since this will break it. */</span><br><span class="line">    tracing_selftest_disabled = 1;</span><br><span class="line">#ifdef CONFIG_FTRACE_STARTUP_TEST</span><br><span class="line">    printk(KERN_INFO &quot;Disabling FTRACE selftests due to running tracer &#x27;%s&#x27;\n&quot;,</span><br><span class="line">           type-&gt;name);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> out_unlock:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="5-ftrace相关工具"><a href="#5-ftrace相关工具" class="headerlink" title="5 ftrace相关工具"></a>5 ftrace相关工具</h1><h2 id="5-1-trace-cmd和kernelshark"><a href="#5-1-trace-cmd和kernelshark" class="headerlink" title="5.1 trace-cmd和kernelshark"></a>5.1 trace-cmd和kernelshark</h2><p>请参照：《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/9014365.html">ftrace利器之trace-cmd和kernelshark</a>》。</p>
<h1 id="6-ftrace实现的原理"><a href="#6-ftrace实现的原理" class="headerlink" title="6 ftrace实现的原理"></a>6 ftrace实现的原理</h1><p>打开对function、function_graph的支持，导致在编译时插入的一段代码。</p>
<p>然后在echo function&#x2F;function_graph &gt; current_tracer，在运行时将代码进行替换的操作。</p>
<p>详细解释编译、动态开关等ftrace相关原理和流程。</p>
<p>《<a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-23141914-id-5603238.html">ftrace function_graph分析</a>》</p>
<h2 id="6-0-GCC-pg选项"><a href="#6-0-GCC-pg选项" class="headerlink" title="6.0 GCC -pg选项"></a>6.0 GCC -pg选项</h2><p>对比打开-pg和不打开汇编代码，查看区别，以cpu_down为例。分别查看不同选项下的反汇编。</p>
<table>
<thead>
<tr>
<th><strong>未开function&#x2F;function_graph tracer</strong></th>
<th><strong>仅开function tracer</strong></th>
<th><strong>开function&#x2F;function_graph tracer</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0000038c <cpu_down>: 38c: e92d4010 push {r4, lr} 390: e1a04000 mov r4, r0 394: e3000000 movw r0, #0 398: e3400000 movt r0, #0 39c: ebfffffe bl 0 <mutex_lock> 3a0: e3003000 movw r3, #0 3a4: e3403000 movt r3, #0 3a8: e5931004 ldr r1, [r3, #4] 3ac: e3510000 cmp r1, #0 3b0: 1a000007 bne 3d4 &lt;cpu_down+0x48&gt; 3b4: e1a00004 mov r0, r4 3b8: ebffff43 bl cc &lt;_cpu_down&gt; 3bc: e1a04000 mov r4, r0 3c0: e3000000 movw r0, #0 3c4: e3400000 movt r0, #0 3c8: ebfffffe bl 0 <mutex_unlock> 3cc: e1a00004 mov r0, r4 3d0: e8bd8010 pop {r4, pc} 3d4: e3e0400f mvn r4, #15 3d8: eafffff8 b 3c0 &lt;cpu_down+0x34&gt;</td>
<td>000003c0 <cpu_down>: 3c0: e92d4010 push {r4, lr} 3c4: e52de004 push {lr} ; (str lr, [sp, #-4]!) 3c8: ebfffffe bl 0 &lt;__gnu_mcount_nc&gt; 3cc: e1a04000 mov r4, r0 3d0: e3000000 movw r0, #0 3d4: e3400000 movt r0, #0 3d8: ebfffffe bl 0 <mutex_lock> 3dc: e3003000 movw r3, #0 3e0: e3403000 movt r3, #0 3e4: e5931004 ldr r1, [r3, #4] 3e8: e3510000 cmp r1, #0 3ec: 1a000007 bne 410 &lt;cpu_down+0x50&gt; 3f0: e1a00004 mov r0, r4 3f4: ebffff3e bl f4 &lt;_cpu_down&gt; 3f8: e1a04000 mov r4, r0 3fc: e3000000 movw r0, #0 400: e3400000 movt r0, #0 404: ebfffffe bl 0 <mutex_unlock> 408: e1a00004 mov r0, r4 40c: e8bd8010 pop {r4, pc} 410: e3e0400f mvn r4, #15 414: eafffff8 b 3fc &lt;cpu_down+0x3c&gt;</td>
<td>00000400 <cpu_down>: 400: e1a0c00d mov ip, sp 404: e92dd830 push {r4, r5, fp, ip, lr, pc} 408: e24cb004 sub fp, ip, #4 40c: e52de004 push {lr} ; (str lr, [sp, #-4]!) 410: ebfffffe bl 0 &lt;__gnu_mcount_nc&gt; 414: e1a04000 mov r4, r0 418: e3000000 movw r0, #0 41c: e3400000 movt r0, #0 420: ebfffffe bl 0 <mutex_lock> 424: e3003000 movw r3, #0 428: e3403000 movt r3, #0 42c: e5931004 ldr r1, [r3, #4] 430: e3510000 cmp r1, #0 434: 1a000007 bne 458 &lt;cpu_down+0x58&gt; 438: e1a00004 mov r0, r4 43c: ebffff3a bl 12c &lt;_cpu_down&gt; 440: e1a04000 mov r4, r0 444: e3000000 movw r0, #0 448: e3400000 movt r0, #0 44c: ebfffffe bl 0 <mutex_unlock> 450: e1a00004 mov r0, r4 454: e89da830 ldm sp, {r4, r5, fp, sp, pc} 458: e3e0400f mvn r4, #15 45c: eafffff8 b 444 &lt;cpu_down+0x44&gt;</td>
</tr>
</tbody></table>
<p> __gnu_mcount_nc定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(__gnu_mcount_nc)</span><br><span class="line">#ifdef CONFIG_DYNAMIC_FTRACE</span><br><span class="line">    mov    ip, lr</span><br><span class="line">    ldmia    sp!, &#123;lr&#125;</span><br><span class="line">    mov    pc, ip</span><br><span class="line">#else</span><br><span class="line">    __mcount</span><br><span class="line">#endif</span><br><span class="line">ENDPROC(__gnu_mcount_nc)</span><br></pre></td></tr></table></figure>







<h2 id="6-1-打开哪些选项才能实现ftrace功能？"><a href="#6-1-打开哪些选项才能实现ftrace功能？" class="headerlink" title="6.1 打开哪些选项才能实现ftrace功能？"></a>6.1 打开哪些选项才能实现ftrace功能？</h2><p>可以看出在定义了CONFIG_FUNCTION_TRACER、CONFIG_DYNAMIC_FTRACE之后就具备了recordmcount的功能。</p>
<p>如果再定义CONFIG_HAVE_C_RECORDMCOUNT，那么就会使用recordmcount.c而不是recordmcount.pl来进行mcount处理。</p>
<p>.config中定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CONFIG_FUNCTION_TRACER=y</span><br><span class="line">CONFIG_HAVE_C_RECORDMCOUNT=y</span><br><span class="line">CONFIG_DYNAMIC_FTRACE=y</span><br><span class="line">CONFIG_FTRACE_MCOUNT_RECORD=y</span><br></pre></td></tr></table></figure>

<p> Makefile中定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ifdef CONFIG_FUNCTION_TRACER</span><br><span class="line">ifndef CC_FLAGS_FTRACE</span><br><span class="line">CC_FLAGS_FTRACE := -pg</span><br><span class="line">endif</span><br><span class="line">export CC_FLAGS_FTRACE</span><br><span class="line">ifdef CONFIG_HAVE_FENTRY</span><br><span class="line">CC_USING_FENTRY    := $(call cc-option, -mfentry -DCC_USING_FENTRY)</span><br><span class="line">endif</span><br><span class="line">KBUILD_CFLAGS    += $(CC_FLAGS_FTRACE) $(CC_USING_FENTRY)</span><br><span class="line">KBUILD_AFLAGS    += $(CC_USING_FENTRY)</span><br><span class="line">ifdef CONFIG_DYNAMIC_FTRACE</span><br><span class="line">    ifdef CONFIG_HAVE_C_RECORDMCOUNT</span><br><span class="line">        BUILD_C_RECORDMCOUNT := y</span><br><span class="line">        export BUILD_C_RECORDMCOUNT</span><br><span class="line">    endif</span><br><span class="line">endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>



<p> Makefile.build中定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ifdef CONFIG_FTRACE_MCOUNT_RECORD</span><br><span class="line">ifdef BUILD_C_RECORDMCOUNT</span><br><span class="line">ifeq (&quot;$(origin RECORDMCOUNT_WARN)&quot;, &quot;command line&quot;)</span><br><span class="line">  RECORDMCOUNT_FLAGS = -w</span><br><span class="line">endif</span><br><span class="line"># Due to recursion, we must skip empty.o.</span><br><span class="line"># The empty.o file is created in the make process in order to determine</span><br><span class="line">#  the target endianness and word size. It is made before all other C</span><br><span class="line">#  files, including recordmcount.</span><br><span class="line">sub_cmd_record_mcount =                    \</span><br><span class="line">    if [ $(@) != &quot;scripts/mod/empty.o&quot; ]; then    \</span><br><span class="line">        $(objtree)/scripts/recordmcount $(RECORDMCOUNT_FLAGS) &quot;$(@)&quot;;    \</span><br><span class="line">    fi;</span><br><span class="line">recordmcount_source := $(srctree)/scripts/recordmcount.c \</span><br><span class="line">            $(srctree)/scripts/recordmcount.h</span><br><span class="line">else...</span><br><span class="line">endif</span><br><span class="line">...</span><br><span class="line"># Built-in and composite module parts</span><br><span class="line">$(obj)/%.o: $(src)/%.c $(recordmcount_source) FORCE</span><br><span class="line">    $(call cmd,force_checksrc)</span><br><span class="line">    $(call if_changed_rule,cc_o_c)</span><br><span class="line"></span><br><span class="line"># Single-part modules are special since we need to mark them in $(MODVERDIR)</span><br><span class="line"></span><br><span class="line">$(single-used-m): $(obj)/%.o: $(src)/%.c $(recordmcount_source) FORCE</span><br><span class="line">    $(call cmd,force_checksrc)</span><br><span class="line">    $(call if_changed_rule,cc_o_c)</span><br><span class="line">    @&#123; echo $(@:.o=.ko); echo $@; &#125; &gt; $(MODVERDIR)/$(@F:.o=.mod)</span><br></pre></td></tr></table></figure>





<h2 id="6-2-ftrace的mcount功能是如何实现的？"><a href="#6-2-ftrace的mcount功能是如何实现的？" class="headerlink" title="6.2 ftrace的mcount功能是如何实现的？"></a>6.2 ftrace的mcount功能是如何实现的？</h2><p>在Documentation&#x2F;trace&#x2F;ftrace.txt中有一段解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">If CONFIG_DYNAMIC_FTRACE is set, the system will run with virtually no overhead when function tracing is disabled.The way this works is the mcount function call (placed at the start of every kernel function, produced by the -pg switch in gcc),</span><br><span class="line">starts of pointing to a simple return. (Enabling FTRACE will include the -pg switch in the compiling of the kernel.)</span><br><span class="line"></span><br><span class="line">At compile time every C file object is run through the recordmcount program (located in the scripts directory).This program will parse the ELF headers in the C object to find all</span><br><span class="line">the locations in the .text section that call mcount.(Note, only white listed .text sections are processed, since processing other sections like .init.text may cause races due to those sections being freed unexpectedly).</span><br><span class="line"></span><br><span class="line">A new section called &quot;__mcount_loc&quot; is created that holds references to all the mcount call sites in the .text section.</span><br><span class="line">The recordmcount program re-links this section back into the original object.The final linking stage of the kernel will add all these references into a single table.</span><br></pre></td></tr></table></figure>



<p> 在c文件编译完之后，recordmcount增加一个__mcount_loc段。</p>
<p>在vmlinux.lds.h文件中对__mcount_loc段归集，在系统初始化的时候有两个参数很重要__start_mcount_loc和__stop_mcount_loc。</p>
<p>在available_function</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define MCOUNT_REC()    . = ALIGN(8);                \</span><br><span class="line">            VMLINUX_SYMBOL(__start_mcount_loc) = .; \</span><br><span class="line">            *(__mcount_loc)                \</span><br><span class="line">            VMLINUX_SYMBOL(__stop_mcount_loc) = .;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* init and exit section handling */</span><br><span class="line">#define INIT_DATA                            \</span><br><span class="line">    *(.init.data)                            \</span><br><span class="line">...</span><br><span class="line">    KERNEL_CTORS()                            \</span><br><span class="line">    *(.init.rodata)                            \</span><br><span class="line">    MCOUNT_REC()                            \</span><br><span class="line">...</span><br><span class="line">    KERNEL_DTB()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define INIT_DATA_SECTION(initsetup_align)                \</span><br><span class="line">    .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) &#123;        \</span><br><span class="line">        INIT_DATA                        \</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<h2 id="6-3-引入ftrace对性能的影响有多大？"><a href="#6-3-引入ftrace对性能的影响有多大？" class="headerlink" title="6.3 引入ftrace对性能的影响有多大？"></a>6.3 引入ftrace对性能的影响有多大？</h2><p> 在不使用的时候在入口点插入nop，在使用的时候才会替换成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">On boot up, before SMP is initialized, the dynamic ftrace code scans this table and updates all the locations into nops.It also records the locations, which are added to the available_filter_functions list.在启动阶段，SMP初始化之前，ftrace扫描__mcount_loc段，将所有入口地址mcount使用nop替代。这样只要不打开，开销非常小，基本上不产生性能影响。Modules are processed as they are loaded and before they are executed.When a module is unloaded, it also removes its functions from the ftrace function list.This is automatic in the module unload code, and the module author does not need to worry about it.</span><br><span class="line"></span><br><span class="line">When tracing is enabled, the process of modifying the function tracepoints is dependent on architecture....</span><br><span class="line">The new method of modifying the function tracepoints is to place a breakpoint at the location to be modified,sync all CPUs, modify the rest of the instruction not covered by the breakpoint.Sync all CPUs again, and then remove the breakpoint with the finished version to the ftrace call site.</span><br></pre></td></tr></table></figure>



<p>在内核初始化的初期，ftrace 查询 __mcount_loc 段，得到每个函数的入口地址，并将 mcount 替换为 nop 指令。这样在默认情况下，ftrace 不会对内核性能产生影响。</p>
<p>当用户打开 ftrace 功能时，ftrace 将这些 nop 指令动态替换为 ftrace_caller，该函数将调用用户注册的 trace 函数。</p>
<h2 id="6-4-核心函数ftrace-caller-x2F-ftrace-graph-caller"><a href="#6-4-核心函数ftrace-caller-x2F-ftrace-graph-caller" class="headerlink" title="6.4 核心函数ftrace_caller&#x2F;ftrace_graph_caller"></a>6.4 核心函数ftrace_caller&#x2F;ftrace_graph_caller</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_DYNAMIC_FTRACE</span><br><span class="line">ENTRY(ftrace_caller)</span><br><span class="line">UNWIND(.fnstart)</span><br><span class="line">    __ftrace_caller</span><br><span class="line">UNWIND(.fnend)</span><br><span class="line">ENDPROC(ftrace_caller)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.macro __ftrace_caller suffix</span><br><span class="line">    mcount_enter------------------------------------宏mcount_enter</span><br><span class="line"></span><br><span class="line">    mcount_get_lr    r1            @ lr of instrumented func</span><br><span class="line">    mcount_adjust_addr    r0, lr        @ instrumented function</span><br><span class="line"></span><br><span class="line">    .globl ftrace_call\suffix</span><br><span class="line">ftrace_call\suffix:</span><br><span class="line">    bl    ftrace_stub</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">    .globl ftrace_graph_call\suffix</span><br><span class="line">ftrace_graph_call\suffix:</span><br><span class="line">    mov    r0, r0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    mcount_exit------------------------------------宏mcount_exit</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>.macro mcount_enter———————————-mcount_enter定义<br>stmdb sp!, {r0-r3, lr}<br>.endm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>.macro mcount_get_lr reg<br>ldr \reg, [fp, #-4]<br>.endm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>.macro mcount_exit———————————mcount_exit定义<br>ldr lr, [fp, #-4]<br>ldmia sp!, {r0-r3, pc}<br>.endm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>







<p>function_graph：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">ENTRY(ftrace_graph_caller)</span><br><span class="line">UNWIND(.fnstart)</span><br><span class="line">    __ftrace_graph_caller</span><br><span class="line">UNWIND(.fnend)</span><br><span class="line">ENDPROC(ftrace_graph_caller)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">.macro __ftrace_graph_caller</span><br><span class="line">    sub    r0, fp, #4        @ &amp;lr of instrumented routine (&amp;parent)</span><br><span class="line">#ifdef CONFIG_DYNAMIC_FTRACE</span><br><span class="line">    @ called from __ftrace_caller, saved in mcount_enter</span><br><span class="line">    ldr    r1, [sp, #16]        @ instrumented routine (func)</span><br><span class="line">    mcount_adjust_addr    r1, r1</span><br><span class="line">#else</span><br><span class="line">    @ called from __mcount, untouched in lr</span><br><span class="line">    mcount_adjust_addr    r1, lr    @ instrumented routine (func)</span><br><span class="line">#endif</span><br><span class="line">    mov    r2, fp            @ frame pointer</span><br><span class="line">    bl    prepare_ftrace_return</span><br><span class="line">    mcount_exit</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>







<p>参考文档：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/core-api/tracepoint.html">The Linux Kernel Tracepoint API</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-20543183-id-1930846.html">Linux内核跟踪之trace框架分析</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/u011013137/article/details/9093823">linux ftrace追踪一（基本技术结构粗略剖析）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace1/">使用 ftrace 调试 Linux 内核，第 1 部分</a> &amp; <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace2/">使用 ftrace 调试 Linux 内核，第 2 部分</a> &amp; <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace3/">使用 ftrace 调试 Linux 内核，第 3 部分</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.4.110/source/Documentation/trace">Linux Tracepoint内核文档</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html">ftrace简介</a></p>
</li>
</ol>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/df/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  Df(1)
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/mpstat/">
                Mpstat-Multiprocessor Statistics
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>

	</div>
	<div id="footer">
	<p>
	©2022-<span id="footerYear"></span> 
	<a href="/">Leah Ge</a> 
	
	
	<br>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>
