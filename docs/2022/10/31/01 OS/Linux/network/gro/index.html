<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	  
<script src="/js/search.js"></script>

	<!-- title -->
	
	<title>
	
		Linux Kernel 网络协议栈之GRO |
	
	LeahGe
	</title>

	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "leahge.github.io";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>


	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.4.14/dist/Valine.min.js"></script>

	
	
	<script type="text/javascript">

		var search_path = "/search.xml";
		if (search_path.length == 0) {
			search_path = "search.xml";
		}
		var path = search_path;
		searchFunc(path, 'local-search-input', 'local-search-result');
	</script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">LeahGe</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	

	

		<li class="menu-item">
			<a href="https://github.com/leahge" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
		<li class="menu-item">
			<form class="">
				<button class="btn text-muted fa fa-search d-none d-md-block d-lg-block" style="background-color: transparent;"
					disabled></button>
				<input id="local-search-input" class="form-control me-2 pe-4" type="search" aria-label="Search">
				<div id="local-search-result"
					style="position:absolute; padding-top: 8px; max-height: 960px; width: 480px;overflow-y: scroll; z-index: 1050;">
				</div>
			</form>
		</li>
	</ul>


</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 OS
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Linux
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Kernel
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/Kernel/kallsyms/">
                     
										    Kallsyms
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/31/01%20OS/Linux/Kernel/kernel_config/">
                     
										    Linux Kernel 编译选项
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Perf
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf-report/">
                     
										    Perf-Report(1) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf-script/">
                     
										    Perf-Script(1) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf-stat/">
                     
										    Perf-Stat(1)
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/28/01%20OS/Linux/Perf/perf_event/">
                     
										    PMU计数器
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_hardware/">
                     
										    PERF EVENT 硬件篇
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_hardware2/">
                     
										    PERF EVENT 硬件篇续篇
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_ipc/">
                     
										    Perf IPC以及CPU利用率
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Perf/perf_kernel/">
                     
										    PERF EVENT 内核篇
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/Perf/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">
                     
										    参考资料
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Shell
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/Shell/ctrlc/">
                     
										    Linux Shell中捕获CTRL+C
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/Shell/stringcut/">
                     
										    Shell字符串截取
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										network
									</a>
									
							<ul>
								<li class="file active">
									<a href="/2022/10/31/01%20OS/Linux/network/gro/">
                     
										    Linux Kernel 网络协议栈之GRO
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/network/irq/">
                     
										    网卡多队列配置和中断绑定
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/31/01%20OS/Linux/network/napi/">
                     
										    Linux协议栈--NAPI机制
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/systemd/">
                     
										    Systemd
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										指令
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/df/">
                     
										    Df(1)
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/du/">
                     
										    Du(1)
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ftrace/">
                     
										    Ftrace
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/ltrace/">
                     
										    Ltrace(1) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/man_class/">
                     
										    Linux指令后的数字代表什么
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/mpstat/">
                     
										    Mpstat-Multiprocessor Statistics
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/pidstat/">
                     
										    Pidstat
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/pushd/">
                     
										    Linux 中使用 Pushd 和 Popd 命令来进行高效的目录导航
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sadc/">
                     
										    Sadc(8) — Linux Manual Page
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sar/">
                     
										    Sar
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/%E6%8C%87%E4%BB%A4/sed/">
                     
										    Sed
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/strace/">
                     
										    Strace
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/tee/">
                     
										    Tee
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/Linux/%E6%8C%87%E4%BB%A4/vmstat/">
                     
										    Vmstat-Report Virtual Memory Statistics
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										系统调用
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/brk/">
                     
										    Brk
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/exec/">
                     
										    Exec
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/futex/">
                     
										    Futex
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/getcpu/">
                     
										    Getcpu系统调用
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/gettimeofday/">
                     
										    Gettimeofday
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/ioctl/">
                     
										    Ioctl
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/mmap/">
                     
										    Mmap
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										编译、链接和装载
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/DSO/">
                     
										    DSO(dynamic Shared Object)动态共享对象的原理
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/27/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/compile_Link/">
                     
										    Linux下编译、链接和装载
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/elfremovesymbol/">
                     
										    剥离与导回符号表及调试信息
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/16/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/elf/">
                     
										    Elf文件格式
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/01%20OS/Linux/%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD/linux_compile/">
                     
										    编译、链接和装载
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										进程
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/28/01%20OS/Linux/%E8%BF%9B%E7%A8%8B/status/">
                     
										    Linux进程状态：S 和D状态
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/01%20OS/%E6%9C%8D%E5%8A%A1%E5%99%A8BMC%E4%B8%8EIPMI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                     
										    服务器BMC与IPMI基础知识
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 CPU
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/14/02%20CPU/SocketNodeDieCoreProcessor/">
                     
										    Socket/Node/Die/Core/Processor/Package
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/14/02%20CPU/%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95/">
                     
										    技术发展
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										12 Python
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/14/12%20Python/Gunicorn_manual/">
                     
										    Gunicorn的使用手册
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										50 soft
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Nodejs
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/14/50%20soft/Nodejs/npm/">
                     
										    Npm
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										99 Other
									</a>
									
							<ul>
								<li class="file">
									<a href="/2022/10/13/99%20Other/%E5%9B%BE%E7%81%B5%E6%9C%BA%E4%B8%8E%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/">
                     
										    图灵机与图灵完备
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2022/10/13/ebook/">
                     
										    99 Ebook
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										优化
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 CPU
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-1%20%E4%B8%BB%E9%A2%91/">
                     
										    03-1 主频
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-2%20%E9%A2%84%E5%8F%96/">
                     
										    03-2 预取
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-3%20%E4%BA%B2%E5%92%8C%E6%80%A7/">
                     
										    03-3 亲和性
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-4%20%E7%8B%AC%E5%8D%A0/">
                     
										    03-4 独占
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-5%20Time%20Tick%E4%B8%AD%E6%96%AD/">
                     
										    03-5 Time Tick中断
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-6%20RCB/">
                     
										    03-6 RCB
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-7%20%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7/">
                     
										    03-7 调度优先级
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/01%20CPU/03-8%20%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">
                     
										    03-8 中断负载均衡
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 内存
									</a>
									
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/01%20%E5%8E%9F%E7%90%86/">
                     
										    01 原理
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/02%20%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/">
                     
										    02 监控工具
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-1%E5%86%85%E5%AD%98%E6%9D%A1%E9%80%89%E6%8B%A9/">
                     
										    03-1内存条选择
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-2%E5%86%85%E6%A0%B8%E5%8F%AF%E8%B0%83%E5%8F%82%E6%95%B0/">
                     
										    03-2内核可调参数
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-3%20%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F/">
                     
										    03-3 页面大小
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2024/01/20/%E4%BC%98%E5%8C%96/02%20%E5%86%85%E5%AD%98/03-4%20%E9%81%BF%E5%85%8D%E8%B7%A8numa%E8%AE%BF%E5%AD%98/">
                     
										    03-4 避免跨numa访存
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>
	<!-- 引入正文 -->
	<div id="content">
		<div id="local-search-result"></div>
		<h1 id="article-title">
	Linux Kernel 网络协议栈之GRO
</h1>
<div class="article-meta">
	
	<span>Leah Ge</span>
	<span>2022-10-31 13:53:57</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<h1 id="linux-kernel-网络协议栈之GRO-Generic-receive-offload"><a href="#linux-kernel-网络协议栈之GRO-Generic-receive-offload" class="headerlink" title="linux kernel 网络协议栈之GRO(Generic receive offload)"></a>linux kernel 网络协议栈之GRO(Generic receive offload)</h1><p>GRO(Generic receive offload)在内核2.6.29之后合并进去的，作者是一个华裔Herbert Xu ,GRO的简介可以看这里：</p>
<p><a target="_blank" rel="noopener" href="http://lwn.net/Articles/358910/">http://lwn.net/Articles/358910/</a></p>
<p>先来描述一下GRO的作用，GRO是针对网络接受包的处理的，并且只是针对NAPI类型的驱动，因此如果要支持GRO，不仅要内核支持，而且驱动也必须调用相应的借口，用ethtool -K gro on来设置，如果报错就说明网卡驱动本身就不支持GRO。</p>
<p>GRO类似tso，可是tso只支持发送数据包，这样你tcp层大的段会在网卡被切包，然后再传递给对端，而如果没有gro，则小的段会被一个个送到协议栈，有了gro之后，就会在接收端做一个反向的操作(想对于tso).也就是将tso切好的数据包组合成大包再传递给协议栈。</p>
<p>如果实现了GRO支持的驱动是这样子处理数据的，在NAPI的回调poll方法中读取数据包，然后调用GRO的接口napi_gro_receive或者napi_gro_frags来将数据包feed进协议栈。而具体GRO的工作就是在这两个函数中进行的，他们最终都会调用__napi_gro_receive。下面就是napi_gro_receive，它最终会调用napi_skb_finish以及__napi_gro_receive。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">gro_result_t</span> <span class="title">napi_gro_receive</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">skb_gro_reset_offset</span>(skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">napi_skb_finish</span>(__napi_gro_receive(napi, skb), skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后GRO什么时候会将数据feed进协议栈呢，这里会有两个退出点，一个是在napi_skb_finish里，他会通过判断__napi_gro_receive的返回值，来决定是需要将数据包立即feed进协议栈还是保存起来，还有一个点是当napi的循环执行完毕时，也就是执行napi_complete的时候，先来看napi_skb_finish,napi_complete我们后面会详细介绍。</p>
<p>在NAPI驱动中，直接调用netif_receive_skb会将数据feed 进协议栈，因此这里如果返回值是NORMAL，则直接调用netif_receive_skb来将数据送进协议栈。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">gro_result_t</span> <span class="title">napi_skb_finish</span><span class="params">(<span class="type">gro_result_t</span> ret, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">	<span class="keyword">case</span> GRO_NORMAL:</span><br><span class="line"><span class="comment">//将数据包送进协议栈</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">netif_receive_skb</span>(skb))</span><br><span class="line">			ret = GRO_DROP;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//表示skb可以被free，因为gro已经将skb合并并保存起来。</span></span><br><span class="line">	<span class="keyword">case</span> GRO_DROP:</span><br><span class="line">	<span class="keyword">case</span> GRO_MERGED_FREE:</span><br><span class="line"><span class="comment">//free skb</span></span><br><span class="line">		<span class="built_in">kfree_skb</span>(skb);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//这个表示当前数据已经被gro保存起来，但是并没有进行合并，因此skb还需要保存。</span></span><br><span class="line">	<span class="keyword">case</span> GRO_HELD:</span><br><span class="line">	<span class="keyword">case</span> GRO_MERGED:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GRO的主要思想就是，组合一些类似的数据包(基于一些数据域，后面会介绍到)为一个大的数据包(一个skb)，然后feed给协议栈，这里主要是利用Scatter-gather IO，也就是skb的struct skb_shared_info域(我前面的blog讲述ip分片的时候有详细介绍这个域)来合并数据包。</p>
<p>在每个NAPI的实例都会包括一个域叫gro_list,保存了我们积攒的数据包(将要被merge的).然后每次进来的skb都会在这个链表里面进行查找，看是否需要merge。而gro_count表示当前的gro_list中的skb的个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">napi_struct</span> &#123;</span><br><span class="line">................................................</span><br><span class="line"><span class="comment">//个数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		gro_count;</span><br><span class="line">......................................</span><br><span class="line"><span class="comment">//积攒的数据包</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span>		*gro_list;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span>		*skb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>紧接着是gro最核心的一个数据结构napi_gro_cb,它是保存在skb的cb域中，它保存了gro要使用到的一些上下文，这里每个域kernel的注释都比较清楚。到后面我们会看到这些域的具体用途。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">napi_gro_cb</span> &#123;</span><br><span class="line">	<span class="comment">/* Virtual address of skb_shinfo(skb)-&gt;frags[0].page + offset. */</span></span><br><span class="line">	<span class="type">void</span> *frag0;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Length of frag0. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> frag0_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This indicates where we are processing relative to skb-&gt;data. */</span></span><br><span class="line">	<span class="type">int</span> data_offset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This is non-zero if the packet may be of the same flow. */</span></span><br><span class="line">	<span class="type">int</span> same_flow;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This is non-zero if the packet cannot be merged with the new skb. */</span></span><br><span class="line">	<span class="type">int</span> flush;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of segments aggregated. */</span></span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Free the skb? */</span></span><br><span class="line">	<span class="type">int</span> free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每一层协议都实现了自己的gro回调函数，gro_receive和gro_complete，gro系统会根据协议来调用对应回调函数，其中gro_receive是将输入skb尽量合并到我们gro_list中。而gro_complete则是当我们需要提交gro合并的数据包到协议栈时被调用的。</p>
<p>下面就是ip层和tcp层对应的回调方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">net_protocol</span> tcp_protocol = &#123;</span><br><span class="line">	.handler =	tcp_v4_rcv,</span><br><span class="line">	.err_handler =	tcp_v4_err,</span><br><span class="line">	.gso_send_check = tcp_v4_gso_send_check,</span><br><span class="line">	.gso_segment =	tcp_tso_segment,</span><br><span class="line"><span class="comment">//gso回调</span></span><br><span class="line">	.gro_receive =	tcp4_gro_receive,</span><br><span class="line">	.gro_complete =	tcp4_gro_complete,</span><br><span class="line">	.no_policy =	<span class="number">1</span>,</span><br><span class="line">	.netns_ok =	<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">packet_type</span> ip_packet_type __read_mostly = &#123;</span><br><span class="line">	.type = <span class="built_in">cpu_to_be16</span>(ETH_P_IP),</span><br><span class="line">	.func = ip_rcv,</span><br><span class="line">	.gso_send_check = inet_gso_send_check,</span><br><span class="line">	.gso_segment = inet_gso_segment,</span><br><span class="line"><span class="comment">//gso回调</span></span><br><span class="line">	.gro_receive = inet_gro_receive,</span><br><span class="line">	.gro_complete = inet_gro_complete,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>gro的入口函数是napi_gro_receive，它的实现很简单，就是将skb包含的gro上下文reset，然后调用__napi_gro_receive,最终通过napi_skb_finis来判断是否需要讲数据包feed进协议栈。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">gro_result_t</span> <span class="title">napi_gro_receive</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//reset gro对应的域</span></span><br><span class="line">	<span class="built_in">skb_gro_reset_offset</span>(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">napi_skb_finish</span>(__napi_gro_receive(napi, skb), skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>napi_skb_finish一开始已经介绍过了，这个函数主要是通过判断传递进来的ret(__napi_gro_receive的返回值),来决定是否需要feed数据进协议栈。它的第二个参数是前面处理过的skb。</p>
<p>这里再来看下skb_gro_reset_offset，首先要知道一种情况，那就是skb本身不包含数据(包括头也没有),而所有的数据都保存在skb_shared_info中(支持S&#x2F;G的网卡有可能会这么做).此时我们如果想要合并的话，就需要将包头这些信息取出来，也就是从skb_shared_info的frags[0]中去的，在 skb_gro_reset_offset中就有做这个事情,而这里就会把头的信息保存到napi_gro_cb 的frags0中。并且此时frags必然不会在high mem,要么是线性区，要么是dma(S&#x2F;G io)。 来看skb_gro_reset_offset。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">skb_gro_reset_offset</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;data_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;frag0 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;frag0_len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//如果mac_header和skb-&gt;tail相等并且地址不在高端内存，则说明包头保存在skb_shinfo中，所以我们需要从frags中取得对应的数据包</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;mac_header == skb-&gt;tail &amp;&amp;</span><br><span class="line">	    !<span class="built_in">PageHighMem</span>(<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].page)) &#123;</span><br><span class="line"><span class="comment">//可以看到frag0保存的就是对应的skb的frags的第一个元素的地址</span></span><br><span class="line">		<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;frag0 =</span><br><span class="line">			<span class="built_in">page_address</span>(<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].page) +</span><br><span class="line">			<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].page_offset;</span><br><span class="line"><span class="comment">//然后保存对应的大小。</span></span><br><span class="line">		<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;frag0_len = <span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是__napi_gro_receive，它主要是遍历gro_list,然后给same_flow赋值，这里要注意，same_flow是一个标记，表示某个skb是否有可能会和当前要处理的skb是相同的流,而这里的相同会在每层都进行判断，也就是在设备层，ip层，tcp层都会判断，这里就是设备层的判断了。这里的判断很简单，有2个条件：<br>1 设备是否相同<br>2 mac的头必须相等</p>
<p>如果上面两个条件都满足，则说明两个skb有可能是相同的flow，所以设置same_flow,以便与我们后面合并。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">gro_result_t</span></span><br><span class="line">__napi_gro_receive(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">netpoll_rx_on</span>(skb))</span><br><span class="line">		<span class="keyword">return</span> GRO_NORMAL;</span><br><span class="line"><span class="comment">//遍历gro_list,然后判断是否有可能两个skb 相似。</span></span><br><span class="line">	<span class="keyword">for</span> (p = napi-&gt;gro_list; p; p = p-&gt;next) &#123;</span><br><span class="line"><span class="comment">//给same_flow赋值</span></span><br><span class="line">		<span class="built_in">NAPI_GRO_CB</span>(p)-&gt;same_flow =</span><br><span class="line">			(p-&gt;dev == skb-&gt;dev) &amp;&amp;</span><br><span class="line">			!<span class="built_in">compare_ether_header</span>(<span class="built_in">skb_mac_header</span>(p),</span><br><span class="line">					      <span class="built_in">skb_gro_mac_header</span>(skb));</span><br><span class="line">		<span class="built_in">NAPI_GRO_CB</span>(p)-&gt;flush = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//调用dev_gro_receiv</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dev_gro_receive</span>(napi, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来来看dev_gro_receive，这个函数我们分做两部分来看，第一部分是正常处理部分，第二部份是处理frag0的部分。</p>
<p>来看如何判断是否支持GRO，这里每个设备的features会在驱动初始化的时候被初始化，然后如果支持GRO，则会包括NETIF_F_GRO。 还有要注意的就是，gro不支持切片的ip包，因为ip切片的组包在内核的ip会做一遍，因此这里gro如果合并的话，没有多大意义，而且还增加复杂度。</p>
<p>在dev_gro_receive中会遍历对应的ptype(也就是协议的类链表，以前的blog有详细介绍),然后调用对应的回调函数，一般来说这里会调用文章开始说的ip_packet_type，也就是 inet_gro_receive。</p>
<p>而 inet_gro_receive的返回值表示我们需要立刻feed 进协议栈的数据包，如果为空，则说明不需要feed数据包进协议栈。后面会分析到这里他的详细算法。</p>
<p>而如果当inet_gro_receive正确返回后，如果same_flow没有被设置，则说明gro list中不存在能和当前的skb合并的项，因此此时需要将skb插入到gro list中。这个时候的返回值就是HELD。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> gro_result <span class="title">dev_gro_receive</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> **pp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">packet_type</span> *ptype;</span><br><span class="line">	__be16 type = skb-&gt;protocol;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> *head = &amp;ptype_base[<span class="built_in">ntohs</span>(type) &amp; PTYPE_HASH_MASK];</span><br><span class="line">	<span class="type">int</span> same_flow;</span><br><span class="line">	<span class="type">int</span> mac_len;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">gro_result</span> ret;</span><br><span class="line"><span class="comment">//判断是否支持gro</span></span><br><span class="line">	<span class="keyword">if</span> (!(skb-&gt;dev-&gt;features &amp; NETIF_F_GRO))</span><br><span class="line">		<span class="keyword">goto</span> normal;</span><br><span class="line"><span class="comment">//判断是否为切片的ip包</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">skb_is_gso</span>(skb) || <span class="built_in">skb_has_frags</span>(skb))</span><br><span class="line">		<span class="keyword">goto</span> normal;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rcu_read_lock</span>();</span><br><span class="line"><span class="comment">//开始遍历对应的协议表</span></span><br><span class="line">	<span class="built_in">list_for_each_entry_rcu</span>(ptype, head, list) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ptype-&gt;type != type || ptype-&gt;dev || !ptype-&gt;gro_receive)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">skb_set_network_header</span>(skb, <span class="built_in">skb_gro_offset</span>(skb));</span><br><span class="line">		mac_len = skb-&gt;network_header - skb-&gt;mac_header;</span><br><span class="line">		skb-&gt;mac_len = mac_len;</span><br><span class="line">		<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;same_flow = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;flush = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;free = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//调用对应的gro接收函数</span></span><br><span class="line">		pp = ptype-&gt;<span class="built_in">gro_receive</span>(&amp;napi-&gt;gro_list, skb);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rcu_read_unlock</span>();</span><br><span class="line"><span class="comment">//如果是没有实现gro的协议则也直接调到normal处理</span></span><br><span class="line">	<span class="keyword">if</span> (&amp;ptype-&gt;list == head)</span><br><span class="line">		<span class="keyword">goto</span> normal;</span><br><span class="line"></span><br><span class="line"><span class="comment">//到达这里，则说明gro_receive已经调用过了，因此进行后续的处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到same_flow</span></span><br><span class="line">	same_flow = <span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;same_flow;</span><br><span class="line"><span class="comment">//看是否有需要free对应的skb</span></span><br><span class="line">	ret = <span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;free ? GRO_MERGED_FREE : GRO_MERGED;</span><br><span class="line"><span class="comment">//如果返回值pp部位空，则说明pp需要马上被feed进协议栈</span></span><br><span class="line">	<span class="keyword">if</span> (pp) &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *nskb = *pp;</span><br><span class="line"></span><br><span class="line">		*pp = nskb-&gt;next;</span><br><span class="line">		nskb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//调用napi_gro_complete 将pp刷进协议栈</span></span><br><span class="line">		<span class="built_in">napi_gro_complete</span>(nskb);</span><br><span class="line">		napi-&gt;gro_count--;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//如果same_flow有设置，则说明skb已经被正确的合并，因此直接返回。</span></span><br><span class="line">	<span class="keyword">if</span> (same_flow)</span><br><span class="line">		<span class="keyword">goto</span> ok;</span><br><span class="line"><span class="comment">//查看是否有设置flush和gro list的个数是否已经超过限制</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;flush || napi-&gt;gro_count &gt;= MAX_GRO_SKBS)</span><br><span class="line">		<span class="keyword">goto</span> normal;</span><br><span class="line"></span><br><span class="line"><span class="comment">//到达这里说明skb对应gro list来说是一个新的skb，也就是说当前的gro list并不存在可以和skb合并的数据包，因此此时将这个skb插入到gro_list的头。</span></span><br><span class="line">	napi-&gt;gro_count++;</span><br><span class="line">	<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;count = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">skb_shinfo</span>(skb)-&gt;gso_size = <span class="built_in">skb_gro_len</span>(skb);</span><br><span class="line"><span class="comment">//将skb插入到gro list的头</span></span><br><span class="line">	skb-&gt;next = napi-&gt;gro_list;</span><br><span class="line">	napi-&gt;gro_list = skb;</span><br><span class="line"><span class="comment">//设置返回值</span></span><br><span class="line">	ret = GRO_HELD;</span><br></pre></td></tr></table></figure>

<p>然后就是处理frag0的部分，以及不支持gro的处理。</p>
<p>这里要需要对skb_shinfo的结构比较了解，我在以前的blog对这个有很详细的介绍，可以去查阅。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pull:</span><br><span class="line"><span class="comment">//是否需要拷贝头</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">skb_headlen</span>(skb) &lt; <span class="built_in">skb_gro_offset</span>(skb)) &#123;</span><br><span class="line"><span class="comment">//得到对应的头的大小</span></span><br><span class="line">		<span class="type">int</span> grow = <span class="built_in">skb_gro_offset</span>(skb) - <span class="built_in">skb_headlen</span>(skb);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">BUG_ON</span>(skb-&gt;end - skb-&gt;tail &lt; grow);</span><br><span class="line"><span class="comment">//开始拷贝</span></span><br><span class="line">		<span class="built_in">memcpy</span>(<span class="built_in">skb_tail_pointer</span>(skb), <span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;frag0, grow);</span><br><span class="line"></span><br><span class="line">		skb-&gt;tail += grow;</span><br><span class="line">		skb-&gt;data_len -= grow;</span><br><span class="line"><span class="comment">//更新对应的frags[0]</span></span><br><span class="line">		<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].page_offset += grow;</span><br><span class="line">		<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].size -= grow;</span><br><span class="line"><span class="comment">//如果size为0了，则说明第一个页全部包含头，因此需要将后面的页全部移动到前面。</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].size)) &#123;</span><br><span class="line">			<span class="built_in">put_page</span>(<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[<span class="number">0</span>].page);</span><br><span class="line"><span class="comment">//开始移动。</span></span><br><span class="line">			<span class="built_in">memmove</span>(<span class="built_in">skb_shinfo</span>(skb)-&gt;frags,</span><br><span class="line">				<span class="built_in">skb_shinfo</span>(skb)-&gt;frags + <span class="number">1</span>,</span><br><span class="line">				--<span class="built_in">skb_shinfo</span>(skb)-&gt;nr_frags * <span class="built_in">sizeof</span>(<span class="type">skb_frag_t</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">normal:</span><br><span class="line">	ret = GRO_NORMAL;</span><br><span class="line">	<span class="keyword">goto</span> pull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是inet_gro_receive，这个函数是ip层的gro receive回调函数，函数很简单，首先取得ip头，然后判断是否需要从frag复制数据，如果需要则复制数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到偏移</span></span><br><span class="line">		off = <span class="built_in">skb_gro_offset</span>(skb);</span><br><span class="line"><span class="comment">//得到头的整个长度(mac+ip)</span></span><br><span class="line">	hlen = off + <span class="built_in">sizeof</span>(*iph);</span><br><span class="line"><span class="comment">//得到ip头</span></span><br><span class="line">	iph = <span class="built_in">skb_gro_header_fast</span>(skb, off);</span><br><span class="line"><span class="comment">//是否需要复制</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">skb_gro_header_hard</span>(skb, hlen)) &#123;</span><br><span class="line">		iph = <span class="built_in">skb_gro_header_slow</span>(skb, hlen, off);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!iph))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是一些校验工作，比如协议是否支持gro_reveive,ip头是否合法等等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	proto = iph-&gt;protocol &amp; (MAX_INET_PROTOS - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rcu_read_lock</span>();</span><br><span class="line">	ops = <span class="built_in">rcu_dereference</span>(inet_protos[proto]);</span><br><span class="line"><span class="comment">//是否支持gro</span></span><br><span class="line">	<span class="keyword">if</span> (!ops || !ops-&gt;gro_receive)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="comment">//ip头是否合法</span></span><br><span class="line">	<span class="keyword">if</span> (*(u8 *)iph != <span class="number">0x45</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="comment">//ip头教研</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">ip_fast_csum</span>((u8 *)iph, iph-&gt;ihl)))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br></pre></td></tr></table></figure>

<p>然后就是核心的处理部分，它会遍历整个gro_list,然后进行same_flow和是否需要flush的判断。</p>
<p>这里ip层设置same_flow是根据下面的规则的:<br>1 4层的协议必须相同<br>2 tos域必须相同<br>3 源，目的地址必须相同</p>
<p>如果3个条件一个不满足，则会设置same_flow为0。<br>这里还有一个就是判断是否需要flush 对应的skb到协议栈，这里的判断条件是这样子的。<br>1 ip包的ttl不一样<br>2 ip包的id顺序不对<br>3 如果是切片包</p>
<p>如果上面两个条件某一个满足，则说明skb需要被flush出gro。</p>
<p>不过这里要注意只有两个数据包是same flow的情况下，才会进行flush判断。原因很简单，都不是有可能进行merge的包，自然没必要进行flush了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出id</span></span><br><span class="line">	id = <span class="built_in">ntohl</span>(*(__be32 *)&amp;iph-&gt;id);</span><br><span class="line"><span class="comment">//判断是否需要切片</span></span><br><span class="line">	flush = (u16)((<span class="built_in">ntohl</span>(*(__be32 *)iph) ^ <span class="built_in">skb_gro_len</span>(skb)) | (id ^ IP_DF));</span><br><span class="line">	id &gt;&gt;= <span class="number">16</span>;</span><br><span class="line"><span class="comment">//开始遍历gro list</span></span><br><span class="line">	<span class="keyword">for</span> (p = *head; p; p = p-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">iphdr</span> *iph2;</span><br><span class="line"><span class="comment">//如果上一层已经不可能same flow则直接继续下一个</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">NAPI_GRO_CB</span>(p)-&gt;same_flow)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//取出ip头</span></span><br><span class="line">		iph2 = <span class="built_in">ip_hdr</span>(p);</span><br><span class="line"><span class="comment">//开始same flow的判断</span></span><br><span class="line">		<span class="keyword">if</span> ((iph-&gt;protocol ^ iph2-&gt;protocol) |</span><br><span class="line">		    (iph-&gt;tos ^ iph2-&gt;tos) |</span><br><span class="line">		    ((__force u32)iph-&gt;saddr ^ (__force u32)iph2-&gt;saddr) |</span><br><span class="line">		    ((__force u32)iph-&gt;daddr ^ (__force u32)iph2-&gt;daddr)) &#123;</span><br><span class="line">			<span class="built_in">NAPI_GRO_CB</span>(p)-&gt;same_flow = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//开始flush的判断。这里注意如果不是same_flow的话，就没必要进行flush的判断。</span></span><br><span class="line">		<span class="comment">/* All fields must match except length and checksum. */</span></span><br><span class="line">		<span class="built_in">NAPI_GRO_CB</span>(p)-&gt;flush |=</span><br><span class="line">			(iph-&gt;ttl ^ iph2-&gt;ttl) |</span><br><span class="line">			((u16)(<span class="built_in">ntohs</span>(iph2-&gt;id) + <span class="built_in">NAPI_GRO_CB</span>(p)-&gt;count) ^ id);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">NAPI_GRO_CB</span>(p)-&gt;flush |= flush;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;flush |= flush;</span><br><span class="line"><span class="comment">//pull ip头进gro，这里更新data_offset</span></span><br><span class="line">	<span class="built_in">skb_gro_pull</span>(skb, <span class="built_in">sizeof</span>(*iph));</span><br><span class="line"><span class="comment">//设置传输层的头的位置</span></span><br><span class="line">	<span class="built_in">skb_set_transport_header</span>(skb, <span class="built_in">skb_gro_offset</span>(skb));</span><br><span class="line"><span class="comment">//调用传输层的reveive方法。</span></span><br><span class="line">	pp = ops-&gt;<span class="built_in">gro_receive</span>(head, skb);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	<span class="built_in">rcu_read_unlock</span>();</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;flush |= flush;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是tcp层的gro方法，它的主要实现函数是tcp_gro_receive，他的流程和inet_gro_receiv类似，就是取得tcp的头，然后对gro list进行遍历，最终会调用合并方法。</p>
<p>首先来看gro list遍历的部分,它对same flow的要求就是source必须相同，如果不同则设置same flow为0.如果相同则跳到found部分，进行合并处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历gro list</span></span><br><span class="line">	<span class="keyword">for</span> (; (p = *head); head = &amp;p-&gt;next) &#123;</span><br><span class="line"><span class="comment">//如果ip层已经不可能same flow则直接进行下一次匹配</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">NAPI_GRO_CB</span>(p)-&gt;same_flow)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		th2 = <span class="built_in">tcp_hdr</span>(p);</span><br><span class="line"><span class="comment">//判断源地址</span></span><br><span class="line">		<span class="keyword">if</span> (*(u32 *)&amp;th-&gt;source ^ *(u32 *)&amp;th2-&gt;source) &#123;</span><br><span class="line">			<span class="built_in">NAPI_GRO_CB</span>(p)-&gt;same_flow = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> found;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是当找到能够合并的skb的时候的处理，这里首先来看flush的设置,这里会有4个条件：<br>1 拥塞状态被设置(TCP_FLAG_CWR).<br>2 tcp的ack的序列号不匹配 (这是肯定的，因为它只是对tso或者说gso进行反向操作)<br>3 skb的flag和从gro list中查找到要合并skb的flag 如果他们中的不同位 不包括TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH，这三个任意一个域。<br>4 tcp的option域不同</p>
<p>如果上面4个条件有一个满足，则会设置flush为1，也就是找到的这个skb(gro list中)必须被刷出到协议栈。</p>
<p>这里谈一下flags域的设置问题首先如果当前的skb设置了cwr，也就是发生了拥塞，那么自然前面被缓存的数据包需要马上被刷到协议栈，以便与tcp的拥塞控制马上进行。</p>
<p>而FIN和PSH这两个flag自然不需要一致，因为这两个和其他的不是互斥的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">found:</span><br><span class="line">	flush = <span class="built_in">NAPI_GRO_CB</span>(p)-&gt;flush;</span><br><span class="line"><span class="comment">//如果设置拥塞，则肯定需要刷出skb到协议栈</span></span><br><span class="line">	flush |= (__force <span class="type">int</span>)(flags &amp; TCP_FLAG_CWR);</span><br><span class="line"><span class="comment">//如果相差的域是除了这3个中的，就需要flush出skb</span></span><br><span class="line">	flush |= (__force <span class="type">int</span>)((flags ^ <span class="built_in">tcp_flag_word</span>(th2)) &amp;</span><br><span class="line">		  ~(TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH));</span><br><span class="line"><span class="comment">//ack的序列号必须一致</span></span><br><span class="line">	flush |= (__force <span class="type">int</span>)(th-&gt;ack_seq ^ th2-&gt;ack_seq);</span><br><span class="line"><span class="comment">//tcp的option头必须一致</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="built_in">sizeof</span>(*th); i &lt; thlen; i += <span class="number">4</span>)</span><br><span class="line">		flush |= *(u32 *)((u8 *)th + i) ^</span><br><span class="line">			 *(u32 *)((u8 *)th2 + i);</span><br><span class="line"></span><br><span class="line">	mss = <span class="built_in">skb_shinfo</span>(p)-&gt;gso_size;</span><br><span class="line"></span><br><span class="line">	flush |= (len - <span class="number">1</span>) &gt;= mss;</span><br><span class="line">	flush |= (<span class="built_in">ntohl</span>(th2-&gt;seq) + <span class="built_in">skb_gro_len</span>(p)) ^ <span class="built_in">ntohl</span>(th-&gt;seq);</span><br><span class="line"><span class="comment">//如果flush有设置则不会调用 skb_gro_receive，也就是不需要进行合并，否则调用skb_gro_receive进行数据包合并</span></span><br><span class="line">	<span class="keyword">if</span> (flush || <span class="built_in">skb_gro_receive</span>(head, skb)) &#123;</span><br><span class="line">		mss = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> out_check_final;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p = *head;</span><br><span class="line">	th2 = <span class="built_in">tcp_hdr</span>(p);</span><br><span class="line"><span class="comment">//更新p的头。到达这里说明合并完毕，因此需要更新合并完的新包的头。</span></span><br><span class="line">	<span class="built_in">tcp_flag_word</span>(th2) |= flags &amp; (TCP_FLAG_FIN | TCP_FLAG_PSH);</span><br></pre></td></tr></table></figure>

<p>从上面我们可以看到如果tcp的包被设置了一些特殊的flag比如PSH，SYN这类的就必须马上把数据包刷出到协议栈。</p>
<p>下面就是最终的一些flags判断,比如第一个数据包进来都会到这里来判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">out_check_final:</span><br><span class="line">	flush = len &lt; mss;</span><br><span class="line"><span class="comment">//根据flag得到flush</span></span><br><span class="line">	flush |= (__force <span class="type">int</span>)(flags &amp; (TCP_FLAG_URG | TCP_FLAG_PSH |</span><br><span class="line">					TCP_FLAG_RST | TCP_FLAG_SYN |</span><br><span class="line">					TCP_FLAG_FIN));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; (!<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;same_flow || flush))</span><br><span class="line">		pp = head;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;flush |= flush;</span><br></pre></td></tr></table></figure>

<p>这里要知道每次我们只会刷出gro list中的一个skb节点，这是因为每次进来的数据包我们也只会匹配一个。因此如果遇到需要刷出的数据包，会在dev_gro_receive中先刷出gro list中的，然后再将当前的skb feed进协议栈。</p>
<p>最后就是gro最核心的一个函数skb_gro_receive，它的主要工作就是合并，它有2个参数，第一个是gro list中和当前处理的skb是same flow的skb，第二个就是我们需要合并的skb。</p>
<p>这里要注意就是farg_list,其实gro对待skb_shared_info和ip层切片，组包很类似，就是frags放Scatter-Gather I&#x2F;O的数据包，frag_list放线性数据。这里gro 也是这样的，如果过来的skb支持Scatter-Gather I&#x2F;O并且数据是只放在frags中，则会合并frags，如果过来的skb不支持Scatter-Gather I&#x2F;O(数据头还是保存在skb中)，则合并很简单，就是新建一个skb然后拷贝当前的skb，并将gro list中的skb直接挂载到farg_list。</p>
<p>先来看支持Scatter-Gather I&#x2F;O的处理部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一些需要用到的变量</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *p = *head;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sk_buff</span> *nskb;</span><br><span class="line"><span class="comment">//当前的skb的 share_ino</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">skb_shared_info</span> *skbinfo = <span class="built_in">skb_shinfo</span>(skb);</span><br><span class="line"><span class="comment">//当前的gro list中的要合并的skb的share_info</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">skb_shared_info</span> *pinfo = <span class="built_in">skb_shinfo</span>(p);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> headroom;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> len = <span class="built_in">skb_gro_len</span>(skb);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset = <span class="built_in">skb_gro_offset</span>(skb);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> headlen = <span class="built_in">skb_headlen</span>(skb);</span><br><span class="line"><span class="comment">//如果有frag_list的话，则直接去非Scatter-Gather I/O部分处理，也就是合并到frag_list.</span></span><br><span class="line">	<span class="keyword">if</span> (pinfo-&gt;frag_list)</span><br><span class="line">		<span class="keyword">goto</span> merge;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (headlen &lt;= offset) &#123;</span><br><span class="line"><span class="comment">//支持Scatter-Gather I/O的处理</span></span><br><span class="line">		<span class="type">skb_frag_t</span> *frag;</span><br><span class="line">		<span class="type">skb_frag_t</span> *frag2;</span><br><span class="line">		<span class="type">int</span> i = skbinfo-&gt;nr_frags;</span><br><span class="line"><span class="comment">//这里遍历是从后向前。</span></span><br><span class="line">		<span class="type">int</span> nr_frags = pinfo-&gt;nr_frags + i;</span><br><span class="line"></span><br><span class="line">		offset -= headlen;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nr_frags &gt; MAX_SKB_FRAGS)</span><br><span class="line">			<span class="keyword">return</span> -E2BIG;</span><br><span class="line"><span class="comment">//设置pinfo的frags的大小，可以看到就是加上skb的frags的大小</span></span><br><span class="line">		pinfo-&gt;nr_frags = nr_frags;</span><br><span class="line">		skbinfo-&gt;nr_frags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		frag = pinfo-&gt;frags + nr_frags;</span><br><span class="line">		frag2 = skbinfo-&gt;frags + i;</span><br><span class="line"><span class="comment">//遍历赋值，其实就是地址赋值，这里就是将skb的frag加到pinfo的frgas后面。</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			*--frag = *--frag2;</span><br><span class="line">		&#125; <span class="keyword">while</span> (--i);</span><br><span class="line"><span class="comment">//更改page_offet的值</span></span><br><span class="line">		frag-&gt;page_offset += offset;</span><br><span class="line"><span class="comment">//修改size大小</span></span><br><span class="line">		frag-&gt;size -= offset;</span><br><span class="line"><span class="comment">//更新skb的相关值</span></span><br><span class="line">		skb-&gt;truesize -= skb-&gt;data_len;</span><br><span class="line">		skb-&gt;len -= skb-&gt;data_len;</span><br><span class="line">		skb-&gt;data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">NAPI_GRO_CB</span>(skb)-&gt;free = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//最终完成</span></span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">skb_gro_len</span>(p) != pinfo-&gt;gso_size)</span><br><span class="line">		<span class="keyword">return</span> -E2BIG;</span><br></pre></td></tr></table></figure>

<p>这里gro list中的要被合并的skb我们叫做skb_s.</p>
<p>接下来就是不支持支持Scatter-Gather I&#x2F;O(skb的头放在skb中)的处理。这里处理也比较简单，就是复制一个新的nskb，然后它的头和skb_s一样，然后将skb_s挂载到nskb的frag_list上，并且把新建的nskb挂在到gro list中，代替skb_s的位置，而当前的skb</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">	headroom = <span class="built_in">skb_headroom</span>(p);</span><br><span class="line">	nskb = <span class="built_in">alloc_skb</span>(headroom + <span class="built_in">skb_gro_offset</span>(p), GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(!nskb))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="comment">//复制头</span></span><br><span class="line">	__copy_skb_header(nskb, p);</span><br><span class="line">	nskb-&gt;mac_len = p-&gt;mac_len;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">skb_reserve</span>(nskb, headroom);</span><br><span class="line">	__skb_put(nskb, <span class="built_in">skb_gro_offset</span>(p));</span><br><span class="line"><span class="comment">//设置各层的头</span></span><br><span class="line">	<span class="built_in">skb_set_mac_header</span>(nskb, <span class="built_in">skb_mac_header</span>(p) - p-&gt;data);</span><br><span class="line">	<span class="built_in">skb_set_network_header</span>(nskb, <span class="built_in">skb_network_offset</span>(p));</span><br><span class="line">	<span class="built_in">skb_set_transport_header</span>(nskb, <span class="built_in">skb_transport_offset</span>(p));</span><br><span class="line"></span><br><span class="line">	__skb_pull(p, <span class="built_in">skb_gro_offset</span>(p));</span><br><span class="line"><span class="comment">//复制数据</span></span><br><span class="line">	<span class="built_in">memcpy</span>(<span class="built_in">skb_mac_header</span>(nskb), <span class="built_in">skb_mac_header</span>(p),</span><br><span class="line">	       p-&gt;data - <span class="built_in">skb_mac_header</span>(p));</span><br><span class="line"><span class="comment">//对应的gro 域的赋值</span></span><br><span class="line">	*<span class="built_in">NAPI_GRO_CB</span>(nskb) = *<span class="built_in">NAPI_GRO_CB</span>(p);</span><br><span class="line"><span class="comment">//可以看到frag_list被赋值</span></span><br><span class="line">	<span class="built_in">skb_shinfo</span>(nskb)-&gt;frag_list = p;</span><br><span class="line">	<span class="built_in">skb_shinfo</span>(nskb)-&gt;gso_size = pinfo-&gt;gso_size;</span><br><span class="line">	pinfo-&gt;gso_size = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">skb_header_release</span>(p);</span><br><span class="line">	nskb-&gt;prev = p;</span><br><span class="line"><span class="comment">//更新新的skb的数据段</span></span><br><span class="line">	nskb-&gt;data_len += p-&gt;len;</span><br><span class="line">	nskb-&gt;truesize += p-&gt;len;</span><br><span class="line">	nskb-&gt;len += p-&gt;len;</span><br><span class="line"><span class="comment">//将新的skb插入到gro list中</span></span><br><span class="line">	*head = nskb;</span><br><span class="line">	nskb-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	p = nskb;</span><br><span class="line"></span><br><span class="line">merge:</span><br><span class="line">	<span class="keyword">if</span> (offset &gt; headlen) &#123;</span><br><span class="line">		skbinfo-&gt;frags[<span class="number">0</span>].page_offset += offset - headlen;</span><br><span class="line">		skbinfo-&gt;frags[<span class="number">0</span>].size -= offset - headlen;</span><br><span class="line">		offset = headlen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__skb_pull(skb, offset);</span><br><span class="line"><span class="comment">//将skb插入新的skb的(或者老的skb，当frag list本身存在)fraglist</span></span><br><span class="line">	p-&gt;prev-&gt;next = skb;</span><br><span class="line">	p-&gt;prev = skb;</span><br><span class="line">	<span class="built_in">skb_header_release</span>(skb);</span><br></pre></td></tr></table></figure>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2022/10/31/01%20OS/Linux/Kernel/kernel_config/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  Linux Kernel 编译选项
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2022/10/28/01%20OS/Linux/Perf/perf_event/">
                PMU计数器
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>

	</div>
	<div id="footer">
	<p>
	©2022-<span id="footerYear"></span> 
	<a href="/">Leah Ge</a> 
	
	
	<br>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>
