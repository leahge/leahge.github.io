<!DOCTYPE html>
<!-- saved from url=(0072)https://zh-blog.logan.tw/2019/10/06/intro-to-perf-events-and-call-graph/ -->
<html lang="zh-hant"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>簡介 perf_events 與 Call Graph | 羅根學習筆記</title>

	
	<link href="https://zh-blog.logan.tw/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="羅根學習筆記 Full Atom Feed">
	<link href="https://zh-blog.logan.tw/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="羅根學習筆記 Atom Feed">
	<link href="https://zh-blog.logan.tw/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="羅根學習筆記 RSS Feed">
	<link href="https://zh-blog.logan.tw/feeds/2019.atom.xml" type="application/atom+xml" rel="alternate" title="羅根學習筆記 Categories Atom Feed">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" type="text/css" href="./簡介 perf_events 與 Call Graph_files/css">
	<link rel="stylesheet" type="text/css" href="./簡介 perf_events 與 Call Graph_files/main.css" media="all">
	<link rel="stylesheet" type="text/css" href="./簡介 perf_events 與 Call Graph_files/pygment.css" media="all">

	<link rel="apple-touch-icon" sizes="180x180" href="https://zh-blog.logan.tw/theme/images/favicon-180.png">
	<link rel="icon" type="image/png" href="https://zh-blog.logan.tw/theme/images/favicon-192.png" sizes="192x192">
	<link rel="icon" type="image/png" href="https://zh-blog.logan.tw/theme/images/favicon-96.png" sizes="96x96">
	<link rel="icon" type="image/png" href="https://zh-blog.logan.tw/theme/images/favicon-32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="https://zh-blog.logan.tw/theme/images/favicon-16.png" sizes="16x16">

	<!--[if lte IE 8]>
	<script type="text/javascript" src="/theme/js/respond.min.js"></script>
	<![endif]-->


	<meta name="tags" content="performance">
	<meta name="tags" content="linux">
	<meta name="tags" content="flamegraph">

	<meta property="og:title" content="簡介 perf_events 與 Call Graph">
	<meta property="og:url" content="https://zh-blog.logan.tw/2019/10/06/intro-to-perf-events-and-call-graph/">
	<meta property="og:image" content="https://zh-blog.logan.tw/static/images/2019/10/06/perf-report-tui.png">
</head>

<body>
	<div id="container">
		<div id="content">
<h1 class="entry-title">
        <a href="https://zh-blog.logan.tw/2019/10/06/intro-to-perf-events-and-call-graph/" rel="bookmark" title="Permalink to 簡介 perf_events 與 Call Graph">簡介 perf_events 與 Call Graph</a>
</h1>



<div class="post-info">
	<time class="published" datetime="2019-10-06T17:31:00+08:00">
		Sun 06 October 2019
	</time>

	<div class="tags">
		<span class="tags-label">Tags</span>
		<a class="tags" href="https://zh-blog.logan.tw/tag/performance/">performance</a>
		<a class="tags" href="https://zh-blog.logan.tw/tag/linux/">linux</a>
		<a class="tags" href="https://zh-blog.logan.tw/tag/flamegraph/">flamegraph</a>
	</div>

	<address class="vcard author">
		Posted by <a class="url fn" href="https://zh-blog.logan.tw/author/logan/">Logan</a>	</address>
</div>

<div class="entry-content">
<p>Call Graph 是幫助 Perf Events 使用者判讀效能瓶頸成因的重要工具。Call Graph 優雅地結合「<strong>花去最多執行時間的熱區</strong>」與「<strong>為什麼要執行熱區內的程式碼</strong>」進而讓使用者能快速判斷程式有沒有改進空間。本文會從 Call Graph 的基本概念著手，再介紹記錄 Stack Trace 的注意事項與判讀 Call Graph 的方式。最後，本文會以一個文字處理程式示範如何利用 Call Graph 找出效能問題。</p>
<div class="section" id="call-graph">
<h2>Call Graph 概論</h2>
<p><code>perf report</code> 印出的 <strong>Call Graph（呼叫圖）</strong>是以各個樣本的 <strong>Stack Trace（堆疊回溯）</strong>為基礎繪製而成的樹狀圖。因此本節會依序介紹 Stack Trace 與兩種不同的 Call Graph。</p>
<div class="section" id="stack-trace">
<h3>Stack Trace</h3>
<p><strong>Stack Trace（堆疊回溯）</strong>有時又稱 <strong>Call Chain（呼叫鏈）</strong>是特定時間下 <strong>Call Stack（呼叫堆疊）</strong>的記錄。舉例來說，如果在下方程式執行到函式 <code>c</code> 的時候記錄 Call Stack，記錄到的 Stack Trace 會是 <code>main -&gt; a -&gt; b -&gt; c</code>：</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">b</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">c</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Dump Stack Trace</span>
<span class="p">}</span>
</pre></div>
<p>Stack Trace 包含「呼叫者（Caller）」與「被呼叫者（Callee）」之間的關係。在程序化程式設計（Procedural Programming）之中，呼叫者與被呼叫者之間通常有一定的因果關係，所以 <strong>Stack Trace 是尋找效能問題發生原因的重要工具</strong>。如果說最常被取樣的指令（Instruction）位址是程式執行的熱區，最常出現的 Stack Trace 就是程式進入熱區的原因。</p>
<p><a class="reference external" href="https://zh-blog.logan.tw/2019/07/10/analyze-program-performance-with-perf-events/">上一篇文章</a>提到 <code>perf record</code> 會以特定頻率取樣開發者想要測量的事件。我們能讓 <code>perf record</code> 在每次取樣時一併記錄 Stack Trace，進而蒐集大量 Stack Trace。以下方示意圖為例，橫軸為時間順序，縱軸為堆疊的變化過程，圓圈為事件的取樣點：</p>
<div class="highlight"><pre><span></span>  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o  o
+--------------------------------------------------+
|main                                              |
+--+-----------------------+-----------------------+
   |a                      |a                      |
   +--+--------+--+--------+--+--------+--+--------+
      |b       |c |b       |  |b       |c |b       |
      +--+--+--+--+--+--+--+  +--+--+--+--+--+--+--+
         |c |c |     |c |c |     |c |c |     |c |c |
         +--+--+     +--+--+     +--+--+     +--+--+
</pre></div>
<p>因為 Stack Trace 數量龐大，所以下一步是統計各種 Stack Trace 的樣本個數。如下表所示：</p>
<table border="1" class="docutils">
<colgroup>
<col width="61%">
<col width="19%">
<col width="19%">
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stack Trace</th>
<th class="head">樣本數</th>
<th class="head">百分比</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>main</td>
<td>1</td>
<td>5.9</td>
</tr>
<tr><td>main -&gt; a</td>
<td>2</td>
<td>11.8</td>
</tr>
<tr><td>main -&gt; a -&gt; b</td>
<td>4</td>
<td>23.5</td>
</tr>
<tr><td>main -&gt; a -&gt; b -&gt; c</td>
<td>8</td>
<td>47.1</td>
</tr>
<tr><td>main -&gt; a -&gt; c</td>
<td>2</td>
<td>11.8</td>
</tr>
</tbody>
</table>
<p>這個統計圖表有兩種不同的解讀方式：</p>
<ul class="simple">
<li><a class="reference internal" href="https://zh-blog.logan.tw/2019/10/06/intro-to-perf-events-and-call-graph/#caller-based-call-graph">由上而下</a>的解讀是從「第一個呼叫者（First Caller）」往「最後一個被呼叫者（Last Callee）」處理 Stack Trace 並繪製 Call Graph。</li>
<li><a class="reference internal" href="https://zh-blog.logan.tw/2019/10/06/intro-to-perf-events-and-call-graph/#callee-based-call-graph">由下而上</a>的解讀是從「最後一個被呼叫者（Last Callee）」往「第一個呼叫者（First Caller）」處理 Stack Trace 並繪製 Call Graph。</li>
</ul>
<p>這兩種解讀方式各有長處，本文僅以以下兩小節分述兩種方法的思路與使用方法。</p>
</div>
<div class="section" id="caller-based-call-graph">
<h3>Caller-based Call Graph</h3>
<p>第一種解讀方式是<strong>由上而下（Top Down）</strong>解讀統計數據。此方法會合併有<strong>共同呼叫者</strong>的 Stack Trace。換句話說，就是將 <code>x -&gt; y -&gt; z</code> 的個數加到 <code>x -&gt; y</code> 的累計數量：</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%">
<col width="10%">
<col width="23%">
<col width="6%">
<col width="31%">
</colgroup>
<thead valign="bottom">
<tr><th class="head">Stack Trace</th>
<th class="head">樣本數</th>
<th class="head">百分比（Self）</th>
<th class="head">累計</th>
<th class="head">累計百分比（Total）</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>main</td>
<td>1</td>
<td>5.9</td>
<td>17</td>
<td>100.0</td>
</tr>
<tr><td>main -&gt; a</td>
<td>2</td>
<td>11.8</td>
<td>16</td>
<td>94.1</td>
</tr>
<tr><td>main -&gt; a -&gt; b</td>
<td>4</td>
<td>23.5</td>
<td>12</td>
<td>70.6</td>
</tr>
<tr><td>main -&gt; a -&gt; b -&gt; c</td>
<td>8</td>
<td>47.1</td>
<td>8</td>
<td>47.1</td>
</tr>
<tr><td>main -&gt; a -&gt; c</td>
<td>2</td>
<td>11.8</td>
<td>2</td>
<td>11.8</td>
</tr>
</tbody>
</table>
<p>或者可以畫出以下 <strong>Caller-based Call Graph</strong>（以「呼叫者」為基礎的呼叫圖）：</p>
<div class="highlight"><pre><span></span>           Total   Self
+@ main    100.0     5.9
 +@ a       94.1    11.8
  +@ b      70.6    23.5
  |+@ c     47.1    47.1
  +@ c      11.8    11.8
</pre></div>
<p>每個 Caller-based Call Graph 的節點通常會有一組數字：</p>
<ul class="simple">
<li><strong>Self</strong> 是結束於該節點的 Stack Trace 佔總體數量的百分比。</li>
<li><strong>Total</strong> 是所有有共同前綴的 Stack Trace 佔總體數量的百分比。通常程式的執行起點（例如：<code>main</code> 或 <code>_start</code>）應該要很接近 100%。</li>
</ul>
<p>Caller-based Call Graph 能讓我們知道每個函式呼叫執行的過程中會觸發多少事件。如果記錄的事件種類是 <code>cycles</code>，Caller-based Call Graph 就會呈現每個函式呼叫的執行時間百分比。改進程式效能的時候，我們可以從比例最高的函式開始分析與最佳化。</p>
<p>舉例來說，假設測量對象是一個 3D 影像渲染程式。渲染每個畫面的過程都會經過 Vertex Processing、Primitive Assembly、Rasterization、Fragment Shader 與 Per-Sample Processing。下圖為一個簡單的示意圖：</p>
<div class="highlight"><pre><span></span>VVVVVVVVVVVVVVV PPPPP RRRRR FFFFFFFFFFFFFFFFFFFF SSSSS
</pre></div>
<p>如果要改進這個程式的效能可以先從 Fragment Shader 下手（40%）、再嘗試 Vertix Processing（30%）、之後再嘗試其他部分。之所以從佔比最高的部分開始是因為整體改進幅度受限於該部分原本所佔比例。舉例來說，如果減少 50% 的 Fragment Shader 執行時間，總體時間就能減少 20%。然而，同樣是減少 50% 的 Rasterization 執行時間，總體時間只能減少 5%。</p>
<p>Caller-based Call Graph 也可以反過來解讀。若因為某種原因其中一部分沒有辦法再進一步最佳化，我們就能知道效能改進的上限。以上面的例子，如果 Fragment Shader 和 Vertex Shader 都沒有辦法再最佳化，效能改進的上限就是減少 30% 的時間（假設剩下來計算都可以省下來）。</p>
<p><strong>小結：</strong>Caller-based Call Graph 適合用來判讀能被分割為若干模組、各個模組獨立性高、且各模組都有自己的領域知識的程式。它讓我們可以從改進上限較高的模組開始分析與最佳化。</p>
</div>
<div class="section" id="callee-based-call-graph">
<h3>Callee-based Call Graph</h3>
<p>第二種解讀方式是<strong>由下而上（Bottom Up）</strong>解讀統計數據。首先先反轉 Stack Trace，然後以最後一個被呼叫者分組排序，將 Stack Trace 個數較高者排在上面：</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%">
<col width="35%">
<col width="11%">
<col width="11%">
<col width="18%">
<col width="18%">
</colgroup>
<thead valign="bottom">
<tr><th class="head">組別</th>
<th class="head">Stack Trace</th>
<th class="head">樣本數</th>
<th class="head">百分比</th>
<th class="head">組別樣本數</th>
<th class="head">組別百分比</th>
</tr>
</thead>
<tbody valign="top">
<tr><td rowspan="2">c</td>
<td>c &lt;- b &lt;- a &lt;- main</td>
<td>8</td>
<td>47.1</td>
<td rowspan="2">10</td>
<td rowspan="2">58.8</td>
</tr>
<tr><td>c &lt;- a &lt;- main</td>
<td>2</td>
<td>11.8</td>
</tr>
<tr><td>b</td>
<td>b &lt;- a &lt;- main</td>
<td>4</td>
<td>23.5</td>
<td>4</td>
<td>23.5</td>
</tr>
<tr><td>a</td>
<td>a &lt;- main</td>
<td>2</td>
<td>11.8</td>
<td>2</td>
<td>11.8</td>
</tr>
<tr><td>main</td>
<td>main</td>
<td>1</td>
<td>5.9</td>
<td>1</td>
<td>5.9</td>
</tr>
</tbody>
</table>
<p>接著，再將每組 Stack Trace 合併為 <strong>Callee-based Call Graph</strong>（以「被呼叫者」為基礎的呼叫圖）：</p>
<div class="highlight"><pre><span></span>           total   self / parent = fractal
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@ c         58.8   58.8 /  100.0 =    58.8
+@ b        47.1   47.1 /   58.8 =    80.0
|+@ a       47.1   47.1 /   47.1 =   100.0
| +@ main   47.1   47.1 /   47.1 =   100.0
+@ a        11.8   11.8 /   58.8 =    20.0
 +@ main    11.8   11.8 /   11.8 =   100.0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@ b         23.5   23.5 /  100.0 =    23.5
+@ a        23.5   23.5 /   23.5 =   100.0
 +@ main    23.5   23.5 /   23.5 =   100.0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@ a         11.8   11.8 /  100.0 =    11.8
+@ main     11.8   11.8 /   11.8 =   100.0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@main        5.9    5.9 /  100.0 =     5.9
</pre></div>
<p>Callee-based Call Graph 呈現的重點有二個：</p>
<ul class="simple">
<li>每個函式各自觸發多少事件</li>
<li>每個函式各自被誰呼叫、每種呼叫方式佔有多少比例</li>
</ul>
<p>以上面的例子來說，我們可以知道有 58.8% 的樣本落在函式 <code>c</code>。在 58.8% 之中，80.0% 是來自函式 <code>b</code>，20.0% 是來自函式 <code>a</code>。所以我們可以先思考函式 <code>b</code> 是否一定要呼叫函式 <code>c</code>，分析完 <code>c &lt;- b &lt;- a &lt;- main</code> 之後，再分析下一種 Stack Trace。</p>
<p>這種分析方法讓我們能深入探究重要函式的使用情境。舉例來說，一個文字處理程式可能會多次呼叫 <code>strcmp</code> 與 <code>strcpy</code> 等字串處理函式。作為 C 語言標準函式庫的一部分，<code>strcmp</code> 與 <code>strcpy</code> 通常都已經被仔細地最佳化過，應該沒有多少改進空間。然而我們能分析這些函式的呼叫者，看看是否能從呼叫者得到額外的資訊（例如：輸入資料有一定規則或者有其它資料結構能更有效率地解決相同的問題等等），再進一步減少非必要的函式呼叫。一般而言，如果樣本大多落於基礎函式之中，Callee-based Call Graph 會是比較合適的呈現方式。</p>
<p>由下而上分析程式效能時，Callee-based Call Graph 會是比 Caller-based Call Graph 合理的選擇。因為 Stack Trace 之中相鄰的函式比較有因果關係，距離較遠的函式比較沒有因果關係。以下面的例子來說，<code>strchr</code> 和 <code>normalizePath</code> 的關聯比較大，和 <code>main</code> 的關聯比較小，因此分析為什麼要呼叫 <code>strchr</code> 的時候，從「最後一個被呼叫者」往「第一個呼叫者」逐步分析會比較有用：</p>
<div class="highlight"><pre><span></span>   main
-&gt; parseFile
-&gt; parseIncludeDirective
-&gt; normalizePath
-&gt; strchr
</pre></div>
<p>在這個例子之中，如果使用 Caller-based Call Graph，<code>normalizePath</code> 會散落在不同的呼叫者之下，使我們無法快速看出大部分 <code>strchr</code> 的呼叫者都是  <code>normalizePath</code>：</p>
<div class="highlight"><pre><span></span>+---@ main
    |
    +---@ parseFile
        |
        +---@ handleError
        |   |
        |   +---@ printDiagnostic
        |       |
        |       +---@ normalizePath
        |           |
        |           +---@ strchr
        |
        +---@ parseIncludeDirective
        |   |
        |   +---@ normalizePath
        |       |
        |       +---@ strchr
        |
        +---@ parseLocationDirective
            |
            +---@ normalizePath
                |
                +---@ strchr
</pre></div>
<p>對照 Callee-based Call Graph 會把 <code>normalizePath</code> 整理在一起：</p>
<div class="highlight"><pre><span></span>+---@ strchr
    |
    +---@ normalizePath
        |
        +---@ parseIncludeDirective
        |   |
        |   +---@ parseFile
        |       |
        |       +---@ main
        |
        +---@ parseLocationDirective
        |   |
        |   +---@ parseFile
        |       |
        |       +---@ main
        |
        +---@ printDiagnostic
            |
            +---@ handleError
                |
                +---@ parseFile
                    |
                    +---@ main
</pre></div>
<p>由此可知，當我們要分析為什麼一個函式會被呼叫時，Callee-based Call Graph 會是比較合理的選擇。</p>
<p><strong>小結</strong>：Callee-based Call Graph 的強項是分析為什麼特定函式（熱區或效能瓶頸）會被呼叫。該函式呼叫的前後文為何。</p>
</div>
</div>
<div class="section" id="id1">
<h2>Perf Events 與 Call Graph</h2>
<p>本節會從概論轉向實際的 Perf Events。我會先介紹使用 <code>perf record</code> 命令記錄 Stack Trace 的注意事項，再介紹 <code>perf report</code> 命令與 Call Graph 相關的選項。</p>
<div class="section" id="id2">
<h3>記錄 Stack Trace</h3>
<p>如同<a class="reference external" href="https://zh-blog.logan.tw/2019/07/10/analyze-program-performance-with-perf-events/">上一篇文章</a>所述，<code>perf record</code> 命令能取樣並記錄「測量對象的執行狀態」：</p>
<div class="highlight"><pre><span></span>$ sudo perf record <span class="o">[</span>-g<span class="o">]</span> <span class="o">[</span>--call graph <span class="o">[</span>fp,dwarf,lbr<span class="o">]]</span> <span class="o">[</span>command<span class="o">]</span>
</pre></div>
<p>選項 <code>-g</code> 會讓 <code>perf record</code> 在記錄各個樣本的時候，同時記錄取樣點的 Stack Trace：</p>
<div class="highlight"><pre><span></span>$ sudo perf record -g ./callgraph
</pre></div>
<p>其次，使用者可以透過 <code>--call-graph</code> 選項指定走訪 Stack Trace 的方法：</p>
<div class="highlight"><pre><span></span>$ sudo perf record -g --call-graph <span class="o">[</span>fp,dwarf,lbr<span class="o">]</span> ./callgraph
</pre></div>
<p>目前 <code>perf record</code> 支援 3 種方法：</p>
<ul>
<li><p class="first"><strong>fp</strong>（預設值）</p>
<p>此方法是利用 Frame Pointer 走訪每一個 Frame 並記錄呼叫堆疊上的函式。通常 CPU 會有一個暫存器記錄呼叫堆疊最後一個 Frame 的起始位址，每個 Frame 會記錄前一個 Frame 的起始位址，所以只要依序走訪每一個 Frame 就能得到 Stack Trace。</p>
<p><strong>優點</strong>：這個方法能得到<strong>準確的 Stack Trace</strong> 且<strong>額外負擔亦可接受</strong>。</p>
<p><strong>缺點</strong>：這個方法假設所有函式都遵循特定呼叫約定（Calling Convention）。如果有函式沒有遵循呼叫約定，<code>perf record</code> 就可能得到不完整的 Stack Trace。</p>
<p>此外，部分計算機結構（包含 x86 與 x86-64）的編譯器在最佳化模式下會省略 Frame Pointer。如果要讓 <code>perf record</code> 正確地記錄 Stack Trace，編譯待測程式時必須加上 <code>-fno-omit-frame-pointer</code> 選項。</p>
</li>
<li><p class="first"><strong>dwarf</strong></p>
<p>這個方法是利用 <a class="reference external" href="http://dwarfstd.org/">Dwarf 除錯資訊</a>走訪每一個 Frame。Dwarf 除錯資訊是將「正在執行的指令位址」對應到「Frame 解讀方法」的資料結構。只要有指令位址 <code>perf record</code> 就知道如何找到當前 Frame 的起始位址與前一個 Frame 的起始位置。</p>
<p><strong>優點</strong>：這個方法產生的 <strong>Stack Trace 最詳儘</strong>。Inline 函式也能被正確地列在 Stack Trace 裡面（以 <code>(inlined)</code> 標記）。</p>
<p><strong>缺點</strong>：這個方法在記錄 Stack Trace 時，需要花時間解讀除錯資訊，因此這個方法的額外負擔最高、需要最久的記錄時間。此外，這個方法產生的記錄檔案也是最大的。</p>
<p>其次，這個方法需要額外的除錯資訊，編譯待測程式時必須加上 <code>-g</code> 選項。這個方法不適合用於測量大型程式，因為除錯資訊的大小通常比程式本身大若干倍。考量觀察者效應，過大的除錯資訊可能增加測量結果的不準確度。</p>
</li>
<li><p class="first"><strong>lbr</strong></p>
<p>LBR 是 Last Branch Record（最後分支記錄）的縮寫。這個方法是讓處理器記錄 Branch Instruction（分支指令）跳躍的「來源位址」與「目標位址」。每當處理器執行一個 <code>call</code> 指令之後，就將該 <code>call</code> 指令的來源位址與目標位址記錄於 LBR 暫存器。同樣地，每當處理器執行一個 <code>ret</code> 指令之後，就會從 LBR 暫存器移除最後一組記錄。最後 <code>perf record</code> 會將 LBR 暫存器每一組記錄的來源位址與最後一組的目標位址整理成 Stack Trace。</p>
<p><strong>優點</strong>：這個方法的額外負擔很低，而且不需調整編譯器選項。</p>
<p><strong>缺點</strong>：因為硬體能保留的分支記錄結果是有限的，所以當堆疊深度過深時，會得到不完整的 Stack Trace。這可能會引入一些不確定性。其次，就我目前所知，<strong>只有 Haswell 微架構之後的 Intel 處理器才支援以 Last Branch Record 記錄 Call Stack</strong>。</p>
</li>
</ul>
<p>編譯器選項也會影響 Stack Trace 記錄。以下列出 3 個會影響 Stack Trace 的編譯器選項：</p>
<ul>
<li><p class="first"><code>-fno-omit-frame-pointer</code> 會阻止編譯器省略「設定 Frame Pointer」的指令。如前所述，如果要以 <code>fp</code> 模式記錄 Stack Trace，就必須在編譯待測程式時加上此選項。</p>
</li>
<li><p class="first"><code>-fno-optimize-sibling-calls</code> 會阻止編譯器施行 Sibling Call Optimization。</p>
<p>當一個函式的最後一個述句是回傳另一個函式的回傳值時，我們稱該述句為 Tail Call（如下方 <code>example1</code>）。若該函式的的參數型別（Argument Type）與回傳型別（Return Type）與被呼叫者一致，則將該類 Tail Call 細分為 Sibling Call（如下方 <code>example2</code>）。因為 Sibling Call 已經是這個函式的最後步驟，所以這個函式的 Frame 其實是可以被重複利用的。Sibling Call Optimization 就是讓被呼叫者直接覆蓋呼叫者的 Frame。</p>
<p>這個最佳化會讓 <code>perf record</code> 記錄到不存在於程式碼的 Stack Trace。以下方的 <code>main</code> 函式為例，理論上應該不會有 <code>main -&gt; dest2</code>，然而因為 Sibling Call Optimization，中間的 <code>example2</code> 函式會被覆蓋，從而產生不應存在的 Stack Trace。</p>
<p>當 Sibling Call 讓 Call Graph 看起來不太正確時，可以在編譯待測程式時加上 <code>-fno-optimize-sibling-calls</code>。</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">example1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="n">dest1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// Tail Call</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">example2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="n">dest2</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// Sibling Call</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">example2</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</li>
<li><p class="first"><code>-fno-inline</code> 會阻止編譯器將「函式呼叫」代換「為被呼叫者的程式碼」。</p>
<p>在最佳化模式下，編譯器會嘗試將函式呼叫改寫為 Inline Function（內嵌函式）的程式碼。然而，如果使用 <code>fp</code> 或 <code>lbr</code> 記錄 Stack Trace，這些 Inline Function 就無法被記錄於 Stack Trace 上。</p>
<p>雖然測量效能時不建議關閉 Function Inlining（函式內嵌），但是如果你需要詳細的 Stack Trace，你可以加上 <code>-fno-inline</code>。如果不想要全面關閉 Function Inlining，也可以將想要測試的函式標上 <code>__attribute__((noinline))</code> 屬性，編譯器就不會內嵌該函式。</p>
</li>
</ul>
<div class="section" id="id3">
<h4>實際操作</h4>
<p>現在讓我們以範例程式展示各種選項的差異。本節使用的範例程式為 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/callgraph.c">callgraph.c</a>，部分程式碼節錄如下：</p>
<div class="highlight"><pre><span></span><span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">D</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">COMPUTE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sc">'D'</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">C</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">D</span><span class="p">();</span>
  <span class="n">COMPUTE</span><span class="p">(</span><span class="n">NUM_ROUNDS</span><span class="p">,</span> <span class="sc">'C'</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">B</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">COMPUTE</span><span class="p">(</span><span class="n">NUM_ROUNDS</span><span class="p">,</span> <span class="sc">'B'</span><span class="p">);</span>
  <span class="n">C</span><span class="p">();</span>
  <span class="n">C</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">A</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">COMPUTE</span><span class="p">(</span><span class="n">NUM_ROUNDS</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">);</span>
  <span class="n">B</span><span class="p">();</span>
  <span class="n">C</span><span class="p">();</span>
  <span class="n">B</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">COMPUTE</span><span class="p">(</span><span class="n">NUM_ROUNDS</span><span class="p">,</span> <span class="sc">'M'</span><span class="p">);</span>
  <span class="n">A</span><span class="p">();</span>
  <span class="n">A</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>請先下載 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/callgraph.c">callgraph.c</a> 並使用以下命令編譯程式碼：</p>
<div class="highlight"><pre><span></span>$ gcc -g -O2 -fno-omit-frame-pointer <span class="se">\</span>
      callgraph.c -o callgraph
</pre></div>
<p>接著分別使用以下 <code>perf record</code> 命令測量 <code>callgraph</code> 的效能：</p>
<div class="highlight"><pre><span></span>$ sudo perf record -g --call-graph fp <span class="se">\</span>
      -o callgraph.fp.perf.data ./callgraph

$ sudo perf record -g --call-graph dwarf <span class="se">\</span>
      -o callgraph.dwarf.perf.data ./callgraph

$ sudo perf record -g --call-graph lbr <span class="se">\</span>
      -o callgraph.lbr.perf.data ./callgraph
</pre></div>
<p>第一個明顯的差異是記綠檔案的大小：</p>
<div class="highlight"><pre><span></span>$ ls -lh callgraph.*.perf.data
-rw------- <span class="m">1</span> root root 198M Aug <span class="m">13</span> <span class="m">21</span>:43 callgraph.dwarf.perf.data
-rw------- <span class="m">1</span> root root <span class="m">2</span>.2M Aug <span class="m">13</span> <span class="m">21</span>:43 callgraph.fp.perf.data
-rw------- <span class="m">1</span> root root <span class="m">4</span>.5M Aug <span class="m">13</span> <span class="m">21</span>:44 callgraph.lbr.perf.data
</pre></div>
<p>上面的結果顯示「dwarf 產生的記錄檔案」會比「fp 或 lbr 產生的記檔案」大兩個數量級。「lbr 產生的記錄檔案」會稍微比「fp 產生的記錄檔案」大。順帶一提，記錄檔案並不是越大越好，有時候小的記錄檔案也能提供精準且詳細的資訊。所以<strong>以實務經驗來說，正常規模的程式不太可能使用 dwarf 記錄 Stack Trace</strong>。</p>
<p>接著，我們可以用以下指令觀察記錄檔案的內容（下節會再進一步介紹）：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio -i <span class="o">[</span>filename<span class="o">]</span>
</pre></div>
<p>為了方便比較，以下輸出都只節選以 <code>_start</code> 函式（一個執行檔第一個被執行的函式）開始的 Call Graph。</p>
<p>首先是 <strong>dwarf 產生的記錄檔案</strong>：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio -i callgraph.dwarf.perf.data

99.99%     0.00%  callgraph  callgraph          [.] _start
        |
        ---_start
           __libc_start_main
           main
           |
           |--58.80%--A
           |          |
           |          |--23.54%--C
           |          |
           |           --23.53%--B
           |                     |
           |                      --11.79%--C
           |
           |--23.52%--B
           |          |
           |           --11.77%--C
           |
            --11.77%--C
</pre></div>
<p>其次是 <strong>fp 產生的記錄檔案</strong>（雖然輸出結果沒有 <code>_start</code> 但可以透過 <code>__libc_start_main</code> 推得 <code>0x64e258d4c544155</code> 是 <code>_start</code> 的位址）：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio -i callgraph.fp.perf.data

99.99%     0.00%  callgraph  [unknown]          [.] 0x064e258d4c544155
        |
        ---0x64e258d4c544155
           __libc_start_main
           main
           |
           |--58.81%--A
           |          |
           |          |--23.57%--C
           |          |
           |           --23.52%--B
           |                     |
           |                      --11.78%--C
           |
           |--23.51%--B
           |          |
           |           --11.78%--C
           |
            --11.79%--C
</pre></div>
<p>最後是 <strong>lbr 產生的記錄檔案</strong>：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio -i callgraph.lbr.perf.data

99.99%     0.00%  callgraph  callgraph          [.] _start
        |
        ---_start
           __libc_start_main
           main
           |
           |--82.26%--A
           |          |
           |          |--35.23%--B
           |          |          |
           |          |           --11.77%--C
           |          |
           |           --11.82%--C
           |
            --11.79%--B
                      C
</pre></div>
<p>觀察以上結果，我們能注意到 fp 和 dwarf 兩種方法產生的結果相似，而 lbr 產生的結果與其他兩者不同。然而，三種方法的結果都和程式碼有所出入。這些差異都是 Sibling Call Optimization 造成的：</p>
<ul>
<li><p class="first">對於 <code>fp</code> 和 <code>dwarf</code> 而言，Sibling Call Optimization 會重覆利用同一個 Frame，因此部分函式的呼叫者變成 <code>A</code> 函式。</p>
</li>
<li><p class="first">對於 <code>lbr</code> 而言，Sibling Call Optimization 會將 Sibling Call 原本會使用的 <code>call</code> 與 <code>ret</code> 指令代換為 <code>jmp</code> 指令。因此有些 Stack Trace 會令人感到困惑。</p>
<p>舉例來說，<code>_start -&gt; __libc_start_main -&gt; main -&gt; B -&gt; C</code> 對應到「<code>A</code> 函式第二次呼叫 <code>B</code> 函式」且「<code>B</code> 函式第一次呼叫 <code>C</code> 函式」。此時，LBR 暫存器上的記錄依序為：</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%">
<col width="50%">
</colgroup>
<thead valign="bottom">
<tr><th class="head">來源位址</th>
<th class="head">目標位址</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>_start</td>
<td>__libc_start_main</td>
</tr>
<tr><td>__libc_start_main</td>
<td>main</td>
</tr>
<tr><td>main</td>
<td>A</td>
</tr>
<tr><td>B</td>
<td>C</td>
</tr>
</tbody>
</table>
<p>若只截取每組記錄的來源位址與最後一組的目標位址，Stack Trace 就會變成 <code>main -&gt; B -&gt; C</code>。</p>
</li>
</ul>
<p>為了看到比較合理的 Stack Trace，請加上 <code>-fno-optimize-sibing-calls</code> 並重新編譯 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/callgraph.c">callgraph.c</a>：</p>
<div class="highlight"><pre><span></span>$ gcc -g -O2 -fno-omit-frame-pointer -fno-optimize-sibling-calls <span class="se">\</span>
      callgraph.c -o callgraph
</pre></div>
<p>重新再測量一次：</p>
<div class="highlight"><pre><span></span>$ sudo perf record -g --call-graph fp <span class="se">\</span>
      -o callgraph.fp.perf.data ./callgraph
</pre></div>
<p>這次的結果大致上與程式碼相符：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio -i callgraph.fp.perf.data

<span class="m">99</span>.99%     <span class="m">0</span>.00%  callgraph <span class="o">[</span>unknown<span class="o">]</span> <span class="o">[</span>k<span class="o">]</span> 0x063e258d4c544155
    <span class="p">|</span>
    ---0x63e258d4c544155
       __libc_start_main
       main
       <span class="p">|</span>
        --94.10%--A
                  <span class="p">|</span>
                  <span class="p">|</span>--70.60%--B
                  <span class="p">|</span>          <span class="p">|</span>
                  <span class="p">|</span>           --47.12%--C
                  <span class="p">|</span>
                   --11.77%--C
</pre></div>
<p>以此例而言，在關閉 Sibling Call Optimization 之後，三種記錄 Stack Trace 的方法都會得到類似的結果。上面只以 <code>fp</code> 為例，<code>dwarf</code> 與 <code>lbr</code> 就留給讀者練習。</p>
</div>
</div>
<div class="section" id="id4">
<h3>呈現 Call Graph</h3>
<p>使用 <code>perf report</code> 呈現 Call Graph 的指令如下：</p>
<div class="highlight"><pre><span></span>$ sudo perf report <span class="se">\</span>
      <span class="o">[</span>--tui<span class="p">|</span>--stdio<span class="o">]</span> <span class="se">\</span>
      <span class="o">[</span>--children<span class="p">|</span>--no-children<span class="o">]</span> <span class="se">\</span>
      <span class="o">[</span>-g <span class="o">[</span>fractal<span class="p">|</span>graph<span class="o">]</span>,0.5,<span class="o">[</span>caller<span class="p">|</span>callee<span class="o">]]</span> <span class="se">\</span>
      -i perf.data
</pre></div>
<p><code>--tui</code> 與 <code>--stdio</code> 是兩種不同的輸出模式：</p>
<ul class="simple">
<li><code>--tui</code> 會提供一個互動式純文字介面讓使用者選擇要展開的節點。</li>
<li><code>--stdio</code> 會直接將所有結果一次印出。</li>
</ul>
<p>一般常用的模式 <code>--tui</code>，這也是 <code>perf report</code> 的預設值：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --tui -i perf.data
</pre></div>
<img alt="perf report --tui 的執行畫面" src="./簡介 perf_events 與 Call Graph_files/perf-report-tui.png">
<p>有時候 <code>--stdio</code> 會有比較完整的資訊，下圖是 <code>--stdio</code> 的執行畫面：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio -i <span class="o">[</span>perf.data<span class="o">]</span>

<span class="m">99</span>.99%     <span class="m">0</span>.00%  callgraph <span class="o">[</span>unknown<span class="o">]</span> <span class="o">[</span>k<span class="o">]</span> 0x063e258d4c544155
    <span class="p">|</span>
    ---0x63e258d4c544155
       __libc_start_main
       main
       <span class="p">|</span>
        --94.10%--A
                  <span class="p">|</span>
                  <span class="p">|</span>--70.60%--B
                  <span class="p">|</span>          <span class="p">|</span>
                  <span class="p">|</span>           --47.12%--C
                  <span class="p">|</span>
                   --11.77%--C
</pre></div>
<p>因為截取 <code>--stdio</code> 的輸出結果比較容易，所以本文大部分的例子都是使用 <code>perf report --stdio</code> 產生的。</p>
<p>其次，如果指定 <code>--children</code> 選項，<code>perf report</code> 會將「被呼叫者」的樣本數量加進「呼叫者」的統計數字。反之，如果指定 <code>--no-children</code> 選項，<code>perf record</code> 就不會累加統計數字。在 2013 年之後，<code>perf report</code> 的預設值是 <code>--children</code>。</p>
<p>接著 <code>-g</code> 選項是用以指定 Call Graph 的繪製參數。通常我們會指定三個參數（以逗號分開）：</p>
<ul class="simple">
<li>第一個參數是<strong>各個節點百分比</strong>的計算方法。如果指定 <code>graph</code> 則會直接顯示該節點佔總體樣本數的比例。如果指定 <code>fractal</code> 會顯示一個節點和其他平級節點相比所佔的比例。</li>
<li>第二個參數是繪製 Call Graph 的<strong>門檻值</strong>。如果一個 Stack Trace 的數量與總體樣本數相比低於門檻值，則忽略該 Stack Trace。此數值以百分比表示。如果指定的數值為 0.5，則佔比低於 0.5% 的 Stack Trace 會被忽略。</li>
<li>第三個參數是 Stack Trace 的<strong>走訪順序</strong>。如果指定 <code>caller</code> 就會顯示 Caller-based Call Graph。反之，如果指定 <code>callee</code> 則會顯示 Callee-based Call Graph。</li>
</ul>
<p><code>-g</code> 選項的預設值會受 <code>--[no-]children</code> 選項影響：</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%">
<col width="53%">
</colgroup>
<thead valign="bottom">
<tr><th class="head">選項</th>
<th class="head"><code>-g</code> 預設值</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><code>--children</code></td>
<td><code>graph,0.5,caller</code></td>
</tr>
<tr><td><code>--no-children</code></td>
<td><code>graph,0.5,callee</code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id5">
<h3>實際操作</h3>
<p>請先以上一小節的方法編譯並執行 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/callgraph.c">callgraph.c</a>：</p>
<div class="highlight"><pre><span></span>$ gcc -g -O2 -fno-omit-frame-pointer -fno-optimize-sibling-calls <span class="se">\</span>
      callgraph.c -o callgraph

$ sudo perf record -g --call-graph fp <span class="se">\</span>
      -o callgraph.fp.perf.data ./callgraph
</pre></div>
<p>第一個實驗先以 <code>--children</code> 搭配 <code>-g graph,0.5,caller</code> 觀察 Call Graph：</p>
<div class="highlight"><pre><span></span>$ sudo perf report -i callgraph.fp.perf.data --stdio <span class="se">\</span>
      --children -g graph,0.5,caller

<span class="m">99</span>.99%     <span class="m">0</span>.00%  callgraph <span class="o">[</span>unknown<span class="o">]</span> <span class="o">[</span>k<span class="o">]</span> 0x063e258d4c544155
        <span class="p">|</span>
        ---0x63e258d4c544155
           __libc_start_main
           main
           <span class="p">|</span>
            --94.10%--A
                      <span class="p">|</span>
                      <span class="p">|</span>--70.60%--B
                      <span class="p">|</span>          <span class="p">|</span>
                      <span class="p">|</span>           --47.12%--C
                      <span class="p">|</span>
                       --11.77%--C
</pre></div>
<p>這個 Call Graph 沒有函式 <code>D</code>，因為 <code>main -&gt; A -&gt; B -&gt; C -&gt; D</code> 的比例低於 0.5%。如果將 <code>-g</code> 選項的門檻值下調至 0.1，就看得到函式 <code>D</code>：</p>
<div class="highlight"><pre><span></span>$ sudo perf report -i callgraph.fp.perf.data --stdio <span class="se">\</span>
      --children -g graph,0.1,caller

<span class="m">99</span>.99%     <span class="m">0</span>.00%  callgraph  <span class="o">[</span>unknown<span class="o">]</span> <span class="o">[</span>k<span class="o">]</span> 0x063e258d4c544155
        <span class="p">|</span>
        ---0x63e258d4c544155
           __libc_start_main
           main
           <span class="p">|</span>
            --94.10%--A
                      <span class="p">|</span>
                      <span class="p">|</span>--70.60%--B
                      <span class="p">|</span>          <span class="p">|</span>
                      <span class="p">|</span>           --47.12%--C
                      <span class="p">|</span>                     <span class="p">|</span>
                      <span class="p">|</span>                      --0.18%--D
                      <span class="p">|</span>
                       --11.77%--C
</pre></div>
<p>如果進一步將門檻值下調至 0.0，則會看到 Linux 核心處理中斷的函式：</p>
<div class="highlight"><pre><span></span>$ sudo perf report -i callgraph.fp.perf.data --stdio <span class="se">\</span>
      --children -g graph,0.0,caller

<span class="m">99</span>.99%     <span class="m">0</span>.00%  callgraph  <span class="o">[</span>unknown<span class="o">]</span>  <span class="o">[</span>k<span class="o">]</span> 0x063e258d4c544155
        <span class="p">|</span>
        ---0x63e258d4c544155
           __libc_start_main
           main
           <span class="p">|</span>
           <span class="p">|</span>--94.10%--A
           <span class="p">|</span>          <span class="p">|</span>
           <span class="p">|</span>          <span class="p">|</span>--70.60%--B
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>--47.12%--C
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>--0.18%--D
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>--0.01%--apic_timer_interrupt
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          smp_apic_timer_interrupt
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>--0.01%--hrtimer_interrupt
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          __hrtimer_run_queuess
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          tick_sched_timer
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          tick_sched_handle
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          update_process_times
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          scheduler_tick
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          perf_event_task_tick
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>           --0.00%--x86_pmu_enable
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>                     intel_tfa_pmu_enable_all
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>                     __intel_pmu_enable_all.constprop.25
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>                     native_write_msr
</pre></div>
<p>因為這些函式比例很低，反而會在視覺上干擾 Call Graph 判讀工作，所以我們通常還是會指定一個門檻值。</p>
<p>先前的例子我們都只截取以 <code>_start</code> 為起點的 Call Graph。現在我們把目光轉向函式 <code>B</code> 與函式 <code>C</code> 的 Call Graph：</p>
<div class="highlight"><pre><span></span>$ sudo perf report -i callgraph.fp.perf.data --stdio <span class="se">\</span>
      --children -g graph,0.5,caller

... 中略 ...

<span class="m">70</span>.60%    <span class="m">23</span>.47%  callgraph callgraph  <span class="o">[</span>.<span class="o">]</span> B
        <span class="p">|</span>
        <span class="p">|</span>--47.13%--B
        <span class="p">|</span>          <span class="p">|</span>
        <span class="p">|</span>           --47.12%--C
        <span class="p">|</span>
         --23.47%--0x63e258d4c544155
                   __libc_start_main
                   main
                   A
                   B

<span class="m">58</span>.89%    <span class="m">58</span>.65%  callgraph callgraph  <span class="o">[</span>.<span class="o">]</span> C
        <span class="p">|</span>
         --58.65%--0x63e258d4c544155
                   __libc_start_main
                   main
                   A
                   <span class="p">|</span>
                   <span class="p">|</span>--46.92%--B
                   <span class="p">|</span>          C
                   <span class="p">|</span>
                    --11.72%--C
</pre></div>
<p>在 Caller-based Call Graph 模式下，<code>perf report</code> 會以「Stack Trace 是否以該函式結束」分為兩類：</p>
<ul class="simple">
<li>第一類是<strong>結尾不是該函式的 Stack Trace</strong>。<code>perf report</code> 會從該函式第一次出現的位置合併此類 Stack Trace。這呈現的是該函式裡面的函式呼叫各佔去多少比例。<ul>
<li>函式 <code>B</code> 的 Call Graph 顯示函式 <code>B</code> 裡面的函式呼叫大多都是呼叫函式 <code>C</code>。</li>
<li>函式 <code>C</code> 的 Call Graph 顯示函式 <code>C</code> 只出現於 Stack Trace 的結尾。（嚴格的說，其實函式 <code>C</code> 有呼叫函式 <code>D</code>，但是因為低於門檻值而被省略。）</li>
</ul>
</li>
<li>第二類是<strong>結尾是該函式的 Stack Trace</strong>。<code>perf report</code> 會以 <code>_start</code> 函式為起點，繪製其他函式是如何呼叫該函式。<ul>
<li>函式 <code>B</code> 的 Call Graph 顯示所有結束於函式 <code>B</code> 的 Stack Trace 都是以 <code>_start -&gt; __libc_start_main -&gt; A -&gt; B</code> 開頭。</li>
<li>函式 <code>C</code> 的 Call Graph 將函式 <code>C</code> 的 Stack Trace 分為兩類：46.92% 的 Stack Trace 有經過函式 <code>B</code>，11.72% 的 Stack Trace 是直接從函式 <code>A</code> 跳至函式 <code>C</code>。</li>
</ul>
</li>
</ul>
<p>我自己在判讀 Caller-based Call Graph 的時候會著重第一類 Stack Trace。因為我想知道的是一個函式是如何被分拆為若干個函式呼叫。其次，我想要知道各個函式呼叫佔去多少比例，以方便我決定要分析哪一部分。</p>
<p>除了比例總和（Self）之外，我幾乎不看第二類 Stack Trace 產生的 Call Graph，因為 Caller-based Call Graph 會傾向把該函式被呼叫的原因打散到不同的子樹。如果想要知道一個函式為什麼被呼叫，Callee-based Call Graph 會是比較好的選擇。</p>
<p>第二個實驗請改用 <code>--no-children</code> 搭配 <code>-g graph,0.5,callee</code> 觀察 Call Graph：</p>
<div class="highlight"><pre><span></span>$ sudo perf report -i callgraph.fp.perf.data --stdio <span class="se">\</span>
      --no-children -g graph,0.5,callee

<span class="m">58</span>.65%  callgraph-no-op  callgraph-no-optimize-sibling-calls  <span class="o">[</span>.<span class="o">]</span> C
        <span class="p">|</span>
        ---C
           <span class="p">|</span>
           <span class="p">|</span>--46.92%--B
           <span class="p">|</span>          A
           <span class="p">|</span>          main
           <span class="p">|</span>          __libc_start_main
           <span class="p">|</span>          0x63e258d4c544155
           <span class="p">|</span>
            --11.72%--A
                      main
                      __libc_start_main
                      0x63e258d4c544155

<span class="m">23</span>.47%  callgraph-no-op  callgraph-no-optimize-sibling-calls  <span class="o">[</span>.<span class="o">]</span> B
        <span class="p">|</span>
         --23.46%--B
                   A
                   main
                   __libc_start_main
                   0x63e258d4c544155
</pre></div>
<p>在 <code>perf report</code> 會先以各個函式的樣本數量排序各個函式的 Callee-based Call Graph。取樣點比較多的函式就會被排在前面。接著以 Stack Trace 的最後一個「被呼叫者」為起點，繪製每一個 Call Graph。以上圖為例，以函式 <code>C</code> 結束的 Stack Trace 佔總樣本數的 58.65%。由函式 <code>B</code> 呼叫函式 <code>C</code> 的 Stack Trace 佔總樣本數的 46.92%。直接由函式 <code>A</code> 呼叫函式 <code>C</code> 的 Stack Trace 佔總樣本數的 11.72%。</p>
<p>看到這個 Callee-based Call Graph 之後，我們能思考：函式 <code>B</code> 一定要呼叫函式 <code>C</code> 嗎？有沒有更有效率的方法能實作函式 <code>B</code> 的功能？</p>
<p>在判讀 Callee-based Call Graph 的時候，我們有時候會想要知道平級節點的相對關係。只要指定 <code>-g fractal,0.5,callee</code> 選項，<code>perf report</code> 就能幫我們換算比例：</p>
<div class="highlight"><pre><span></span>$ sudo perf report -i callgraph.fp.perf.data --stdio <span class="se">\</span>
    --no-children -g fractal,0.5,callee

<span class="m">58</span>.65%  callgraph callgraph  <span class="o">[</span>.<span class="o">]</span> C
        <span class="p">|</span>
        ---C
           <span class="p">|</span>
           <span class="p">|</span>--80.01%--B
           <span class="p">|</span>          A
           <span class="p">|</span>          main
           <span class="p">|</span>          __libc_start_main
           <span class="p">|</span>          0x63e258d4c544155
           <span class="p">|</span>
            --19.99%--A
                      main
                      __libc_start_main
                      0x63e258d4c544155

... 下略 ...
</pre></div>
<p>這個 Call Graph 顯示：在以函式 <code>C</code> 結束的 Stack Trace 之中，80.01% 是由函式 <code>B</code> 呼叫，19.99% 是由函式 <code>A</code> 呼叫。有時候平級節點之間的比例會比總體比例好用，我在分析效能的時候有時會交互使用。</p>
<p><strong>備註</strong>：上面的範例 <code>--children</code> 都是搭配 <code>-g *,*,caller</code> 而  <code>--no-children</code> 都是搭配 <code>-g *,*,callee</code>。雖然 <code>perf report</code> 能讓我們任意指定，但是我的實驗結果讓我覺得其他組合並不實用。然而作為練習，我建議大家一併嘗試不同的排列組合。</p>
</div>
</div>
<div class="section" id="flame-graph">
<h2>Flame Graph</h2>
<p><strong>Flame Graph（火焰圖）</strong>是 Caller-based Call Graph 的變型。它是由 Brendan Gregg 開發並發揚光大。Flame Graph 的橫軸是事件數量百分比，縱軸是呼叫堆疊。每個函式呼叫都會依照 Stack Trace 數量百分比繪製橫向長條。最下面是各個 Stack Trace 第一個呼叫者，最上面是各個 Stack Trace 最後一個被呼叫者。有同樣前綴的 Stack Trace 都會被整理在一起。因為 Flame Graph 直接產生 SVG 向量圖，所以使用者可以迅速看出佔比最高的 Stack Trace。若函式名稱比較長，使用者也可以將滑鼠游標指向各個長條圖，其代表的函式名稱會顯示在右下方：</p>
<a href="https://zh-blog.logan.tw/static/images/2019/10/06/callgraph-no-optimize-sibling-calls.flamegraph.svg"><img src="./簡介 perf_events 與 Call Graph_files/callgraph-no-optimize-sibling-calls.flamegraph.png" alt="callgraph.c 的 Flame Graph"></a><div class="section" id="id6">
<h3>實際操作</h3>
<p>首先，請先下載 FlameGraph 的程式碼：</p>
<div class="highlight"><pre><span></span>$ git clone https://github.com/brendangregg/FlameGraph
</pre></div>
<p>接著，將 FlameGraph 目錄加到 PATH 環境變數：</p>
<div class="highlight"><pre><span></span>$ <span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/FlameGraph:<span class="nv">$PATH</span>
</pre></div>
<p>最後，以 <code>perf script</code> 讀取 <code>perf_events</code> 記錄檔案，再交由 <code>stackcollapse-perf.pl</code> 與 <code>flamegraph.pl</code> 後製：</p>
<div class="highlight"><pre><span></span>$ sudo perf script -i perf.data <span class="p">|</span> <span class="se">\</span>
    stackcollapse-perf.pl --all <span class="p">|</span> <span class="se">\</span>
    flamegraph.pl --color<span class="o">=</span>java --hash &gt; flamegraph.svg
</pre></div>
<p>產生的 <code>flamegraph.svg</code> 就是與記錄檔案對應的 Flame Graph（如上圖）。</p>
</div>
</div>
<div class="section" id="id7">
<h2>綜合練習：文字處理程式</h2>
<p>現在我們以一個文字處理程式（<a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor1.c">textprocessor1.c</a>）示範如何最佳化一個實際的程式。這個程式會將每一行以空白分割為「鍵（Key）」與「值（Value）」，以每行的「鍵」分組，將每行的「值」加進對應的組別。輸出時，以字典順序排序「鍵」與「值」，並分組印出。</p>
<p>以下是一個簡單的範例輸入：</p>
<div class="highlight"><pre><span></span>BB y
AA x
AA xx
AA x
BB x
</pre></div>
<p>對應的輸出結果為：</p>
<div class="highlight"><pre><span></span>AA
        x
        x
        xx
BB
        x
        y
</pre></div>
<p>受限與篇幅，本文僅簡述 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor1.c">textprocessor1.c</a> 的架構：</p>
<ul class="simple">
<li><code>string_list</code> 是儲存「值」的串列。<ul>
<li><code>string_list_new</code> 會配置與建構一個 <code>string_list</code> 物件。</li>
<li><code>string_list_delete</code> 會解構與釋放一個 <code>string_list</code> 物件。</li>
<li><code>string_list_append</code> 會在 <code>string_list</code> 尾端加上一個值。</li>
<li><code>string_list_reserve</code> 是用以確保 <code>string_list</code> 有充足空位的函式。</li>
</ul>
</li>
<li><code>string_map</code> 是儲存鍵值對應的資料結構。<ul>
<li><code>string_map_new</code> 會配置與建構一個 <code>string_map</code> 物件。</li>
<li><code>string_map_delete</code> 會解構與釋放一個 <code>string_map</code> 物件。</li>
<li><code>string_map_add</code> 會將一組鍵值加進 <code>string_map</code> 物件。如果 <code>string_map</code> 已經有該鍵，則會直接將值加進對應的 <code>string_list</code> 物件。如果 <code>string_map</code> 還沒有該鍵，則會在 <code>string_map</code> 新增一筆記錄指向一個新的 <code>string_list</code>  物件，並將值加進該 <code>string_list</code>。</li>
</ul>
</li>
</ul>
<p>現在開始進行分析：</p>
<p>第一步，請先下載並編譯 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor1.c">textprocessor1.c</a>：</p>
<div class="highlight"><pre><span></span>$ gcc -O2 -fno-omit-frame-pointer -fno-inline -g <span class="se">\</span>
      textprocessor1.c -o textprocessor1
</pre></div>
<p>第二步，請下載 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/gen_test_data.py">gen_test_data.py</a> 以產生測資：</p>
<div class="highlight"><pre><span></span>$ python gen_test_data.py &gt; input.txt
</pre></div>
<p>第三步，以 <code>perf stat</code> 測量時間：</p>
<div class="highlight"><pre><span></span>$ sudo perf stat <span class="se">\</span>
      ./textprocessor1 input.txt /dev/null

<span class="c1"># started on Sun Oct  6 21:40:42 2019</span>
Performance counter stats <span class="k">for</span> <span class="s1">'./textprocessor1 input.txt /dev/null'</span>:

      <span class="m">1</span>,676.09 msec task-clock       <span class="c1">#    1.000 CPUs utilized</span>
             <span class="m">4</span>      context-switches <span class="c1">#    0.002 K/sec</span>
             <span class="m">0</span>      cpu-migrations   <span class="c1">#    0.000 K/sec</span>
       <span class="m">106</span>,012      page-faults      <span class="c1">#    0.063 M/sec</span>
 <span class="m">5</span>,016,328,300      cycles           <span class="c1">#    2.993 GHz</span>
<span class="m">10</span>,217,335,197      instructions     <span class="c1">#    2.04  insn per cycle</span>
 <span class="m">2</span>,253,680,016      branches         <span class="c1"># 1344.605 M/sec</span>
    <span class="m">15</span>,744,959      branch-misses    <span class="c1">#    0.70% of all branches</span>

   <span class="m">1</span>.676458791 seconds <span class="nb">time</span> elapsed

   <span class="m">1</span>.420940000 seconds user
   <span class="m">0</span>.255449000 seconds sys
</pre></div>
<p>第四步，以 <code>perf record -g</code> 取樣：</p>
<div class="highlight"><pre><span></span>$ sudo perf record -g --call-graph fp <span class="se">\</span>
      -o textprocessor1.fp.perf.data <span class="se">\</span>
      ./textprocessor1 input.txt /dev/null
</pre></div>
<p>第五步，以 <code>perf report --children</code> 觀察 Caller-based Call Graph：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio --children <span class="se">\</span>
      -i textprocessor1.fp.perf.data

<span class="m">47</span>.91%     <span class="m">0</span>.00%  textprocessor1  <span class="o">[</span>unknown<span class="o">]</span> <span class="o">[</span>.<span class="o">]</span> 0x08ce258d4c544155
    <span class="p">|</span>
    ---0x8ce258d4c544155
        __libc_start_main
        <span class="p">|</span>
        --47.67%--main
                    <span class="p">|</span>
                    <span class="p">|</span>--29.52%--__strcmp_sse2_unaligned
                    <span class="p">|</span>
                    <span class="p">|</span>--14.55%--string_map_add
                    <span class="p">|</span>
                    <span class="p">|</span>--1.59%--string_map_delete
                    <span class="p">|</span>          <span class="p">|</span>
                    <span class="p">|</span>           --1.53%--cfree@GLIBC_2.2.5
                    <span class="p">|</span>
                    --1.01%--string_list_append
</pre></div>
<p>我們遇到一個非預期的問題。理論上，在 Caller-based Call Graph 裡，以 <code>_start</code> 函式為起點的 Stack Trace 數量應該要很接近 99%，然而上面的結果顯示只有 47.91% 的 Stack Trace 是以 <code>_start</code> 函式為起點。</p>
<p>如果再往下看，會看到一些不合理的 Call Graph。舉例來說，下面 <code>__strcmp_sse2_unaligned</code> 函式有 9.41% 的樣本看不到其「呼叫者」或「被呼叫者」：</p>
<div class="highlight"><pre><span></span>39.01%    34.26%  textprocessor1  libc-2.27.so [.] __strcmp_sse2_unaligned
        |
        |--29.57%--0x8ce258d4c544155
        |          __libc_start_main
        |          main
        |          |
        |          |--24.95%--__strcmp_sse2_unaligned
        |          |
        |           --4.62%--string_map_add
        |
         --9.41%--__strcmp_sse2_unaligned
</pre></div>
<p>深入研究後，我發現問題的成因是 C 語言函式庫 glibc 在編譯的時候沒有加上 <code>-fno-omit-frame-pointer</code>。然而要安裝不同的 glibc 很麻煩，所以我直接改用 <code>lbr</code> 記錄 Stack Trace（如果你的 CPU 不支援，也可以改用 <code>dwarf</code>）。</p>
<p>第六步，重新以 <code>perf record -g --call-graph lbr</code> 取樣：</p>
<div class="highlight"><pre><span></span>$ sudo perf record -g --call-graph lbr <span class="se">\</span>
      -o textprocessor1.lbr.perf.data <span class="se">\</span>
      ./textprocessor1 input.txt /dev/null
</pre></div>
<p>第七步，再次以 <code>perf report --children</code> 觀察 Caller-based Call Graph：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio --children <span class="se">\</span>
      -i textprocessor1.lbr.perf.data

<span class="m">99</span>.36%     <span class="m">0</span>.00%  textprocessor1  textprocessor1     <span class="o">[</span>.<span class="o">]</span> _start
        <span class="p">|</span>
        ---_start
           __libc_start_main
           main
           <span class="p">|</span>
           <span class="p">|</span>--45.63%--string_map_add
           <span class="p">|</span>          <span class="p">|</span>
           <span class="p">|</span>           --28.90%--strcmp@plt
           <span class="p">|</span>
           <span class="p">|</span>--13.05%--string_list_append
           <span class="p">|</span>          <span class="p">|</span>
           <span class="p">|</span>          <span class="p">|</span>--11.81%--__strdup
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>--9.97%--malloc
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          _int_malloc
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>--3.87%--0xffffffff8c2010ee
</pre></div>
<p>這次以 <code>_start</code> 函式為起點的 Stack Trace 佔總樣本數量的 99.36%。這符合我們的預期。其次，我們可以看到 <code>string_map_add</code> 函式呼叫的 <code>strcmp</code> 函式佔去 28.90%，值得進一步分析。（備註：這個 Call Graph 有很多 0xffffffff8c2010ee 之類的函式。這些其實是 Linux 核心內部的函式，可以暫時忽略。）</p>
<p>第八步，反過來用 <code>perf report --no-children</code> 觀察 Callee-based Call Graph：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio --no-children <span class="se">\</span>
      -i textprocessor1.lbr.perf.data

<span class="m">33</span>.44%  textprocessor1  libc-2.27.so <span class="o">[</span>.<span class="o">]</span> __strcmp_sse2_unaligned
        <span class="p">|</span>
        <span class="p">|</span>--23.73%--strcmp@plt
        <span class="p">|</span>          string_map_add
        <span class="p">|</span>          main
        <span class="p">|</span>          __libc_start_main
        <span class="p">|</span>          _start
        <span class="p">|</span>
        <span class="p">|</span>--4.95%--string_map_add
        <span class="p">|</span>          main
        <span class="p">|</span>          __libc_start_main
        <span class="p">|</span>          _start
        <span class="p">|</span>
         --4.68%--str_ptr_compare
                   msort_with_tmp.part.0
                   <span class="p">|</span>
                   <span class="p">|</span>--4.13%--msort_with_tmp.part.0
</pre></div>
<p>我們能看到 <code>string_map_add</code> 函式裡的 <code>strcmp</code> 函式呼叫確實是很大的問題。我們看看 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor1.c">textprocessor1.c</a> 的程式碼：</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">string_map_add</span><span class="p">(</span><span class="n">string_map</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Find the matching key and add the value to the list.</span>
  <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">num_elements</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">string_list_append</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// ... skipped ...</span>

  <span class="n">string_map_entry</span> <span class="o">*</span><span class="n">ent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">num_elements</span><span class="p">];</span>
  <span class="n">ent</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">;</span>
  <span class="n">ent</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_list</span><span class="p">;</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">num_elements</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>這段程式透過「循序搜尋」尋找對應的「鍵」。然而從演算法的時間複雜度來看，這是沒有效率的選擇。在不改變架構的前提下，我把 <code>string_map</code> 改以 Sorted Array 與 Binary Search 實作（<a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor2.c">textprocessor2.c</a>）：</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">string_map_add</span><span class="p">(</span><span class="n">string_map</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// Find the matching key and add the value to the list.</span>
  <span class="kt">size_t</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">num_elements</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">string_list_append</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// ... skipped ...</span>

  <span class="n">memmove</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">elements</span> <span class="o">+</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">elements</span> <span class="o">+</span> <span class="n">start</span><span class="p">,</span>
          <span class="k">sizeof</span><span class="p">(</span><span class="n">string_map_entry</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">num_elements</span> <span class="o">-</span> <span class="n">start</span><span class="p">));</span>
  <span class="n">string_map_entry</span> <span class="o">*</span><span class="n">ent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
  <span class="n">ent</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">;</span>
  <span class="n">ent</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_list</span><span class="p">;</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">num_elements</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>第九步，下載 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor2.c">textprocessor2.c</a> 並重新編譯：</p>
<div class="highlight"><pre><span></span>$ gcc -O2 -fno-omit-frame-pointer -fno-inline -g <span class="se">\</span>
      textprocessor2.c -o textprocessor2
</pre></div>
<p>重新以 <code>perf stat</code> 測量：</p>
<div class="highlight"><pre><span></span>$ sudo perf stat <span class="se">\</span>
      ./textprocessor2 input.txt /dev/null

<span class="c1"># started on Sun Oct  6 21:40:44 2019</span>
Performance counter stats <span class="k">for</span> <span class="s1">'./textprocessor2 input.txt /dev/null'</span>:

      <span class="m">1</span>,090.55 msec task-clock       <span class="c1">#    1.000 CPUs utilized</span>
             <span class="m">5</span>      context-switches <span class="c1">#    0.005 K/sec</span>
             <span class="m">0</span>      cpu-migrations   <span class="c1">#    0.000 K/sec</span>
       <span class="m">106</span>,011      page-faults      <span class="c1">#    0.097 M/sec</span>
 <span class="m">2</span>,973,836,135      cycles           <span class="c1">#    2.727 GHz</span>
 <span class="m">2</span>,754,413,677      instructions     <span class="c1">#    0.93  insn per cycle</span>
   <span class="m">555</span>,628,887      branches         <span class="c1">#  509.493 M/sec</span>
    <span class="m">13</span>,331,051      branch-misses    <span class="c1">#    2.40% of all branches</span>

   <span class="m">1</span>.090851312 seconds <span class="nb">time</span> elapsed

   <span class="m">0</span>.910295000 seconds user
   <span class="m">0</span>.180455000 seconds sys
</pre></div>
<p>很明顯地，使用的時間從 1.676 秒降到 1.091 秒（-34.93%），是一個好的開始。</p>
<p>重新以 <code>perf report -g --call-graph lbr</code> 取樣：</p>
<div class="highlight"><pre><span></span>$ sudo perf record -g --call-graph lbr <span class="se">\</span>
      -o textprocessor2.lbr.perf.data <span class="se">\</span>
      ./textprocessor2 input.txt /dev/null
</pre></div>
<p>第十步，再次使用 <code>perf report --no-children</code> 觀察 Callee-based Call Graph：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio --no-children <span class="se">\</span>
      -i textprocessor2.lbr.perf.data

<span class="m">14</span>.35%  textprocessor2  libc-2.27.so       <span class="o">[</span>.<span class="o">]</span> cfree@GLIBC_2.2.5
    <span class="p">|</span>
     --14.31%--free@plt
               string_list_delete
               string_map_delete
               main
               __libc_start_main
               _start
</pre></div>
<p>這次花去最多時間的函式是 glibc 的 <code>free</code> 函式。<code>free</code> 函式的主要工作是更新記憶體配置器的資料結構，使得之後的 <code>malloc</code> 函式呼叫能重複利用這些被釋放的記憶體。然而，對我們的範例程式而言，所有的 <code>free</code> 函式都是在程式最後的清理階段呼叫的，其實我們並不在乎這些記憶體能不能被重複使用。一個不負責任的作法是直接刪除所有的 <code>free</code> 函式呼叫。比較正規的作法是引入 <a class="reference external" href="https://en.wikipedia.org/wiki/Region-based_memory_management">Arena Allocator</a>。Arena Allocator 會向 C 語言函式庫的記憶體配置器要求一大塊記憶體，然後自行管理記憶體。使用完畢之後，再一次歸還所有記憶體。<a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor3.c">textprocessor3.c</a> 實作了一個簡單的 Arena Allocator，並將原本的 <code>malloc</code> 函式呼叫代換為 <code>arena_alloc</code> 函式呼叫：</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">arena_allocator</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">buf_head</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">begin</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">arena_allocator</span> <span class="o">*</span><span class="nf">arena_new</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">arena_allocator</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span>
      <span class="p">(</span><span class="n">arena_allocator</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arena_allocator</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">buf_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">begin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arena_delete</span><span class="p">(</span><span class="n">arena_allocator</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">buf_head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">void</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">cur</span><span class="p">;</span>
      <span class="n">free</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">arena_alloc</span><span class="p">(</span><span class="n">arena_allocator</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="kt">size_t</span> <span class="n">aligned_begin</span> <span class="o">=</span> <span class="n">ARENA_ALLOC_ALIGN</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">aligned_end</span> <span class="o">=</span> <span class="n">aligned_begin</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">buf_head</span> <span class="o">&amp;&amp;</span> <span class="n">aligned_end</span> <span class="o">&lt;=</span> <span class="n">ARENA_ALLOC_BUF_SIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">buf_head</span> <span class="o">+</span> <span class="n">aligned_begin</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">begin</span> <span class="o">=</span> <span class="n">aligned_end</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">size_t</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">ARENA_ALLOC_BUF_SIZE</span><span class="p">);</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">buf</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">buf_head</span><span class="p">;</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">buf_head</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">begin</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">buf</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>第十一步，下載 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor3.c">textprocessor3.c</a> 並重新編譯：</p>
<div class="highlight"><pre><span></span>$ gcc -O2 -fno-omit-frame-pointer -fno-inline -g <span class="se">\</span>
      textprocessor3.c -o textprocessor3
</pre></div>
<p>重新以 <code>perf stat</code> 測量：</p>
<div class="highlight"><pre><span></span>$ sudo perf stat <span class="se">\</span>
      ./textprocessor3 input.txt /dev/null

<span class="c1"># started on Sun Oct  6 21:40:45 2019</span>
Performance counter stats <span class="k">for</span> <span class="s1">'./textprocessor3 input.txt /dev/null'</span>:

            <span class="m">841</span>.33 msec task-clock       <span class="c1">#    1.000 CPUs utilized</span>
                 <span class="m">8</span>      context-switches <span class="c1">#    0.010 K/sec</span>
                 <span class="m">0</span>      cpu-migrations   <span class="c1">#    0.000 K/sec</span>
           <span class="m">105</span>,264      page-faults      <span class="c1">#    0.125 M/sec</span>
     <span class="m">2</span>,595,040,498      cycles           <span class="c1">#    3.084 GHz</span>
     <span class="m">2</span>,600,730,011      instructions     <span class="c1">#    1.00  insn per cycle</span>
       <span class="m">545</span>,582,983      branches         <span class="c1">#  648.473 M/sec</span>
        <span class="m">13</span>,110,046      branch-misses    <span class="c1">#    2.40% of all branches</span>

       <span class="m">0</span>.841712243 seconds <span class="nb">time</span> elapsed

       <span class="m">0</span>.641217000 seconds user
       <span class="m">0</span>.200380000 seconds sys
</pre></div>
<p>使用的時間再次從 1.091 秒降到 0.842 秒（-22.84%）。</p>
<p>第十二步，再次使用 <code>perf record -g --call-graph lbr</code> 取樣：</p>
<div class="highlight"><pre><span></span>$ sudo perf record -g --call-graph lbr <span class="se">\</span>
      -o textprocessor3.lbr.perf.data <span class="se">\</span>
      ./textprocessor3 input.txt /dev/null
</pre></div>
<p>然後使用 <code>perf report --no-children</code> 觀察 Callee-based Call Graph：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio --no-children <span class="se">\</span>
      -i textprocessor3.lbr.perf.data

<span class="m">16</span>.11%  textprocessor3  libc-2.27.so       <span class="o">[</span>.<span class="o">]</span> __strcmp_sse2_unaligned
        <span class="p">|</span>
        <span class="p">|</span>--10.41%--str_ptr_compare
        <span class="p">|</span>          msort_with_tmp.part.0
        <span class="p">|</span>          <span class="p">|</span>
... skipped ...
        <span class="p">|</span>          <span class="p">|</span>
        <span class="p">|</span>           --1.13%--__GI___qsort_r
        <span class="p">|</span>                     string_map_sort
        <span class="p">|</span>                     main
        <span class="p">|</span>                     __libc_start_main
        <span class="p">|</span>                     _start
        <span class="p">|</span>
         --5.49%--strcmp@plt
                   string_map_add
                   main
                   __libc_start_main
                   _start

<span class="m">12</span>.77%  textprocessor3  libc-2.27.so       <span class="o">[</span>.<span class="o">]</span> __strlen_avx2
        <span class="p">|</span>
        <span class="p">|</span>--11.93%--@plt
        <span class="p">|</span>          _IO_fputs
        <span class="p">|</span>          string_map_dump
        <span class="p">|</span>          main
        <span class="p">|</span>          __libc_start_main
        <span class="p">|</span>          _start
        <span class="p">|</span>
         --0.82%--strlen@plt
                   string_list_append
                   main
                   __libc_start_main
                   _start
</pre></div>
<p>這次次數最高的函式是 <code>__strcmp_sse2_unaligned</code>。然而呼叫它的呼叫者分別是 <code>string_map_sort</code> 與 <code>string_map_add</code>，在不改動資料結構的前提下，能最佳化的空間應該不大了。</p>
<p>接著，我們可以把目光轉向次高的函式 <code>__strlen_avx2</code>。它的呼叫者是 <code>fputs</code>。因為 <code>fputs</code> 的參數只有一個 C-style String，所以它必須呼叫 <code>strlen</code> 函式取得字串長度。</p>
<p><a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor3.c">textprocessor3.c</a> 在 <code>string_list_append</code> 的時候就會計算字串長度，所以或許我們可以記錄字串長度，再直接呼叫 <code>fwrite</code> 節省 <code>strlen</code>。在這個構想下，<a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor4.c">textprocessor4.c</a> 定義了 <code>string</code>：</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">string</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[];</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">string_list_append</span><span class="p">(</span><span class="n">string_list</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span>
                       <span class="n">arena_allocator</span> <span class="o">*</span><span class="n">allocator</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">new_str</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span> <span class="o">*</span><span class="p">)</span><span class="n">arena_alloc</span><span class="p">(</span>
      <span class="n">allocator</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">new_str</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">new_str</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// ... skipped ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">string_map_dump</span><span class="p">(</span><span class="n">string_map</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">num_elements</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... skipped ...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">num_elements</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fputc</span><span class="p">(</span><span class="sc">'\t'</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
      <span class="n">fwrite</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
      <span class="n">fputc</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>第十三步，下載 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor4.c">textprocessor4.c</a> 並重新編譯：</p>
<div class="highlight"><pre><span></span>$ gcc -O2 -fno-omit-frame-pointer -fno-inline -g <span class="se">\</span>
      textprocessor4.c -o textprocessor4
</pre></div>
<p>重新以 <code>perf stat</code> 測量：</p>
<div class="highlight"><pre><span></span>$ sudo perf stat <span class="se">\</span>
      ./textprocessor4 input.txt /dev/null

<span class="c1"># started on Sun Oct  6 21:40:46 2019</span>
 Performance counter stats <span class="k">for</span> <span class="s1">'./textprocessor4 input.txt /dev/null'</span>:

            <span class="m">824</span>.87 msec task-clock       <span class="c1">#    1.000 CPUs utilized</span>
                 <span class="m">3</span>      context-switches <span class="c1">#    0.004 K/sec</span>
                 <span class="m">0</span>      cpu-migrations   <span class="c1">#    0.000 K/sec</span>
           <span class="m">106</span>,827      page-faults      <span class="c1">#    0.130 M/sec</span>
     <span class="m">2</span>,546,158,876      cycles           <span class="c1">#    3.087 GHz</span>
     <span class="m">2</span>,529,577,956      instructions     <span class="c1">#    0.99  insn per cycle</span>
       <span class="m">520</span>,276,190      branches         <span class="c1">#  630.740 M/sec</span>
        <span class="m">12</span>,139,306      branch-misses    <span class="c1">#    2.33% of all branches</span>

       <span class="m">0</span>.825163632 seconds <span class="nb">time</span> elapsed

       <span class="m">0</span>.601894000 seconds user
       <span class="m">0</span>.223219000 seconds sys
</pre></div>
<p>使用的時間好像是從 0.842 秒降到 0.8252 秒。然而這其實是測量誤差。多跑幾次偶爾會有 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor4.c">textprocessor4.c</a> 跑的比較慢的數據（儘管差異不大）。我們可以用 <code>perf record</code> 取樣，分析為何前面的最佳化沒有發揮作用：</p>
<div class="highlight"><pre><span></span>$ sudo perf record -g --call-graph lbr <span class="se">\</span>
      -o textprocessor4.lbr.perf.data <span class="se">\</span>
      ./textprocessor4 input.txt /dev/null

$ sudo perf report --stdio --no-children <span class="se">\</span>
      -i textprocessor4.lbr.perf.data

<span class="m">19</span>.11%  textprocessor4  libc-2.27.so <span class="o">[</span>.<span class="o">]</span> __memmove_avx_unaligned_erms
        <span class="p">|</span>
        <span class="p">|</span>--12.86%--@plt
        <span class="p">|</span>          <span class="p">|</span>
        <span class="p">|</span>          <span class="p">|</span>--11.31%--_IO_file_xsputn@@GLIBC_2.2.5
        <span class="p">|</span>          <span class="p">|</span>          _IO_fwrite
        <span class="p">|</span>          <span class="p">|</span>          string_map_dump
        <span class="p">|</span>          <span class="p">|</span>          main
        <span class="p">|</span>          <span class="p">|</span>          __libc_start_main
        <span class="p">|</span>          <span class="p">|</span>          _start
... skipped ...
</pre></div>
<p>對照 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor3.c">textprocessor3.c</a> 的 Call Graph：</p>
<div class="highlight"><pre><span></span>$ sudo perf report --stdio --no-children <span class="se">\</span>
      -i textprocessor3.lbr.perf.data

<span class="m">12</span>.77%  textprocessor3  libc-2.27.so <span class="o">[</span>.<span class="o">]</span> __strlen_avx2
        <span class="p">|</span>
        <span class="p">|</span>--11.93%--@plt
        <span class="p">|</span>          _IO_fputs
        <span class="p">|</span>          string_map_dump
        <span class="p">|</span>          main
        <span class="p">|</span>          __libc_start_main
        <span class="p">|</span>          _start
... skipped ...

 <span class="m">8</span>.31%  textprocessor3  libc-2.27.so <span class="o">[</span>.<span class="o">]</span> __memmove_avx_unaligned_erms
... skipped ...
        <span class="p">|</span>
        <span class="p">|</span>--1.86%--@plt
        <span class="p">|</span>          <span class="p">|</span>
... skipped ...
        <span class="p">|</span>          <span class="p">|</span>
        <span class="p">|</span>           --0.72%--_IO_file_xsputn@@GLIBC_2.2.5
        <span class="p">|</span>                     _IO_fputs
        <span class="p">|</span>                     string_map_dump
        <span class="p">|</span>                     main
        <span class="p">|</span>                     __libc_start_main
        <span class="p">|</span>                     _start
</pre></div>
<p>我們能注意到在 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor3.c">textprocessor3.c</a> 裡面的 <code>__memmove_avx_unaligned_erms</code> 跑得很快。一種可能性是因為 <code>strlen</code> 會把等下 <code>memmove</code> 會讀到的資料帶進快取（Cache），所以 <code>memmove</code> 函式幾乎不佔用任何時間。在既有測試資料下，<a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor4.c">textprocessor4.c</a> 並不能帶來任何改進。如果「值」的字串長度會大於 L3 Cache 的大小，或許 <a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/textprocessor4.c">textprocessor4.c</a> 就能展示它的價值。</p>
<p>很多時候效能分析會和程式設計師想得不太一樣。直覺告訴我們指令的數量應該和執行時間成正比。若能減少 CPU 必須執行的指令，總執行時間應該會同步縮減。然而現代的計算機結構有很多機制能幫我們隱藏 Latency（延遲），如果我們最佳化的程式碼不在 Critical Path（關鍵路徑）上，總執行時間是不會有變化的。這再次提醒我們以系統化的方法分析程式效能的重要性。</p>
<p>扣除 <code>strlen</code> 函式之後，在不改動資料結構的前提下，已經沒有多少簡單的最佳化了。所以本節就在此告一個段落。當然這個程式一定還有不少改進空間。例如，我沒有嘗試紅黑樹、雜湊表等等比較複雜的資料結構。其次，<a class="reference external" href="https://zh-blog.logan.tw/static/sourcecode/2019/10/06/gen_test_data.py">gen_test_data.py</a> 產生的測試資料非常固定。如果要更完整地測試程式效能，應該要產生不同長度的字串。這些就留給各位讀者練習。</p>
<p><strong>小結</strong>：本節以一個簡單的文字處理程式展示程式效能的分析方法與兩種 Call Graph 的判讀方法。除此之外，也展示了一些平常分析程式時會遇到的狀況。最後，以一個「沒有用的最佳化」結尾。雖然這樣的結果可能會令人感到挫折，不過這就是效能分析工程師的日常生活。一個方法不成功，就分析為什麼不成功，之後建立假說、實驗、再改進方法。</p>
</div>
<div class="section" id="id8">
<h2>結語</h2>
<p>本文從<a class="reference internal" href="https://zh-blog.logan.tw/2019/10/06/intro-to-perf-events-and-call-graph/#call-graph">Call Graph 的原理</a>談起，接著再介紹<a class="reference internal" href="https://zh-blog.logan.tw/2019/10/06/intro-to-perf-events-and-call-graph/#id2">記錄 Stack Trace 的注意事項</a>與<a class="reference internal" href="https://zh-blog.logan.tw/2019/10/06/intro-to-perf-events-and-call-graph/#id4">Call Graph 的判讀方法</a>。最後本文以一個<a class="reference internal" href="https://zh-blog.logan.tw/2019/10/06/intro-to-perf-events-and-call-graph/#id7">實際的例子</a>示範如何使用 Perf Events 分析與最佳化程式。</p>
<p>希望這篇文章能對各位讀者的工作有所助益。如果文章有任何錯誤，也請不吝指教。</p>
</div>
<div class="section" id="id9">
<h2>系列文章</h2>
<ol class="arabic simple">
<li><a class="reference external" href="https://zh-blog.logan.tw/2019/07/10/analyze-program-performance-with-perf-events/">使用 perf_events 分析程式效能</a></li>
<li><strong>簡介 perf_events 與 Call Graph</strong>（本文）</li>
</ol>
</div>
<div class="section" id="id11">
<h2>參考資料</h2>
<ul class="simple">
<li><a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/perf-report.txt">perf-report(1) Manual Page</a></li>
<li>Brendan Gregg, <a class="reference external" href="http://www.brendangregg.com/perf.html">perf Examples</a></li>
<li>Brendan Gregg, <a class="reference external" href="http://www.brendangregg.com/flamegraphs.html">Flame Graphs</a></li>
<li>Andi Kleen, (2016).  <a class="reference external" href="https://lwn.net/Articles/680985/">An introduction to last branch records</a>, LWN.net</li>
<li><a class="reference external" href="https://software.intel.com/en-us/articles/intel-sdm">Intel 64 and IA-32 Architectures Software Developer's Manual</a>, Volume 3 Section 17.11 Last Branch, Call Stack, Interrupt, and Exception Recording for Processors Based on Haswell Microarchitecture</li>
<li>Linux Kernel, <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/perf/util/machine.c">tools/perf/util/machine.c</a>, <code>resolve_lbr_callchain_sample()</code></li>
<li><a class="reference external" href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=767756">Debian Bug #767756</a>: glibc: Consider providing a libc build compiled with -fno-omit-frame-pointer to help with profiling</li>
</ul>

</div>

</div>

		</div>


	</div>

	<script type="text/javascript" async="" src="./簡介 perf_events 與 Call Graph_files/ga.js"></script><script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-57011197-3']);
	_gaq.push(['_trackPageview']);
	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = 'https://ssl.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
	</script>

</body></html>